<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.ProgramSynthesis.Common</name>
    </assembly>
    <members>
        <member name="T:Microsoft.ProgramSynthesis.AST.ASTSerializationFormat">
            <summary>
                The format of serialization of AST into strings. Used in
                <see cref="!:ProgramNode.Parse(string,Symbol,ASTSerializationFormat,DeserializationContext)" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.AST.LetNode.LetRule">
            <summary>
                <see cref="P:Microsoft.ProgramSynthesis.AST.NonterminalNode.Rule" /> cast to <see cref="P:Microsoft.ProgramSynthesis.AST.LetNode.LetRule" />.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.AST.NamespaceDoc">
            <summary>
                Classes for representing programs in memory,
                which are made out of <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/> and its subclasses.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.AST.Extensions.NamespaceDoc">
            <summary>
                Helper methods for <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/> defined in <see cref="T:Microsoft.ProgramSynthesis.AST.Extensions.ProgramNodeExtensions"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Extensions.ProgramNodeExtensions.PreTraverse(Microsoft.ProgramSynthesis.AST.ProgramNode,System.Action{Microsoft.ProgramSynthesis.AST.ProgramNode})">
            <summary>
             Applies a callback to each descendant, starting with itself. Returns this for chaining purposes.
            </summary>
            <param name="program">The <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> to traverse.</param>
            <param name="action">The function to apply to every program node</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Extensions.ProgramNodeExtensions.PreMap(Microsoft.ProgramSynthesis.AST.ProgramNode,System.Func{Microsoft.ProgramSynthesis.AST.ProgramNode,System.Int32,Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode},Microsoft.ProgramSynthesis.AST.ProgramNode,System.Int32)">
            <summary>
             Transforms a programNode to another using the given function.
             Clones the programNode if the transformation returned null.
            </summary>
            <param name="program">The <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> to transform.</param>
            <param name="transformation">The function which applied to (parent, indexInParent, this) returns a programNode if this should be change, and null otherwise</param>
            <param name="parent">The parent of this node</param>
            <param name="indexInParent">The index where it appears in his parent</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Extensions.ProgramNodeExtensions.PostTraverse(Microsoft.ProgramSynthesis.AST.ProgramNode,System.Action{Microsoft.ProgramSynthesis.AST.ProgramNode})">
            <summary>
             Applies a callback to each descendant, ending with itself
            </summary>
            <param name="program">The <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> to traverse.</param>
            <param name="action">The function to apply to every program node</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Extensions.ProgramNodeExtensions.AddConversionRules(Microsoft.ProgramSynthesis.AST.ProgramNode,System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Rules.ConversionRule})">
            <summary>
                Creates a new program node starting by adding conversion rules to <paramref name="program"/>.
            </summary>
            <param name="program"><see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> to wrap in conversions.</param>
            <param name="conversions">Conversion rules to apply.</param>
            <returns><see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> of <paramref name="program" /> and conversions <paramref name="conversions"/>.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Extensions.ProgramNodeExtensions.AddConversionRules(Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.Symbol)">
            <summary>
                Creates a new program node starting at <paramref name="symbol"/> by adding conversion rules to <paramref name="program"/>.
            </summary>
            <param name="program"><see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> to wrap in conversions.</param>
            <param name="symbol">Output symbol.</param>
            <returns><see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> of <paramref name="program" /> and conversions to <paramref name="symbol" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Extensions.ProgramNodeExtensions.GetFreeVariables(Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Finds the free variables in a program node. This is the set of variables that will (usually) be looked up in the
                argument to <see cref="M:Microsoft.ProgramSynthesis.AST.ProgramNode.Invoke(Microsoft.ProgramSynthesis.State)" />.
            </summary>
            <param name="node">Program node to examine.</param>
            <returns>The set of free variables in <paramref name="node" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Extensions.ProgramNodeExtensions.EnumerateDescendants(Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Enumerate a program and all of its subprograms, recursively.
            </summary>
            <param name="node">A <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" />.</param>
            <returns>An enumeration starting with <paramref name="node" /> and containing all of it descendants.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Extensions.ProgramNodeExtensions.ClearCaches(Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Clear all internal caches from this node to reduce memory footprint.
            </summary>
            <param name="node">The program node to clear caches from.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.AST.ParseContext">
            <summary>
                Simple, immutable, and internal container for various context elements and helpers when parsing.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.ParseContext.WithGrammar(Microsoft.ProgramSynthesis.Grammar)">
            <summary>
                Create a new <see cref="T:Microsoft.ProgramSynthesis.AST.ParseContext" /> with the grammar replaced by the given value.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.ParseContext.WithScope(System.Collections.Immutable.ImmutableStack{Microsoft.ProgramSynthesis.AST.ScopeElement})">
            <summary>
                Create a new <see cref="T:Microsoft.ProgramSynthesis.AST.ParseContext" /> with the scope replaced by the given value.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.AST.ParseSettings">
            <summary>
                Simple and immutable container that encapsulates the public settings to the methods for parsing
                program nodes.
            </summary>
            <remarks>
                This is the location where additional DSL-specific rules for deserialization could be programmatically
                added.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.ParseSettings.#ctor(Microsoft.ProgramSynthesis.AST.DeserializationContext,Microsoft.ProgramSynthesis.Rules.ConversionRule)">
            <summary>
                Construct a container for the public settings for program parsing.
            </summary>
            <param name="context">The deserialization context for types.</param>
            <param name="ruleForBackCompatParsing">
                The rule for which backwards-compatible parsing should be applied.
            </param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.AST.ParseSettings.Context">
            <summary>
                The deserialization context for types.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.AST.ParseSettings.RuleForBackCompatParsing">
            <summary>
                The rule for which backwards-compatible parsing should be applied.  This is for rules that bridge
                to an external grammar.  It allows the variable from the parent grammar to be parsed where the
                matching variable in the child variable is expected.
            </summary>
            <remarks>
                This is only a singleton because we don't have a scenario for multiple rules, and new scenarios
                shouldn't be created because we no longer perform a substitution on the child grammar's rule when
                including it as an external grammar.
            </remarks>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.AST.ProgramNode.FeatureCacheSize">
            <summary>
                The size of the cache for storing computed features.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.ProgramNode.ClearFeatureCache">
            <summary>
                Clear all the computed feature values cached in the program node.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.AST.ProgramNode.GrammarRule">
            <summary>
            Returns the grammar rule associated with this node, or null otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.ProgramNode.AcceptVisitor``1(Microsoft.ProgramSynthesis.AST.ProgramNodeVisitor{``0})">
            <summary>
            Returns the value computed by the hierarchical application of the <paramref name="visitor"/> instance.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.ProgramNode.Parse(System.String,Microsoft.ProgramSynthesis.Symbol,Microsoft.ProgramSynthesis.AST.ASTSerializationFormat,Microsoft.ProgramSynthesis.AST.ParseSettings)">
            <summary>
                Parses a string of the grammar symbol <paramref name="symbol" /> that was deserialized in a
                <paramref name="format" />
                into a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" />/>.
                If the <paramref name="format" /> is <see cref="F:Microsoft.ProgramSynthesis.AST.ASTSerializationFormat.HumanReadable"/>,
                the string must be deserialized from the same grammar (or parsing will fail).
            </summary>
            <param name="ast">The deserialized program.</param>
            <param name="symbol">The symbol corresponding to <paramref name="ast" />.</param>
            <param name="format">The serialization format.</param>
            <param name="settings">The settings for parsing to pass through to all deserialization methods.</param>
            <returns>The program node.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.ProgramNode.ParseXML(Microsoft.ProgramSynthesis.Grammar,System.Xml.Linq.XElement,Microsoft.ProgramSynthesis.AST.ParseSettings)">
            <summary>
                Parses a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/> rooted at the start symbol of <paramref name="grammar"/>
                that was serialized into a given <paramref name="node"/> by
                <see cref="M:Microsoft.ProgramSynthesis.AST.ProgramNode.PrintAST(Microsoft.ProgramSynthesis.AST.ASTSerializationFormat)"/> with <see cref="F:Microsoft.ProgramSynthesis.AST.ASTSerializationFormat.XML"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.ProgramNode.ParseXML(Microsoft.ProgramSynthesis.Symbol,System.Xml.Linq.XElement,Microsoft.ProgramSynthesis.AST.ParseSettings,System.Collections.Generic.Dictionary{System.Int32,System.Object})">
            <summary>
                Parses a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/> rooted at <paramref name="symbol"/> that was serialized into a given
                <paramref name="node"/> by <see cref="M:Microsoft.ProgramSynthesis.AST.ProgramNode.PrintAST(Microsoft.ProgramSynthesis.AST.ASTSerializationFormat)"/>
                with <see cref="F:Microsoft.ProgramSynthesis.AST.ASTSerializationFormat.XML"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.ProgramNode.Parse(System.String,Microsoft.ProgramSynthesis.Grammar,Microsoft.ProgramSynthesis.AST.ASTSerializationFormat,Microsoft.ProgramSynthesis.AST.ParseSettings)">
            <summary>
                Parses a string that was deserialized in a <paramref name="format" /> into a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> according
                to the <paramref name="grammar" />.
                If the <paramref name="format" /> is human readable, the string must be deserialized from the same grammar (or
                parsing will fail).
            </summary>
            <param name="ast">The deserialized program.</param>
            <param name="grammar">The grammar.</param>
            <param name="format">The serialization format.</param>
            <param name="settings">The settings for parsing to pass through to all deserialization methods.</param>
            <returns>The program node.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.AST.IProgramNodeBuilder">
            <summary>
                Wraps a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/>.  A base class from which <c>dslc</c> will derive
                classes for types constructors for <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/>s.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.AST.IProgramNodeBuilder.Node">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/> that is wrapped by this <see cref="T:Microsoft.ProgramSynthesis.AST.IProgramNodeBuilder"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.AST.ScopeElement">
            <summary>
                Representation of a variable in scope when parsing.  It may be a simple definition or a substitution
                caused by an external grammar.  In that case, the lookup should continue with the other variable.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.AST.StdLiteralParsing">
            <summary>
            Contains a set of utility methods for parsing literal values, produced by <see cref="N:Microsoft.ProgramSynthesis"/>.
            Values of primitive .NET types and arrays are parsed natively. User-defined types are parsed using the methods
            <see cref="P:Microsoft.ProgramSynthesis.Utils.ParseableAttribute.ParseXML"/> and <see cref="P:Microsoft.ProgramSynthesis.Utils.ParseableAttribute.ParseHumanReadableString"/> in the associated
            <see cref="T:Microsoft.ProgramSynthesis.Utils.ParseableAttribute"/> instance for the expected type.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.AST.Visitors.HumanReadablePrintVisitor">
            <summary>
            <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNodeVisitor`1"/> implementation used to get human readable representation of a
            program node.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.AST.Visitors.NamespaceDoc">
            <summary>
                Visitors for printing an AST in either human-readable (<see cref="T:Microsoft.ProgramSynthesis.AST.Visitors.HumanReadablePrintVisitor"/>)
                or XML (<see cref="T:Microsoft.ProgramSynthesis.AST.Visitors.XmlPrintVisitor"/>) format.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.AST.Visitors.XmlPrintVisitor">
            <summary>
            <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNodeVisitor`1"/> implementation used to get an <see cref="T:System.Xml.Linq.XElement"/> representation of a program node.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_ReferenceNotFound">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Referenced file not found: {0}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_ReferenceNotFound.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Referenced file not found: {0}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_TypeLocationNotFound">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Type {0} is not found in any of the referenced assemblies. Check that it is public and is in scope of all imported namespaces.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_TypeLocationNotFound.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Type {0} is not found in any of the referenced assemblies. Check that it is public and is in scope of all imported namespaces.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_TypeIsNotStatic">
            <summary>
            Represents a diagnostic that produces a warning message similar to: &quot;Type {0} should be a public static class.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_TypeIsNotStatic.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces a warning message similar to: &quot;Type {0} should be a public static class.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_MemberNotFound">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Member {0} not found in the specified class {1}. Check that it is public and static.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_MemberNotFound.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Member {0} not found in the specified class {1}. Check that it is public and static.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_UnknownReferenceType">
            <summary>
            Represents a diagnostic that produces a warning message similar to: &quot;Cannot load a reference from the file &apos;{0}&apos;. Currently supported references are: .NET assemblies (.dll/.exe), Microsoft.ProgramSynthesis compiled grammars (.grammar.xml).&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_UnknownReferenceType.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces a warning message similar to: &quot;Cannot load a reference from the file &apos;{0}&apos;. Currently supported references are: .NET assemblies (.dll/.exe).&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_UnknownExternalGrammar">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Unknown external language: &apos;{0}&apos;.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_UnknownExternalGrammar.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Unknown external language: &apos;{0}&apos;.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_UnknownSymbol">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Symbol {0} was not found in the language {1}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_UnknownSymbol.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Symbol {0} was not found in the language {1}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_AssemblyNotFound">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Could not resolve an assembly name &apos;{0}&apos;.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_AssemblyNotFound.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Could not resolve an assembly name &apos;{0}&apos;.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_CompilationFailed">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Could not compile grammar assembly.  Compiler messages: {0}&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_CompilationFailed.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Could not compile grammar assembly.  Compiler messages: {0}&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_InvalidRuleName">
            <summary>
            Represents a diagnostic that produces a warning message similar to: &quot;Member {0} references invalid rule name &apos;{1}&apos;. This rule does not exist in the language {2}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_InvalidRuleName.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces a warning message similar to: &quot;Member {0} references invalid rule name &apos;{1}&apos;. This rule does not exist in the language {2}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_UndeclaredExternalGrammar">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Undeclared external language: &apos;{0}&apos;. Use &apos;using grammar &lt;name&gt;=&lt;class&gt;.&lt;property&gt;&apos; to refer to a previously compiled grammar&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_UndeclaredExternalGrammar.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Undeclared external language: &apos;{0}&apos;. Use &apos;using grammar &lt;name&gt;=&lt;class&gt;.&lt;property&gt;&apos; to refer to a previously compiled grammar&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_DuplicateExternalGrammar">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Duplicate external language: &apos;{0}&apos;.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_DuplicateExternalGrammar.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Duplicate external language: &apos;{0}&apos;.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_UnknownFeature">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Feature &apos;{0}&apos; was not found in the language {1}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_UnknownFeature.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Feature &apos;{0}&apos; was not found in the language {1}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_IncompatibleCalculatorReturnType">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;In the feature calculator {0}, return type {1} cannot be converted to the required feature type {2}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_IncompatibleCalculatorReturnType.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;In the feature calculator {0}, return type {1} cannot be converted to the required feature type {2}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_NoFeatureCalculator">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;No &apos;{0}&apos; feature calculator was found for the rule {1}. Please define a public function in the class {2} and mark it with [FeatureCalculator] attribute.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_NoFeatureCalculator.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;No &apos;{0}&apos; feature calculator was found for the rule {1}. Please define a public function in the class {2} and mark it with [FeatureCalculator] attribute.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_NoLearningInfoParameter">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Expected a learning info parameter of type LearningInfo as the first parameter.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_NoLearningInfoParameter.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Expected a learning info parameter of type LearningInfo as the first parameter.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_ExpectedNonterminalCalculator">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;In nonterminal feature calculator {0}, parameter &apos;{1}&apos; has type {2}, expected a type derived from ProgramNode.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_ExpectedNonterminalCalculator.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;In nonterminal feature calculator {0}, parameter &apos;{1}&apos; has type {2}, expected a type derived from ProgramNode.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_ExpectedLiteralCalculator">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Literal feature calculator {0} has {1} parameters, expected {2}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_ExpectedLiteralCalculator.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Literal feature calculator {0} has {1} parameters, expected {2}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_ExpectedRecursiveCalculator">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;In feature &apos;{0}&apos; calculator {1}, parameter &apos;{2}&apos; has type {3}, expected {4}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_ExpectedRecursiveCalculator.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;In feature &apos;{0}&apos; calculator {1}, parameter &apos;{2}&apos; has type {3}, expected {4}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_AmbiguousFeatureCalculator">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Ambiguous &apos;{0}&apos; feature calculator for the rule {1}: cannot choose between {2} and {3}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_AmbiguousFeatureCalculator.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Ambiguous &apos;{0}&apos; feature calculator for the rule {1}: cannot choose between {2} and {3}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_InvalidRuleName">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;In feature &apos;{0}&apos; calculator {1}, the rule name &apos;{2}&apos; is invalid. Rule names must be valid C# identifiers (may contain only alphanumeric symbols and underscores).&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_InvalidRuleName.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;In feature &apos;{0}&apos; calculator {1}, the rule name &apos;{2}&apos; is invalid. Rule names must be valid C# identifiers (may contain only alphanumeric symbols and underscores).&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_VarDefaultNotGiven">
            <summary>
            Represents a diagnostic that produces a warning message similar to: &quot;Implementation {0} of a complete feature &apos;{1}&apos; does not override the default implementation of {2}, which calculates the value of this feature on variable nodes. {3} will be used instead in order to make the feature complete. If this is not intentional, either remove the @complete annotation or override the method with your implementation&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_VarDefaultNotGiven.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces a warning message similar to: &quot;Implementation {0} of a complete feature &apos;{1}&apos; does not override the default implementation of {2}, which calculates the value of this feature on variable nodes. {3} will be used instead in order to make the feature complete. If this is not intentional, either remove the @complete annotation or override the method with your implementation&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_UnknownRuleName">
            <summary>
            Represents a diagnostic that produces a warning message similar to: &quot;Member {0} references invalid rule name &apos;{1}&apos;. This rule does not exist in the language {2}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_UnknownRuleName.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces a warning message similar to: &quot;Member {0} references invalid rule name &apos;{1}&apos;. This rule does not exist in the language {2}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_IncompatibleCalculatorParameters">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;The feature calculator {0} has {2} parameters but must have {3} parameters to match its rule {1}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_IncompatibleCalculatorParameters.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;The feature calculator {0} has {2} parameters but must have {3} parameters to match its rule {1}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_SymbolCircularDependency">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Circular symbol dependency detected: {0}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_SymbolCircularDependency.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Circular symbol dependency detected: {0}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_NoStartSymbols">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;No start symbols found. Please mark one of the nonterminals of the language as @start.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_NoStartSymbols.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;No start symbols found. Please mark one of the nonterminals of the language as @start.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_MoreThanOneStart">
            <summary>
            Represents a diagnostic that produces a warning message similar to: &quot;More then one start symbol detected: {0}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_MoreThanOneStart.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces a warning message similar to: &quot;More then one start symbol detected: {0}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_NoInputSymbols">
            <summary>
            Represents a diagnostic that produces a warning message similar to: &quot;No input symbols found. Please mark one of the terminals of the language as @input.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_NoInputSymbols.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces a warning message similar to: &quot;No input symbols found. Please mark one of the terminals of the language as @input.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_MoreThanOneInput">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;More then one input symbol detected: {0}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_MoreThanOneInput.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;More then one input symbol detected: {0}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_ConceptParametersShouldBeArguments">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;In concept rule {0}, the set of formal parameters {1} on the left-hand side should be equal to the set of the unbound symbols {2} on the right-hand side.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_ConceptParametersShouldBeArguments.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;In concept rule {0}, the set of formal parameters {1} on the left-hand side should be equal to the set of the unbound symbols {2} on the right-hand side.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_IncompatibleSymbolTypes">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Symbol {0} has type {1}, but is initialized with a symbol {2}, which has type {3}&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_IncompatibleSymbolTypes.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Symbol {0} has type {1}, but is initialized with a symbol {2}, which has type {3}&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_NoLanguageName">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;No language name found.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_NoLanguageName.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;No language name found.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_DuplicateId">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Id {0} was already declared.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_DuplicateId.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Id {0} was already declared.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_InvalidSymbolName">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Invalid symbol identifier. Please ensure the symbol names match [_a-zA-Z][_a-zA-Z0-9]* and do not clash with keywords&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_InvalidSymbolName.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Invalid symbol identifier. Please ensure the symbol names match [_a-zA-Z][_a-zA-Z0-9]* and do not clash with keywords&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Semantics_NoSemantics">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;No semantics found for the rule {0}. Expected a function with signature &apos;public static {1} {0}({2})&apos; in any of the semantics locations.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Semantics_NoSemantics.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;No semantics found for the rule {0}. Expected a function with signature &apos;public static {1} {0}({2})&apos; in any of the semantics locations.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Semantics_AmbiguousSemantics">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Ambiguous semantics for the rule {0}: cannot choose between {1} and {2}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Semantics_AmbiguousSemantics.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Ambiguous semantics for the rule {0}: cannot choose between {1} and {2}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Semantics_IncompatibleSemanticsReturnType">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Semantics function {0} returns {1}, expected {2}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Semantics_IncompatibleSemanticsReturnType.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Semantics function {0} returns {1}, expected {2}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Semantics_IncompatibleConceptArgumentType">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Invalid type {0} of symbol {1}: the concept &apos;{2}&apos; expects an argument of type {3} here.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Semantics_IncompatibleConceptArgumentType.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Invalid type {0} of symbol {1}: the concept &apos;{2}&apos; expects an argument of type {3} here.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Semantics_IncompatibleConceptResultType">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Invalid type {0} of symbol {1}: the concept &apos;{2}&apos; returns a type {3} here.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Semantics_IncompatibleConceptResultType.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Invalid type {0} of symbol {1}: the concept &apos;{2}&apos; returns a type {3} here.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.DeductiveLearning_PlanNotFound">
            <summary>
            Represents a diagnostic that produces a warning message similar to: &quot;Plan class {0} is not found in any of the referenced assemblies. Check that it is a public static class.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.DeductiveLearning_PlanNotFound.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces a warning message similar to: &quot;Plan class {0} is not found in any of the referenced assemblies. Check that it is a public static class.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.DeductiveLearning_IgnoredTerminalWitnesses">
            <summary>
            Represents a diagnostic that produces a warning message similar to: &quot;Illegal witness function specification for the terminal rule {0}, ignored.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.DeductiveLearning_IgnoredTerminalWitnesses.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces a warning message similar to: &quot;Illegal witness function specification for the terminal rule {0}, ignored.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.DeductiveLearning_IncompatibleWitnessRuleType">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Witness function {0} expects rule type {1} as its first parameter, but the rule {2} has type {3}, which cannot be converted to {1}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.DeductiveLearning_IncompatibleWitnessRuleType.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Witness function {0} expects rule type {1} as its first parameter, but the rule {2} has type {3}, which cannot be converted to {1}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.DeductiveLearning_IncompatibleWitnessSignature">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Witness function {0} has a signature that does not derive from (GrammarRule rule, Spec outerSpec, [, Spec prereqs...]) -&gt; Spec.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.DeductiveLearning_IncompatibleWitnessSignature.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Witness function {0} has a signature that does not derive from (GrammarRule rule, Spec outerSpec, [, Spec prereqs...]) -&gt; Spec.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.DeductiveLearning_IncompatibleWitnessPrereqTypes">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Witness function {0} has invalid prerequisite type(s). They must occur after the required GrammarRule and Spec and be in a single parameter of type Spec[] or a series of parameters of types deriving from Spec.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.DeductiveLearning_IncompatibleWitnessPrereqTypes.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Witness function {0} has invalid prerequisite type(s). They must occur after the required GrammarRule and Spec and be in a single parameter of type Spec[] or a series of parameters of types deriving from Spec.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.DeductiveLearning_IncompatibleWitnessParameter">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Witness function {0} has a parameter specification that is out of range of valid parameters for the body of the rule {1}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.DeductiveLearning_IncompatibleWitnessParameter.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Witness function {0} has a parameter specification that is out of range of valid parameters for the body of the rule {1}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.NamespaceDoc">
            <summary>
                Error and warning messages emitted by dslc are of type <see cref="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Result`1">
            <summary>
            Represents a result of a computation that can fail, along with a list of diagnostics, collected during a computation.
            For a successful result, the property <see cref="P:Microsoft.ProgramSynthesis.Diagnostics.Result`1.Value"/> contains the result of computation, null otherwise.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.AbstractRegexToken">
            <summary>
                Supertype for <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegexToken" /> and <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringToken" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.AbstractRegexToken.#ctor(System.Text.RegularExpressions.Regex,System.String,System.Int32,System.Double,System.Func{System.String,System.Double},System.Boolean,System.Boolean,System.String)">
            <summary>
                Constructs a token for use in <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression" /> objects.
            </summary>
            <param name="regex">The <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.AbstractRegexToken.Regex" /> this wraps. Should be compiled (<see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />).</param>
            <param name="name">
                The human-readable name describing what <paramref name="regex" /> matches. The name of a dynamic
                token should be the string it matches enclosed in double quotes (").
            </param>
            <param name="score">
                The score of this token used to determine how good programs are that use it. Tokens with higher
                scores are preferred. Static token scores should not be below <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Token.MinScore" />.
            </param>
            <param name="useForLearning">
                If true, this may appear in learned regular expressions. Otherwise, this is just for
                <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache" /> to cache matches of it.
            </param>
            <param name="evaluateLogLikelihood">
                Given a regex match, what is the log probability of a string being generated by the
                token?
            </param>
            <param name="isSymbol">Is this a symbol (as opposed to alphanumeric)?</param>
            <param name="logPrior">What is the log probability of this token being used vs a different token?</param>
            <param name="canonicalRepresentation">If this is not null, a default string for the token to match.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.AbstractRegexToken.#ctor(System.String,System.String,System.Int32,System.Double,System.Func{System.String,System.Double},System.Boolean,System.Boolean,System.String)">
            <summary>
                Constructs a token for use in <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression" /> objects.
            </summary>
            <param name="pattern">The pattern for the <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.AbstractRegexToken.Regex" /> this wraps.</param>
            <param name="name">
                The human-readable name describing what <paramref name="pattern" /> matches. The name of a dynamic
                token should be the string it matches enclosed in double quotes (").
            </param>
            <param name="score">
                The score of this token used to determine how good programs are that use it. Tokens with higher
                scores are preferred. Static token scores should not be below <see cref="!:MinScore" />.
            </param>
            <param name="useForLearning">
                If true, this may appear in learned regular expressions. Otherwise, this is just for
                <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache" /> to cache matches of it.
            </param>
            <param name="evaluateLogLikelihood">
                Given a regex match, what is the log probability of a string being generated by the
                token?
            </param>
            <param name="isSymbol">Is this a symbol (as opposed to alphanumeric)?</param>
            <param name="logPrior">What is the log probability of this token being used vs a different token?</param>
            <param name="canonicalRepresentation">If this is not null, a default string for the token to match.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.AbstractRegexToken.Regex">
            <summary>
                The regular expression defining what this matches.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.AbstractRegexToken.GetMatches(System.String)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.CachedList">
            <summary>
                A cache of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.PositionMatch" /> objects corresponding to a regular expression matching operation. This is
                used to quickly run regular expression matching a substring. Must be kept sorted.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.CachedList.#ctor">
            <summary>
                Constructs an empty <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.CachedList" />. <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.PositionMatch" /> objects must be added in sorted order.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.CachedList.#ctor(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.DslLibrary.PositionMatch})">
            <summary>
                Constructs a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.CachedList" /> containing the matches in <paramref name="l" />.
            </summary>
            <param name="l">A sorted enumerable of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.PositionMatch" /> objects.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.CachedList.GetValues(System.UInt32,System.UInt32)">
            <summary>
                Return the index span of the cached values within the range
            </summary>
            <param name="start">The beginning of the range</param>
            <param name="end">The end of the range</param>
            <returns>The index span of the cached values within the range</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.CachedList.BinarySearchForFirstGreaterOrEqual(System.UInt32)">
            <summary>
                Finds the index in this list of the first match with a <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.PositionMatch.Position" /> at or after
                <paramref name="key" />.
            </summary>
            <param name="key">The starting string index to start looking for matches at.</param>
            <returns>
                The index of the first <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.PositionMatch" /> after <paramref name="key" /> or -1 if no such match
                exists.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.CachedList.BinarySearchForLastLessThanOrEqual(System.UInt32)">
            <summary>
                Finds the index in this list of the last match with a <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.PositionMatch.Right" /> at or before
                <paramref name="key" />.
            </summary>
            <param name="key">The ending string index to start looking for matches at.</param>
            <returns>
                The index of the last <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.PositionMatch" /> before <paramref name="key" /> or -1 if no such match
                exists.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.BasicDateTimeFormatTranslator">
            <summary>
                Basic datetime format translator that implements generic translation without custom language-specific preprocessing.
                This class should not be instantiated directly. Instead, use <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatTranslator.For(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.Target)"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.ConstantDateTimeFormatPart">
            <summary>
                A <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart"/> which is always exactly the same string.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.ConstantDateTimeFormatPart.#ctor(Microsoft.ProgramSynthesis.DslLibrary.StringRegion)">
            <summary>
                Creates a new <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.ConstantDateTimeFormatPart" />.
            </summary>
            <param name="constant">The string this must match exactly.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.ConstantDateTimeFormatPart.#ctor(System.String)">
            <summary>
                Creates a new <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.ConstantDateTimeFormatPart" />.
            </summary>
            <param name="constant">The string this must match exactly.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.ConstantDateTimeFormatPart.ConstantString">
            <summary>
                The string this matches.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.ConstantDateTimeFormatPart.ToString(System.Int32)">
            <summary>
                Convert a value to a string according to this date format.
                The inverse of <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.ParseFullString(System.String)" />
            </summary>
            <param name="value">Ignored.</param>
            <returns><see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.ConstantDateTimeFormatPart.ConstantString" /></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.ConstantDateTimeFormatPart.ParseNext(Microsoft.ProgramSynthesis.DslLibrary.StringRegion)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.ConstantDateTimeFormatPart.FromConstantFormat(System.String)">
            <summary>
                Parses a datetime format string which matches a constant string.
            </summary>
            <param name="format">A constant datetime format, possibly with escaping to ensure it's interpreted as a constant.</param>
            <returns>
                A <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.ConstantDateTimeFormatPart" /> that corresponds to the same constant string as
                <paramref name="format" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.ConstantDateTimeFormatPart.RenderXML">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.ConstantDateTimeFormatPart.TryParseFromXML(System.Xml.Linq.XElement)">
            <summary>
                Load a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.ConstantDateTimeFormatPart" /> that had been serialized to XML using <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.ConstantDateTimeFormatPart.RenderXML" />.
            </summary>
            <param name="literal">An XML element generated by <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.ConstantDateTimeFormatPart.RenderXML" />.</param>
            <returns>The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.ConstantDateTimeFormatPart" /> deserialized from <paramref name="literal" />.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.SpacerDateTimeFormatPart">
            <summary>
                A <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.ConstantDateTimeFormatPart"/> that represents a spacer
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.SpacerDateTimeFormatPart.RenderXML">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.SpacerDateTimeFormatPart.TryParseFromXML(System.Xml.Linq.XElement)">
            <summary>
                Load a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.ConstantDateTimeFormatPart" /> that had been serialized to XML using <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.SpacerDateTimeFormatPart.RenderXML" />.
            </summary>
            <param name="literal">An XML element generated by <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.SpacerDateTimeFormatPart.RenderXML" />.</param>
            <returns>The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.ConstantDateTimeFormatPart" /> deserialized from <paramref name="literal" />.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.SpacerDateTimeFormatPart.IsEmpty">
            <summary>
                <c>true</c> if and only if the spacer represented by this <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.SpacerDateTimeFormatPart" /> is zero-length.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.EmptyDateTimeFormatPart">
            <summary>
                A place-holder for an empty <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart"/>.
                Mainly used to represent that an optional part was not matched.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.EmptyDateTimeFormatPart.RenderXML">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.EmptyDateTimeFormatPart.TryParseFromXML(System.Xml.Linq.XElement)">
            <summary>
                Load a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.ConstantDateTimeFormatPart" /> that had been serialized to XML using <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.EmptyDateTimeFormatPart.RenderXML" />.
            </summary>
            <param name="literal">An XML element generated by <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.EmptyDateTimeFormatPart.RenderXML" />.</param>
            <returns>The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.ConstantDateTimeFormatPart" /> deserialized from <paramref name="literal" />.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache">
            <summary>
                Cache for datetime parsing operations, similar to (and dependent on) <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache" />.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.Formats">
            <summary>
                Atomic formats used to build up larger format strings. Cached like the static tokens in
                <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache" />.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache._allFormatMatches">
            <summary>
                Memoization dictionary for <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.AllFormatMatchesFor(System.String,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.ParseMode,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.Settings)" />.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache._cache">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache" /> for the <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringRegion" /> this caches information on. All access
                to the string is done through this field.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache._dtMatches">
            <summary>
                Stores all <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch" />es of a given <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" />.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache._dtParses">
            <summary>
                Caches parses of a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat"/> for a specific <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringRegion"/>.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache._endingTokenMatches">
            <summary>
                Stores all <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch" />es that end at a position.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache._startingTokenMatches">
            <summary>
                Stores all <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch" />es that start at a position.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache._initialized">
            <summary>
                True once <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.Formats" /> have been loaded into the matches dictionaries.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.#ctor(Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.Settings)">
            <summary>
                Construct a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache" /> for the same string as <paramref name="cache" />.
            </summary>
            <param name="cache">The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache" /> to use when learning dates formats.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.For(Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.Settings)">
            <summary>
                Gets the <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache" /> for <paramref name="sr" />.
            </summary>
            <param name="sr"><see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringRegion" /> to get date format information on.</param>
            <returns>The cached <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache" /> if available or a new one otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.Initialize">
            <summary>
                Initializes the <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache" /> by loading all of the <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.Formats" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.AddDateFormat(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat)">
            <summary>
                Finds all matches of <paramref name="format" /> in the string and records them.
            </summary>
            <param name="format"><see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" /> to cache information on.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.Parse(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat,Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring)">
            <summary>
                Parses <paramref name="sr" /> according to <paramref name="format" /> if possible. This function is memoized so
                repeat calls with the same <paramref name="format" /> on regions of the same string will be fast.
            </summary>
            <param name="format"><see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" /> to use.</param>
            <param name="sr"><see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringRegion" /> to parse.</param>
            <returns>
                The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch" /> with the information on the parse or <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" />
                if <paramref name="sr" /> could not be parsed with <paramref name="format" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.AllFormatMatchesFor(System.String,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.ParseMode,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.Settings)">
            <summary>
                Finds all matches of <paramref name="dateTimeString" /> for any <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" /> which is "reasonable" according
                to <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.Heuristics" />. This function is not memoized, so repeat calls will incur a penalty as compared to the memoized
                overload <see cref="!:AllFormatMatchesFor(LearningCacheSubstring, ParseMode)"/>.
            </summary>
            <param name="dateTimeString">String to look for datetimes in.</param>
            <param name="parseMode">
                Whether matches must match all of <paramref name="dateTimeString" /> or they may also match
                substrings of <paramref name="dateTimeString" />.
            </param>
            <returns>
                All <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch" />es that could possibly correspond to information about datetimes in
                <paramref name="dateTimeString" /> according to <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.Heuristics" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.AllFormatMatchesFor(Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.ParseMode,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.Settings)">
            <summary>
                Finds all matches of <paramref name="sr" /> for any <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" /> which is "reasonable" according
                to <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.Heuristics" />. This function is memoized so repeat calls on regions of the same string are fast.
            </summary>
            <param name="sr"><see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringRegion" /> to look for datetimes in.</param>
            <param name="parseMode">
                Whether matches must match all of <paramref name="dateTimeString" /> or they may also match
                substrings of <paramref name="dateTimeString" />.
            </param>
            <returns>
                All <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch" />es that could possibly correspond to information about datetimes in
                <paramref name="sr" /> according to <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.Heuristics" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.AllReasonableCombinedMatches(System.Collections.Generic.IEnumerable{System.Collections.Generic.ICollection{Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch}})">
            <summary>
                Uses <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.Heuristics" /> to determine which of the
                <see cref="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.CartesianProduct``3(System.Collections.Generic.IDictionary{``0,``1})" /> of <paramref name="matchParts" /> are
                reasonable <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch" />es.
            </summary>
            <param name="matchParts">
                All pieces of matches to try to combine. Matches in the same list are overlapping and
                therefore could never be used together. The lists are in the order of the matches in the string.
            </param>
            <returns>All matches made of pieces from <paramref name="matchParts" /> which satisfy <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.Heuristics" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.CloneWithCurrentCacheState">
            <summary>
                Returns a clone of the object with a snapshot/copy of the cache state before the call.
            </summary>
            <returns>A clone of <c>this</c> object.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.ClearCaches">
            <summary>
                Clears all the cached state in <c>this</c> object.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.Microsoft#ProgramSynthesis#Utils#Caching#ICachefulObject#CloneWithCurrentCacheState">
            <summary>
                Returns a clone of the object with a snapshot/copy of the cache state before the call.
                The object returned will be of the same type as <c>this</c> object, and can be safely
                cast.
            </summary>
            <returns>A clone of <c>this</c> object.</returns>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache._baseFormatsAdded">
            <summary>
                True once atomic <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.Formats" /> have been loaded into the matches dictionaries.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.GetMatchesFor(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat)">
            <summary>
                Retrieves all the matches for <paramref name="format" />.
            </summary>
            <param name="format">The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" />.</param>
            <returns>A collection of matches for <paramref name="format" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.GetMatchesEndingAt(System.UInt32)">
            <summary>
                Retrieves all the matches ending at <paramref name="endPosition" />.
            </summary>
            <param name="endPosition">The ending position.</param>
            <returns>
                A read-only dictionary mapping <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" /> to a collection of matches for the format. Every
                match in the collection ends at <paramref name="endPosition" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.GetMatchesStartingAt(System.UInt32)">
            <summary>
                Retrieves all the matches starting at <paramref name="startPosition" />.
            </summary>
            <param name="startPosition">The starting position.</param>
            <returns>
                A read-only dictionary mapping <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" /> to a collection of matches for the format. Every
                match in the collection starts at <paramref name="startPosition" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.GetFormatMatchesEndingAt(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat,System.UInt32)">
            <summary>
                Retrieves all matches for a given <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" />, that end at <paramref name="endPosition" />.
            </summary>
            <param name="format">The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" />.</param>
            <param name="endPosition">The ending position of matches.</param>
            <returns>
                A collection of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch" /> objects, each of which is a match for
                <paramref name="format" />, which ends at <paramref name="endPosition" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.GetFormatMatchesStartingAt(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat,System.UInt32)">
            <summary>
                Retrieves all matches for a given <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" />, that start at <paramref name="startPosition" />.
            </summary>
            <param name="format">The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" />.</param>
            <param name="startPosition">The starting position of matches.</param>
            <returns>
                A collection of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch" /> objects, each of which is a match for
                <paramref name="format" />, which starts at <paramref name="startPosition" />.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat">
            <summary>
                Wrapper for a datetime format string. Supports more operations than the .NET <see cref="T:System.DateTime" /> type,
                particularly involving information that doesn't form a complete datetime.
                <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" />s are made out of a sequence of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart" />s.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.#ctor(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart[])">
            <summary>
                Constructs a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" /> from a sequence of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart" />s.
            </summary>
            <param name="formatParts">The parts that make up this format.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.#ctor(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart})">
            <summary>
                Constructs a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" /> from a sequence of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart" />s.
            </summary>
            <param name="formatParts">The parts that make up this format.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.#ctor(System.String)">
            <summary>
                Constructs a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" /> by parsing a format string into <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart" />s.
            </summary>
            <param name="format">Format string to parse using <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.ParseFormatString(System.String)" />.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.AllFormatParts">
            <summary>
                All the <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart"/>s that this format is made of.
                The property <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.FormatParts"/> contains only non zero-length format parts
                whereas <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.AllFormatParts"/> includes zero-length format parts.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.FormatParts">
            <summary>
                The parts this format is made out of.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.FormatString">
            <summary>
                The format string this wraps in the format used by <see cref="M:System.DateTime.ToString" /> and
                <see cref="M:System.DateTime.ParseExact(System.String,System.String,System.IFormatProvider)" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.PosixOutputFormatString">
            <summary>
                The format string this wraps in the format used by POSIX <tt>strftime</tt> for outputting datetimes or <c>null</c>
                if this format is not expressible in a format usable by <tt>strftime</tt>.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.PosixParsingFormatString">
            <summary>
                The format string this wraps in the format used by POSIX <tt>strptime</tt> for parsing datetimes or <c>null</c> if
                this format is not expressible in a format usable by <tt>strptime</tt>.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.MatchedParts">
            <summary>
                Which parts of a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime" /> this matches.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.Token">
            <summary>
                The token matches of this appear within, or null if matches are not limited to single token. Used to avoid looking
                elsewhere in the string. This may match a substring of that token.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.IsNumeric">
            <summary>
                Does this format only match numbers?
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.FormatStringFor(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.Target,System.Boolean)">
            <summary>
                Output the format string for the given target. If strict, only
                return format string if semantic equivalence is strictly
                preserved.
            </summary>
            <param name="target">The target format.</param>
            <param name="strict">If strict, only return format string if semantic equivalence is exactly preserved.</param>
            <returns>
                The format string. Can be null if no equivalent target format
                string could be found. When <paramref name="strict"/> is false,
                this method avoids returning null if there exists a reasonable
                alternative, even if the resulting target format is not
                equivalent to this <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat"/>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.FormatWith(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatTranslator,System.Boolean)">
            <summary>
                Output the format string using the given translator. If strict, only
                return format string if semantic equivalence is strictly
                preserved.
            </summary>
            <param name="translator">The translator to use.</param>
            <param name="strict">If strict, only return format string if semantic equivalence is exactly preserved.</param>
            <returns>
                The format string. Can be null if no equivalent target format
                string could be found. When <paramref name="strict"/> is false,
                this method avoids returning null if there exists a reasonable
                alternative, even if the resulting target format is not
                equivalent to this <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat"/>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.Equals(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat)">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.RenderHumanReadable">
            <summary>
                Render this as a human-readable string representation. This should be parseable by the corresponding
                <see cref="P:Microsoft.ProgramSynthesis.Utils.ParseableAttribute.ParseHumanReadableString" /> method.
            </summary>
            <returns>A compact string representation of this object that is easy for a human to understand.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.RenderXML">
            <summary>
                Render this as XML. This should be parseable by the corresponding <see cref="P:Microsoft.ProgramSynthesis.Utils.ParseableAttribute.ParseXML" />
                method.
            </summary>
            <returns>An XML representation of this object.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.ParseAllNext(Microsoft.ProgramSynthesis.DslLibrary.StringRegion,System.Int32,System.Nullable{System.UInt32},Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime)">
            <summary>
                Finds all parses of some suffix of this format.
            </summary>
            <param name="sr">
                The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringRegion" /> being parsed. Note this parses beginning at <paramref name="start" />,
                not beginning at <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Start" />.
            </param>
            <param name="index">The index of the next <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.FormatParts" /> to parse with.</param>
            <param name="start">The position in <paramref name="sr" /> to start parsing at.</param>
            <param name="partialDateTime">The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime" /> parsed so far.</param>
            <returns>
                All <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch" />es of <paramref name="sr" /> starting at <paramref name="start" /> and
                beginning with <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.FormatParts" />[<paramref name="index" />].
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.ToString(System.DateTime)">
            <summary>
                Renders <paramref name="dt" /> according to this date format.
            </summary>
            <param name="dt"><see cref="T:System.DateTime" /> to convert to a string.</param>
            <returns>A string in this datetime format using information from <paramref name="dt" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.ToString(System.DateTimeOffset)">
            <summary>
                Renders <paramref name="dt" /> according to this date format.
            </summary>
            <param name="dt"><see cref="T:System.DateTimeOffset" /> to convert to a string.</param>
            <returns>A string in this datetime format using information from <paramref name="dt" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.ToString(Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime)">
            <summary>
                Renders <paramref name="dt" /> according to this date format.
            </summary>
            <param name="dt"><see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime" /> to convert to a string.</param>
            <returns>A string in this datetime format using information from <paramref name="dt" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.TryParseFromXML(System.Xml.Linq.XElement)">
            <summary>
                Load a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" /> that had been serialized to XML using <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.RenderXML" />.
            </summary>
            <param name="literal">An XML element generated by <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.RenderXML" />.</param>
            <returns>The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" /> deserialized from <paramref name="literal" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.TryParseHumanReadable(System.String)">
            <summary>
                Load a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" /> that had been serialized to a string using <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.RenderHumanReadable" />.
            </summary>
            <param name="literal">A string generated by <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.RenderHumanReadable" />.</param>
            <returns>The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" /> deserialized from <paramref name="literal" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.Equals(System.Object)">
            <summary>
                Determines whether the specified <see cref="T:System.Object" /> is equal to the current
                <see cref="T:System.Object" />.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.GetHashCode">
            <summary>
                Serves as a hash function for a particular type.
            </summary>
            <returns>
                A hash code for the current <see cref="T:System.Object" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.ToString">
            <summary>
                Returns the .NET <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.FormatString" /> corresponding to this.
            </summary>
            <returns>
                A string that represents the current object.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.AllParses(Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring)">
            <summary>
                Computes all parses of <paramref name="ss" /> according to this format.
            </summary>
            <param name="ss">
                <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring" /> to look in for substrings to parse as datetimes according to
                this format.
            </param>
            <returns>
                All substrings of <paramref name="ss" /> that match this format as
                <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch" /> objects.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.GetNextPossibleMatchPosition(Microsoft.ProgramSynthesis.DslLibrary.StringRegion)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.GetAllPossibleMatchPositions(Microsoft.ProgramSynthesis.DslLibrary.StringRegion)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.Parse(Microsoft.ProgramSynthesis.DslLibrary.StringRegion)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch">
            <summary>
                A specific match of a <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch.DateTimeFormat" /> within a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringRegion" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch.#ctor(Microsoft.ProgramSynthesis.DslLibrary.StringRegion,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat,Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime)">
            <summary>
                Constructs a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch" />.
            </summary>
            <param name="region">The position of the match.</param>
            <param name="dateTimeFormat">The format used to make the match.</param>
            <param name="partialDateTime">
                The information extracted from <paramref name="region" /> according to
                <paramref name="dateTimeFormat" />.
            </param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch.PartialDateTime">
            <summary>
                The information extracted by this match. That is, the information contained in <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch.Region" /> according to
                <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch.DateTimeFormat" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch.DateTimeFormat">
            <summary>
                The format used for the match.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch.Region">
            <summary>
                The position matched.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch.Equals(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch)">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch.Explains(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch)">
            <summary>
                Checks if the information in <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch.PartialDateTime" /> is a superset of the information in another
                <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch" />. Used to determine if <paramref name="other" /> is a valid output if this is the
                input.
            </summary>
            <param name="other">Match that may have come from this.</param>
            <returns>True if <paramref name="other" /> can be computed from this.</returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.Explains(Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch.ToString">
            <summary>
                Returns a string that represents the current object.
            </summary>
            <returns>
                A string that represents the current object.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch.Equals(System.Object)">
            <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch.GetHashCode">
            <summary>
                Serves as the default hash function.
            </summary>
            <returns>
                A hash code for the current object.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch.op_Equality(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch)">
            <summary>
                Checks if two date format matches are equal.
            </summary>
            <param name="left">The first date format match.</param>
            <param name="right">The second date format match.</param>
            <returns>
                True if <paramref name="left" /> and <paramref name="right" /> represent the same date format match.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch.op_Inequality(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch)">
            <summary>
                Checks if two date format matches are not equal.
            </summary>
            <param name="left">The first date format match.</param>
            <param name="right">The second date format match.</param>
            <returns>
                False if <paramref name="left" /> and <paramref name="right" /> represent the same date format match.
            </returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch.ParsedRegion">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch.CompleteParse">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch.ContainsOnlyEmptyParse">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch.Sequence(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch.Empty(Microsoft.ProgramSynthesis.DslLibrary.StringRegion)">
            <summary>
                The empty <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch"/> for a given <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringRegion"/> <paramref name="region"/>.
            </summary>
            <param name="region">The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringRegion"/> to construct the empty parse from.</param>
            <returns>An empty <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch"/>.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart">
            <summary>
                The smallest piece of a DateTimeFormat. Either a single custom date specifier or a constant string.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.#ctor(System.String,Microsoft.ProgramSynthesis.Utils.Optional{Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart},Microsoft.ProgramSynthesis.Utils.Optional{Microsoft.ProgramSynthesis.DslLibrary.Token},System.Int32,System.Int32,System.String,System.String,Microsoft.ProgramSynthesis.DslLibrary.Dates.FormatAttributes)">
            <summary>
            </summary>
            <param name="formatString">
                The format string corresponding to this according to
                <see cref="M:System.DateTime.ToString(System.String)" />.
            </param>
            <param name="matchedPart">The part of a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime" /> this parses information about (if any).</param>
            <param name="token">The <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.Token" /> parses of this will be found within or null if matches will span tokens.</param>
            <param name="minimumLength">The minimum length of strings this parses/outputs.</param>
            <param name="maximumLength">The maximum length of strings this parses/outputs.</param>
            <param name="posixOutputFormatString">
                The format string corresponding to this according to the POSIX <tt>strftime</tt>
                datetime formatting function.
            </param>
            <param name="posixParsingFormatString">
                The format string corresponding to this according to the POSIX <tt>strptime</tt>
                datetime parsing function.
            </param>
            <param name="attributes">Additional attributes of format.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.MinimumLength">
            <summary>
                The fewest number of characters this may parse/output.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.MaximumLength">
            <summary>
                The greatest number of characters this may parse/output.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.PosixOutputFormatString">
            <summary>
                The format string this wraps in the format used by POSIX <tt>strftime</tt> for outputting datetimes or <c>null</c>
                if this format is not expressible in a format usable by <tt>strftime</tt>. Can be concated together to form a
                longer datetime format.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.PosixParsingFormatString">
            <summary>
                The format string this wraps in the format used by POSIX <tt>strptime</tt> for parsing datetimes or <c>null</c> if
                this format is not expressible in a format usable by <tt>strptime</tt>. Can be concated together to form a
                longer datetime format.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.Attributes">
            <summary>
                Additional attributes specifying how this datetime part works. Any
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.BaseFormatString">
            <summary>
                The base format string for this, which is usually one or more copies of the same letter. This can be used to
                identify a group of formats.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.FullFormatString">
            <summary>
                The format string for this including the attributes, if any. This should be used when forming larger
                <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.FormatString" />s.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.Token">
            <summary>
                The token matches of this appear within. Used to avoid looking elsewhere in the string. This may match a substring.
                Will be missing for constants.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.MatchedPart">
            <summary>
                The part of the datetime matched or <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if this is a constant.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.IsNumeric">
            <summary>
                Does this format parse only numbers.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.IsNumericAtEnd">
            <summary>
                For <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.TimeZoneOffsetFormatPart" /> which may act like it is numeric, but only at the end of a numeric sequence.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.UniqueParse">
            <summary>
                Does this format parse only exactly the string its <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.ToString(System.Int32)" /> generates.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.FormatStringFor(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.Target,System.Boolean)">
            <summary>
                Output the format string for the given target. If strict, only
                return format string if semantic equivalence is strictly
                preserved.
            </summary>
            <param name="target">The target format.</param>
            <param name="strict">If strict, only return format string if semantic equivalence is exactly preserved.</param>
            <returns>
                The format string. Can be null if no equivalent target format
                string could be found. When <paramref name="strict"/> is false,
                this method avoids returning null if there exists a reasonable
                alternative, even if the resulting target format is not
                equivalent to this <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart"/>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.ParseAll(Microsoft.ProgramSynthesis.DslLibrary.StringRegion)">
            <summary>
                Find all substrings of <paramref name="sr" /> which can be parsed by this format.
            </summary>
            <param name="sr">
                The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringRegion" /> to look for parses in, beginning at or after <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Start" /> and
                ending at or before <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.End" />.
            </param>
            <returns>All parses in <paramref name="sr" /> as a pair of the substring parsed and its value.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.ParseFullString(System.String)">
            <summary>
                Parse a string according to this date format where the entire string corresponds to this format.
                The inverse of <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.ToString(System.Int32)" />.
            </summary>
            <param name="str">The string to parse.</param>
            <returns>
                The value of the string parsed or <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if the entire string could not be parsed
                as a single value.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.ParseNext(Microsoft.ProgramSynthesis.DslLibrary.StringRegion)">
            <summary>
                Parse a substring of <paramref name="sr" /> starting at the beginning.
            </summary>
            <param name="sr">
                The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringRegion" /> to look for parses in, beginning at <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Start" />
                and ending anywhere before <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.End" />.
            </param>
            <returns>
                A record of the substring used and the value parsed or <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if there is
                no valid parse.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.ParseAllNext(Microsoft.ProgramSynthesis.DslLibrary.StringRegion)">
            <summary>
                Finds all parses of this starting at the beginning of <paramref name="sr" />. Due to some datetime formats not
                being a fixed length, there may be ambiguity leading to more than one possible parse.
            </summary>
            <param name="sr">
                The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringRegion" /> to look for parses in, beginning at <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Start" />
                and ending anywhere before <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.End" />.
            </param>
            <returns>
                Every substring starting at <paramref name="sr" />'s <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Start" /> which could be parsed
                by this format in a record of the matched <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringRegion" /> and the value of the
                <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.MatchedPart" /> for that parse.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.ToString(System.Int32)">
            <summary>
                Convert a value to a string according to this date format.
                The inverse of <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.ParseFullString(System.String)" />.
            </summary>
            <param name="value">The value of <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.MatchedPart" />.</param>
            <returns>
                The string representation of a <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.MatchedPart" /> with value <paramref name="value" /> according to
                this format.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.ToString(Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime)">
            <summary>
                Formats <paramref name="dt" /> according to this datetime format.
            </summary>
            <param name="dt"><see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime" /> to format.</param>
            <returns>The string representation of <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.MatchedPart" /> of <paramref name="dt" /> according to this format.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.Create(System.String,Microsoft.ProgramSynthesis.DslLibrary.Dates.FormatAttributes)">
            <summary>
                Creates a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart" /> corresponding to the given format string fragment.
                <paramref name="format" /> must refer to only one part of the format string: either a constant or a sequence of the
                same letter corresponding to a format identifier.
            </summary>
            <param name="format">A format string fragment.</param>
            <param name="attributes">Additional attributes of the format.</param>
            <returns>A <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart" /> which corresponds to <paramref name="format" />.</returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.ParseFormatString(System.String)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.ParseFormatString(System.String)">
            <summary>
                Parses a datetime format string into a sequence of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart" />s.
            </summary>
            <param name="format">A datetime format string.</param>
            <returns>A enumeration of each fragment of <paramref name="format" /> converted to a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart" />.</returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.Create(System.String,Microsoft.ProgramSynthesis.DslLibrary.Dates.FormatAttributes)" />
            <seealso cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.ToString">
            <summary>
                Returns a string that represents the current object.
            </summary>
            <returns>
                A string that represents the current object.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.GetHashCode">
            <summary>
                Serves as the default hash function.
            </summary>
            <returns>
                A hash code for the current object.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.Equals(System.Object)">
            <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.RenderHumanReadable">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.RenderXML">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.TryParseFromXML(System.Xml.Linq.XElement)">
            <summary>
                Load a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart" /> that had been serialized to XML using <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.RenderXML" />.
            </summary>
            <param name="literal">An XML element generated by <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.RenderXML" />.</param>
            <returns>The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart" /> deserialized from <paramref name="literal" />.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPartUtil">
            <summary>
                Utility functions for sequences of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart" />s.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPartUtil.HasNonDelimitedNumbers(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat)">
            <summary>
                Checks if there are any adjacent <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart" />s in
                <paramref name="dateTimeFormat" />. Important because the boundary between them could be unclear, and there's
                a high probability that is actually a number, not a date.
            </summary>
            <param name="dateTimeFormat">
                <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" /> whose <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.FormatParts" /> should be
                checked.
            </param>
            <returns>
                True if there exists a pair of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart" />s at adjacent indexes in
                <paramref name="dateTimeFormat" />'s <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.FormatParts" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPartUtil.HasNonDelimitedNumbers(System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart})">
            <summary>
                Checks if there are any adjacent <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart" />s in
                <paramref name="dateTimeFormatParts" />. Important because the boundary between them could be unclear, and there's
                a high probability that is actually a number, not a date.
            </summary>
            <param name="dateTimeFormatParts">List of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart" />s to check.</param>
            <returns>
                True if there exists a pair of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart" />s at adjacent indexes in
                <paramref name="dateTimeFormatParts" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPartUtil.Sequence(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch)">
            <summary>
                Sequences <paramref name="first" /> with <paramref name="second" /> to obtain a longer
                <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch" />.
            </summary>
            <param name="first">The first <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch" />.</param>
            <param name="second">The second <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch" />.</param>
            <returns>
                A <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch" /> that represents <paramref name="first" /> followed by
                <paramref name="second" /> if such a sequencing is valid, <c>null</c> otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPartUtil.AllowsLeadingZeros(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart)">
            <summary>
                Does this <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart" /> allow optional leading zeros. This is the case if
                <paramref name="part" />'s minimum and maximum lengths are different and its
                <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.Attributes" /> contains <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DTFormatAttributeNames.AllowLeadingZeros" />.
            </summary>
            <param name="part">Format part to check if it allows optional leading zeros when parsing.</param>
            <returns><c>true</c> if <paramref name="part" /> parses strings that both do and do not have leading zeros.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatTranslator">
            <summary>
                Abstract datetime format translator for converting <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat"/>
                instances into target language format strings.
                Use the factory method <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatTranslator.For(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.Target)"/> to obtain
                a concrete translator for the given target language.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatTranslator.FormatSegment">
            <summary>
                This structure is used to create the documentation in the
                minilanguages frontend. These segments do not necessarily
                correspond to datetime format parts.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatTranslator.FormatSegment.IsSignificant">
            <summary>
                Is this a significant part of the format string, i.e., does
                it contain date time info or is it a spacer, constant string, etc?
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatTranslator.FormatSegment.Segment">
            <summary>
                The part of the format string that corresponds to this segment.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatTranslator.FormatSegment.For(System.String,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart)">
            <summary>
                Return a segment corresponding to the data time format part
                <paramref name="fp"/>. The segment is significant only if
                it contains some date time info.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatTranslator.TranslateWithSegmentInfo(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat,System.Boolean)">
            <summary>
                Translate the given format into the target syntax. In addition,
                return the segments of the format string.
            </summary>
            <param name="format">The format to translate.</param>
            <param name="strict">If strict, only return format string if semantic equivalence is exactly preserved.</param>
            <returns>The format string and the corresponding segments, or null if no valid translation exists.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatTranslator.Translate(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat,System.Boolean)">
            <summary>
                Translate the given format into the target syntax.
            </summary>
            <param name="format">The format to translate.</param>
            <param name="strict">If strict, only return format string if semantic equivalence is exactly preserved.</param>
            <returns>The format string, or null if no valid translation exists.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatTranslator.AllTranslationsWithSegmentInfo(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat,System.Boolean)">
            <summary>
                Translate the given format into the target syntax in all possible ways,
                including segment info. If there are multiple formats due to
                rewritings to more concise formats, the more concise formats
                are output first.
            </summary>
            <param name="format">The format to translate.</param>
            <param name="strict">If strict, only return format string if semantic equivalence is exactly preserved.</param>
            <returns>The format strings, or empty if no valid translation exists.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatTranslator.AllTranslations(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat,System.Boolean)">
            <summary>
                Translate the given format into the target syntax in all possible ways.
                If there are multiple formats due to rewritings to more concise formats,
                the more concise formats are output first.
            </summary>
            <param name="format">The format to translate.</param>
            <param name="strict">If strict, only return format string if semantic equivalence is exactly preserved.</param>
            <returns>The format strings, or empty if no valid translation exists.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatTranslator.OrdinalDaySupported">
            <summary>
                Does this translator support the "o" format for ordinal day of month?
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatUtil">
            <summary>
                Utility functions for datetime format strings (both .NET and POSIX).
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatUtil.Escape(System.String)">
            <summary>
                Escapes a string to be used as a constant in a .NET datetime format.
            </summary>
            <param name="constStr">Constant string the format should match.</param>
            <returns>A format string that will match <paramref name="constStr" /> when used as a .NET datetime format.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatUtil.Unescape(System.String)">
            <summary>
                Unescapes a .NET datetime format that matches a constant string.
            </summary>
            <param name="constantFormat">A .NET datetime format that matches a constant string.</param>
            <returns>The constant string matched by <paramref name="constantFormat" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatUtil.EscapeForPosix(System.String)">
            <summary>
                Escapes a string to be used as a constant in a POSIX datetime format.
            </summary>
            <param name="constStr">Constant string the format should match.</param>
            <returns>A format string that will match <paramref name="constStr" /> when used as a POSIX datetime format.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatUtil.EscapeForMomentJS(System.String)">
            <summary>
                Escape a string to be used as a constant in a MomentJS datetime format.
                In order to produce concise outputs, this method adds brackets
                around spans of one or more alphanumeric characters, rather than escaping
                exact matches of special characters.
            </summary>
            <param name="constStr">Constant string the format should match.</param>
            <returns>A format string that will match <paramref name="constStr" /> when used as a MomentJS datetime format.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatUtil.EscapeForDayJS(System.String)">
            <summary>
                Escape a string to be used as a constant in a DayJS datetime format.
                In order to produce concise outputs, this method adds brackets
                around spans of one or more alphanumeric characters, rather than escaping
                exact matches of special characters.
            </summary>
            <param name="constStr">Constant string the format should match.</param>
            <returns>A format string that will match <paramref name="constStr" /> when used as a DayJS datetime format.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatUtil.EscapeForPowerApps(System.String)">
            <summary>
                Escape a string to be used as a constant in a Power Apps datetime format.
                Power Apps does not allow arbitrary literals. In the case that the input
                string is invalid, null is returned.
            </summary>
            <param name="constStr">Constant string the format should match.</param>
            <returns>
                A format string that will match <paramref name="constStr" /> when used as a Power Apps datetime format,
                or null if none exists.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatUtil.Parse(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat,Microsoft.ProgramSynthesis.DslLibrary.StringRegion)">
            <summary>
                Parses <paramref name="sr" /> according to <paramref name="format" /> if possible. This function is memoized so
                repeat calls with the same <paramref name="format" /> on regions of the same string will be fast.
            </summary>
            <param name="format"><see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" /> to use.</param>
            <param name="sr"><see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringRegion" /> to parse.</param>
            <returns>
                The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch" /> with the information on the parse or <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" />
                if <paramref name="sr" /> could not be parsed with <paramref name="format" />.
            </returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.Parse(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat,Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatUtil.Parse(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat,System.String)">
            <summary>
                Parses <paramref name="sr" /> according to <paramref name="format" /> if possible.
            </summary>
            <param name="format"><see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" /> to use.</param>
            <param name="str"><see cref="T:System.String"/> to parse.</param>
            <returns>
                The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch" /> with the information on the parse or <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" />
                if <paramref name="str" /> could not be parsed with <paramref name="format" />.
            </returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.Parse(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat,Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatUtil.Parse(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat,Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring)">
            <summary>
                Parses <paramref name="ss" /> according to <paramref name="format" /> if possible. This function is memoized so
                repeat calls with the same <paramref name="format" /> on regions of the same string will be fast.
            </summary>
            <param name="format"><see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" /> to use.</param>
            <param name="ss"><see cref="T:Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring" /> to parse.</param>
            <returns>
                The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch" /> with the information on the parse or <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" />
                if <paramref name="ss" /> could not be parsed with <paramref name="format" />.
            </returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateFormatCache.Parse(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat,Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatUtil.MatchSameStrings(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat)">
            <summary>
                Checks if two <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" />s could possibly match the same string.
            </summary>
            <param name="a">A <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" />.</param>
            <param name="b">A <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" />.</param>
            <returns>True if there exists a string that matches both <paramref name="a" /> and <paramref name="b" />.</returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatUtil.IsAmbiguous(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat)"/>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatUtil.IsAmbiguous(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat)">
            <summary>
                Checks if two <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" />s could possibly match the same string and give different values.
            </summary>
            <param name="a">A <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" />.</param>
            <param name="b">A <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" />.</param>
            <returns>
                True if there exists a string that matches both <paramref name="a" /> and <paramref name="b" /> such that
                different <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime" />s would be parsed.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatUtil.SimplifyGroup(System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat})">
            <summary>
                Given a collection of datetime formats that are not ambiguous and parse the same strings, return an equivalent,
                possibly smaller, group of datetime parsing formats.
            </summary>
            <param name="group">A collection of datetime formats that parse similar string.</param>
            <returns>
                A collection of datetime formats that parse exactly the same strings as <paramref name="group" /> which
                contains no more formats than <paramref name="group" /> does.
            </returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatUtil.MatchSameStrings(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat)" />
            <seealso cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatUtil.IsAmbiguous(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatUtil.GetDefaultDateTimeFormat(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet)">
            <summary>
                Get a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" /> whose <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat.MatchedParts" /> is <paramref name="parts" />.
            </summary>
            <param name="parts">A collection of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart" />s.</param>
            <returns>A <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" /> for formatting <paramref name="parts" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatUtil.ContainsParsingFormat(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat},Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat)">
            <summary>
                Checks if a datetime parsing format is contained in a collection of datetime parsing formats that may contain
                merged formats like <c>d</c> and <c>dd</c> together as <c>d{allowLeadingZeros}</c>.
            </summary>
            <param name="haystack">Collection of datetime parsing formats to look in.</param>
            <param name="needle">Datetime parsing format to look for.</param>
            <returns>
                <c>true</c> if any element of <paramref name="haystack" /> either is <paramref name="needle" /> or is merged
                parsing format that includes <paramref name="needle" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatUtil.ContainsParsingFormat(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat)">
            <summary>
                Checks if a datetime parsing format is contained in a datetime parsing formats that may be a merged format like
                <c>d</c> and <c>dd</c> together as <c>d{allowLeadingZeros}</c>.
            </summary>
            <param name="haystack">A datetime parsing format which may be multiple formats merged together.</param>
            <param name="needle">Datetime parsing format to look for.</param>
            <returns>
                <c>true</c> if <paramref name="haystack" /> either is <paramref name="needle" /> or is a merged parsing format that
                includes <paramref name="needle" />.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart">
            <summary>
                Enum of the smallest pieces of a datetime. May need multiple parts to have an interpretable datetime.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.Year">
            <summary>
                <see cref="P:System.DateTime.Year"/>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.Month">
            <summary>
                <see cref="P:System.DateTime.Month"/>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.Day">
            <summary>
                <see cref="P:System.DateTime.Day"/>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.Hour">
            <summary>
                <see cref="P:System.DateTime.Hour"/>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.Minute">
            <summary>
                <see cref="P:System.DateTime.Minute"/>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.Second">
            <summary>
                <see cref="P:System.DateTime.Second"/>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.Millisecond">
            <summary>
                <see cref="P:System.DateTime.Millisecond"/>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.HourInPeriod">
            <summary>
                <see cref="P:System.DateTime.Hour"/> in 12-hour format instead of 24-hour.
            </summary>
            <seealso cref="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.Period"/>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.Period">
            <summary>
                The AM/PM indicator. <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.Period"/>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.DayOfWeek">
            <summary>
                <see cref="P:System.DateTime.DayOfWeek"/>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.Quarter">
            <summary>
                The quarter (1-4) of the year. Determined by the month.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.DayOfYear">
            <summary>
                <see cref="P:System.DateTime.DayOfYear"/>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.DayOfWeekInMonth">
            <summary>
                The ordinal of the instance of the <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.DayOfWeek" /> in this <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.Month" /> (1-5). For example, for
                "the 3rd Sunday of April", this is the "3". Currently unsupported, but it is also meaningful to say "last Sunday in
                April" or similar which may be represented using negative numbers in future versions. This is different from
                <c>WeekOfMonth</c> (which is not currently supported) as that definition of week always starts on the same day of
                the week, while this definition of week always starts on the first day of the month.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.WeekYear">
            <summary>
                The ISO 8601 week year. This is almost always the same as <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.Year" />, except at the start/end of the year.
                All week years start on a Monday and end on a Sunday.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.WeekOfYear">
            <summary>
                The ISO 8601 week number (1-53). Future versions may support other week numbering schemes.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.TimeZoneOffset">
            <summary>
                The time zone offset in minutes. Zero is UTC. May be positive or negative. Usually a multiple of 60 or 30.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.Period">
            <summary>
                Period of time during a day (AM or PM).
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.Period.AM">
            <summary>
                A.M.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.Period.PM">
            <summary>
                P.M.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartKind">
            <summary>
                Whether a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart" /> contains information about the date, time, or both.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartKind.Date">
            <summary>
                Contains information about the date.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartKind.Time">
            <summary>
                Contains information about the time.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartList">
            <summary>
                General parts lists for <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart" />.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartList.StandardDateTimeDescending">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart" />s corresponding to the arguments to the <see cref="T:System.DateTime" /> constructor,
                in descending size order.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartList.StandardDateTimeAscending">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart" />s corresponding to the arguments to the <see cref="T:System.DateTime" /> constructor,
                in ascending size order.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartList.StandardTimeDescending">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart" />s for times corresponding to the arguments to the <see cref="T:System.DateTime" /> constructor,
                in descending size order.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet">
            <summary>
                Specialized type for holding a set of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart" /> as a bitmask.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet.#ctor(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart[])">
            <summary>
                Construct a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet" /> with the specified <paramref name="parts" />.
            </summary>
            <param name="parts"><see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart" /> values to include.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet.#ctor(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart})">
            <summary>
                Construct a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet" /> with the specified <paramref name="parts" />.
            </summary>
            <param name="parts"><see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart" /> values to include.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet.All">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet" /> of all <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart" /> values.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet.Empty">
            <summary>
                The empty <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet.Contains(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart)">
            <summary>
                Returns <c>true</c> if <paramref name="part" /> is in this set.
            </summary>
            <param name="part">Part to look for.</param>
            <returns><c>true</c> if this set contains <paramref name="part" />. <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet.Equals(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet.op_Equality(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet)">
            <summary>
                Returns <c>true</c> if <paramref name="left" /> and <paramref name="right" /> contain exactly the same elements.
            </summary>
            <param name="left">The left set.</param>
            <param name="right">The right set.</param>
            <returns>Whether the two sets are identical.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet.op_Inequality(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet)">
            <summary>
                Returns <c>true</c> if <paramref name="left" /> and <paramref name="right" /> do not contain exactly the same
                elements.
            </summary>
            <param name="left">The left set.</param>
            <param name="right">The right set.</param>
            <returns>Whether the two sets differ.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet.ToString">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartUtil">
            <summary>
                Utility functions for <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartUtil.MonthToQuarter(System.Int32)">
            <summary>
                Gets the quarter number for a given month.
            </summary>
            <param name="month">A month number (1-12).</param>
            <returns>The corresponding quarter number (1-4).</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartUtil.HourInPeriodToHour(System.Int32,Microsoft.ProgramSynthesis.DslLibrary.Dates.Period)">
            <summary>
                Gets the 24-hour hour from a 12-hour hour and the AM/PM indicator.
            </summary>
            <param name="hourInPeriod">The hour in the time period (1-12).</param>
            <param name="period">The time period (AM/PM).</param>
            <returns>The hour in 24-hour format (0-23).</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartUtil.DateToDayOfWeek(System.Int32,System.Int32,System.Int32)">
            <summary>
                Gets the <see cref="T:System.DayOfWeek" /> of the specified valid date. This is equivalent to
                <c>
                    new <see cref="T:System.DateTime" />(<paramref name="year" />, <paramref name="month" />, <paramref name="day" />).
                    <see cref="P:System.DateTime.DayOfWeek" />
                </c>
                and exists for performance.
            </summary>
            <param name="year">The year of the date.</param>
            <param name="month">The month of the date.</param>
            <param name="day">The day of month of the date.</param>
            <returns>The <see cref="T:System.DayOfWeek" /> of the date if the date is valid.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartUtil.DayOfMonthToDayOfWeekInMonth(System.Int32)">
            <summary>
                Gets the <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.DayOfWeekInMonth" /> of the specified day of month.
            </summary>
            <param name="day">The day of month of the date.</param>
            <returns>The ordinal of which instance of the day of the week this day is (e.g. 3 for the 3rd Wednesday).</returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartUtil.DayOfWeekInMonthToDayOfMonth(System.Int32,System.Int32,System.DayOfWeek,System.Int32)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartUtil.DayOfWeekInMonthToDayOfMonth(System.Int32,System.Int32,System.DayOfWeek,System.Int32)">
            <summary>
                Gets the day of month of a date given the day of week and <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.DayOfWeekInMonth" />.
            </summary>
            <param name="year">The year of the date.</param>
            <param name="month">The month of the date.</param>
            <param name="dayOfWeek">The <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.DayOfWeek" /> of the date.</param>
            <param name="dayOfWeekInMonth">The <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.DayOfWeekInMonth" /> of the date.</param>
            <returns>The <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.Day" /> of month of the date. If the input invalid, this may be out of range.</returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartUtil.DayOfMonthToDayOfWeekInMonth(System.Int32)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartUtil.GetDaysInMonth(System.Int32,System.Int32)">
            <summary>
                Gets the number of days in the specified month. This is equivalent to
                <c>
                    CultureInfo.InvariantCulture.Calendar.GetDaysInMonth(<paramref name="year" />, <paramref name="month" />)
                </c>
                and exists for performance.
            </summary>
            <param name="year">The year (used to determine if this is a leap year).</param>
            <param name="month">The month to get the day count of.</param>
            <returns>The number of days in <paramref name="month"/> in the year <paramref name="year"/>.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartUtil.IsLeapYear(System.Int32)">
            <summary>
                Returns true if <paramref name="year" /> is a leap year in the modern Gregorian calendar.
            </summary>
            <param name="year">Year to check.</param>
            <returns><c>true</c> if there is a leap day (February 29th) in the year <paramref name="year" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartUtil.DayOfYearToDate(System.Int32,System.Int32,System.Int32@,System.Int32@)">
            <summary>
                Gets the month and day given the year and <see cref="P:System.DateTime.DayOfYear" />. This is equivalent to
                <code>
                    dt = new DateTime(<paramref name="year" />, 1, 1).AddDays(<paramref name="dayOfYear" /> - 1);
                    month = dt.Month;
                    day = dt.Day;
                </code>
            </summary>
            <param name="year">Year of date.</param>
            <param name="dayOfYear"><see cref="P:System.DateTime.DayOfYear" /> of date (1-366).</param>
            <param name="month">Computed month (1-12).</param>
            <param name="day">Computed day (1-31).</param>
            <returns>
                <c>true</c> if the conversion succeeded or <c>false</c> if <paramref name="dayOfYear" /> is not a valid
                <see cref="P:System.DateTime.DayOfYear" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartUtil.DateToDayOfYear(System.Int32,System.Int32,System.Int32)">
            <summary>
                Gets the <see cref="P:System.DateTime.DayOfYear" /> for a date.
                This is equivalent to
                <c>
                    new DateTime(<paramref name="year" />, <paramref name="month" />, <paramref name="day" />).
                    <see cref="P:System.DateTime.DayOfYear" />
                </c>
                .
            </summary>
            <param name="year">The year for the date.</param>
            <param name="month">The month for the date (1-12).</param>
            <param name="day">
                The day of the month for the date (1-31), which must be a valid day in month
                <paramref name="month" />.
            </param>
            <returns>The <see cref="P:System.DateTime.DayOfYear" /> for the specified date.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartUtil.DateToWeekOfYear(System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,System.DayOfWeek@)">
            <summary>
                Gets the ISO 8601 week year and week number. These are <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.WeekYear" /> and
                <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.WeekOfYear" />.
            </summary>
            <param name="year">The year for the date.</param>
            <param name="month">The month for the date (1-12).</param>
            <param name="day">
                The day of the month for the date (1-31), which must be a valid day in month
                <paramref name="month" />.
            </param>
            <param name="weekYear">The ISO 8601 week year.</param>
            <param name="weekOfYear">The ISO 8601 week number.</param>
            <param name="dayOfWeek">The day of week.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartUtil.IsLongIsoWeekYear(System.Int32)">
            <summary>
                Determines if a ISO 8601 week year has 53 or 52 weeks.
            </summary>
            <param name="weekYear">The ISO 8601 week year.</param>
            <returns><c>true</c> if the ISO 8601 week year <paramref name="weekYear" /> has 53 weeks, otherwise it has 52.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartUtil.WeekOfYearToDate(System.Int32,System.Int32,System.DayOfWeek,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
                Gets the date given the ISO 8601 week year, week number, and day of week.
            </summary>
            <param name="weekYear">The ISO 8601 week year.</param>
            <param name="weekOfYear">The ISO 8601 week number.</param>
            <param name="dayOfWeek">The day of week.</param>
            <param name="year">The year for the date.</param>
            <param name="month">The month for the date (1-12).</param>
            <param name="day">The day of the month for the date (1-31).</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartUtil.GetValue(System.DateTime,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart)">
            <summary>
                Gets the <paramref name="part" /> value out of the <see cref="T:System.DateTime" /> <paramref name="dt" />.
            </summary>
            <param name="dt"><see cref="T:System.DateTime" /> to extract value from.</param>
            <param name="part">Part of the datetime to extract.</param>
            <returns>The <paramref name="part" /> of <paramref name="dt" /> cast to the common denominator type of int.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartUtil.GetValue(System.DateTimeOffset,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart)">
            <summary>
                Gets the <paramref name="part" /> value out of the <see cref="T:System.DateTime" /> <paramref name="dt" />.
            </summary>
            <param name="dt"><see cref="T:System.DateTimeOffset" /> to extract value from.</param>
            <param name="part">Part of the datetime to extract.</param>
            <returns>The <paramref name="part" /> of <paramref name="dt" /> cast to the common denominator type of int.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartUtil.CanExplainFullDate(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet)">
            <summary>
                Checks if <paramref name="parts" /> covers enough information to compute the entire date. This means that
                <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartUtil.CanExplain(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart)" /> will return <c>true</c> for any part that
                <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartUtil.GetKind(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart)" /> return <c><see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartKind.Date"/></c> for.
            </summary>
            <param name="parts">Set of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart" /> representing the input information.</param>
            <returns><c>true</c> if all date information can be computed from the information in <paramref name="parts" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartUtil.CanExplain(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart)">
            <summary>
                Checks if <paramref name="parts" /> covers enough information to possibly compute
                <paramref name="toExplain" />.
                In the simplest case, this just checks if <paramref name="toExplain" /> is in
                <paramref name="parts" />.
            </summary>
            <param name="parts">Set of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart" /> representing the input information.</param>
            <param name="toExplain"><see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart" /> representing the desired output information.</param>
            <returns>
                True if given values for <paramref name="parts" />, a value for <paramref name="toExplain" /> can be
                computed.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartUtil.CanExplain(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet)">
            <summary>
                Checks if <paramref name="parts" /> covers enough information to possibly compute
                <paramref name="partsToExplain" />.
                In the simplest case, this just checks if <paramref name="partsToExplain" /> is a subset of
                <paramref name="parts" />.
            </summary>
            <param name="parts">Set of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart" /> representing the input information.</param>
            <param name="partsToExplain">Set of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart" /> representing the desired output information.</param>
            <returns>
                True if given values for <paramref name="parts" />, values for <paramref name="partsToExplain" /> can be
                computed.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartUtil.CanExplain(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartSet,System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart})">
            <summary>
                Checks if <paramref name="parts" /> covers enough information to possibly compute
                <paramref name="partsToExplain" />.
                In the simplest case, this just checks if <paramref name="partsToExplain" /> is a subset of
                <paramref name="parts" />.
            </summary>
            <param name="parts">Set of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart" /> representing the input information.</param>
            <param name="partsToExplain">Set of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart" /> representing the desired output information.</param>
            <returns>
                True if given values for <paramref name="parts" />, values for <paramref name="partsToExplain" /> can be
                computed.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartUtil.GetKind(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart)">
            <summary>
                Gets the <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartKind" /> (date, time, or both) of <paramref name="part" />.
            </summary>
            <param name="part">The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart" /> which may reference information about a date, time, or both.</param>
            <returns>The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartKind" />.</returns>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartUtil.PartKindCount">
            <summary>
                The number of possible different <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart"/> components in a date.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePartUtil.MaxValue(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart)">
            <summary>
                The maximum legal value for a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart"/>, independent of other values.
            </summary>
            <remarks>
                For example, the maximum value for <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.Month"/> is 31
                even though Feburary 31st does not exist.
            </remarks>
            <param name="part">The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart" />.</param>
            <returns>The maximal legal value for <paramref name="part" />.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeRoundingSpec">
            <summary>
                A <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeRoundingSpec" /> specifies a rounding operation. A rounding operation is specified by a set of
                equidistant dates/times defined by a <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeRoundingSpec.Zero" /> point and a distance <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeRoundingSpec.Delta" /> in units
                <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeRoundingSpec.Unit"/>. Of the two numbers closest to the number being rounded, which one is selected is determined by
                the <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeRoundingSpec.Mode" />.
            </summary>
            <see cref="!:Semantics.RoundPartialDateTime" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeRoundingSpec.#ctor(Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime,System.UInt32,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart,Microsoft.ProgramSynthesis.DslLibrary.Numbers.RoundingMode,System.Nullable{Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart},System.UInt32)">
            <summary>
                Constructs a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeRoundingSpec" /> specifying a rounding operation.
            </summary>
            <param name="zero">
                The lower bound of the first range that starts on or after the absolute zero point
                (e.g,. for the ranges 11PM-1AM, 1AM-3AM, etc., it would be 1AM).
            </param>
            <param name="delta">The increment between dates/times to round to.</param>
            <param name="unit">The unit of the <paramref name="delta"/>.</param>
            <param name="mode">
                Whether rounding is <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Numbers.RoundingMode.Up" />, <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Numbers.RoundingMode.UpOrNext" />, or
                <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Numbers.RoundingMode.Down" />
            </param>
            <param name="upperExcludePart">
                The unit of the amount to exclude in the display of the upper bound of each range.
            </param>
            <param name="upperExcludeAmount">
                The amount to exclude in the display of the upper bound of each range.  The unit of this amount
                is given by <paramref name="upperExcludePart"/>.
            </param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeRoundingSpec.Zero">
            <summary>
                The zero-point of the set of numbers to round to. Numbers are rounded to some multiple of <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeRoundingSpec.Delta" /> away
                from this value.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeRoundingSpec.Delta">
            <summary>
                The increment between numbers to round to. Numbers are rounded to some multiple of this value away from
                <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeRoundingSpec.Zero" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeRoundingSpec.Unit">
            <summary>
                The unit of measurement for the <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeRoundingSpec.Delta"/>.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeRoundingSpec.Mode">
            <summary>
                Determines which of the two closest numbers to round to. May be <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Numbers.RoundingMode.Up" />,
                <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Numbers.RoundingMode.UpOrNext" />, or <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Numbers.RoundingMode.Down" />
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeRoundingSpec.UpperExcludePart">
            <summary>
                The unit of the amount to exclude in the display of the upper bound of each range.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeRoundingSpec.UpperExcludeAmount">
            <summary>
                The amount to exclude in the display of the upper bound of each range.  The unit of this amount
                is given by <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeRoundingSpec.UpperExcludePart"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeRoundingSpec.RenderHumanReadable">
            <summary>
                Render this as a human-readable string representation. This should be parseable by the corresponding
                <see cref="P:Microsoft.ProgramSynthesis.Utils.ParseableAttribute.ParseHumanReadableString" /> method.
            </summary>
            <returns>A compact string representation of this object that is easy for a human to understand.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeRoundingSpec.RenderXML">
            <summary>
                Render this as XML. This should be parseable by the corresponding <see cref="P:Microsoft.ProgramSynthesis.Utils.ParseableAttribute.ParseXML" />
                method.
            </summary>
            <returns>An XML representation of this object.</returns>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DtFeatures._unlikelyConstants">
            <summary>
                Strings that are unlikely to be constants. These include names
                of months, weekdays, etc.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DtFeatures.UnlikelyFormatParts">
            <summary>
                Format parts that are very unlikely.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DtFeatures.IsCommonDateTimeSeparator(System.String,Microsoft.ProgramSynthesis.DslLibrary.Dates.DtFeatures.DateTimeSeparatorKind)">
            <summary>
                Checks if <paramref name="constant" /> is commonly used as a separator of the specified kind.
            </summary>
            <param name="constant">The string appearing in the datetime format between the two parts.</param>
            <param name="partsKind">The kind of separator expected.</param>
            <returns>
                <c>true</c> if <paramref name="constant" /> is a commonly used separator for the specified pair of parts,
                <c>false</c> if it is a commonly used separator for other pairs of parts, or <c>null</c> if it is not a known
                common separator.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DtFeatures.IsCommonDateTimeSeparator(System.String,Microsoft.ProgramSynthesis.Utils.Optional{Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart},Microsoft.ProgramSynthesis.Utils.Optional{Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart})">
            <summary>
                Checks if <paramref name="constant" /> is commonly used to separate <paramref name="leftMatchedPart" /> from
                <paramref name="rightMatchedPart" />.
            </summary>
            <param name="constant">The string appearing in the datetime format between the two parts.</param>
            <param name="leftMatchedPart">The part before the separator.</param>
            <param name="rightMatchedPart">The part after the separator.</param>
            <returns>
                <c>true</c> if <paramref name="constant" /> is a commonly used separator for the specified pair of parts,
                <c>false</c> if it is a commonly used separator for other pairs of parts, or <c>null</c> if it is not a known
                common separator.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DtFeatures.DateTimePartOrder.ContainsAllParts(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart})">
            <summary>
                Checks if this order contains all parts used in another order.
            </summary>
            <param name="other">Order to check.</param>
            <returns>
                <c>true</c> if this order includes the parts needed to use it as a reference order to compare
                <paramref name="other" /> to.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DtFeatures.DateTimePartOrder.IsCommonSeparators(System.Collections.Generic.IReadOnlyList{System.String})">
            <summary>
                Checks if the specified list is commonly used as separators for this order. This allows filtering to orders
                commonly used with the given set of separators.
            </summary>
            <param name="separators">Separators used in the actual date or time format.</param>
            <returns><c>true</c> if <paramref name="separators" /> is exactly a common separators list for this part order.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DTFormatAttributeNames">
            <summary>
                Constant strings for names of attributes for use in <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.FormatAttributes" />.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DTFormatAttributeNames.Casing">
            <summary>
                Control case for <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart" />s.
            </summary>
            <seealso cref="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DTFormatAttributeValues.CasingLower" />
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DTFormatAttributeNames.AllowLeadingZeros">
            <summary>
                For <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart" />, allow leading zeros even if longer than
                <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.MinimumLength" />. This allows the same format to match "07" and "7".
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DTFormatAttributeNames.Disallow24Hour">
            <summary>
                For <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart" />, allow hour value equal to 24.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DTFormatAttributeNames.AllowNumericZero">
            <summary>
                For <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.TimeZoneOffsetFormatPart" />, allow "+00:00"/"-0000" instead of "Z" when parsing.
                This allows the same format to match "+0000" and "Z".
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DTFormatAttributeNames.NumericZero">
            <summary>
                For <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.TimeZoneOffsetFormatPart" />, use "+00:00"/"+0000" instead of "Z".
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DTFormatAttributeValues">
            <summary>
                Constant strings for values of attributes for use in <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.FormatAttributes" />.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DTFormatAttributeValues.CasingLower">
            <summary>
                Indicates all strings should be lowercase.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.FormatAttributes">
            <summary>
                A collection of attributes which may modify a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart" />. This allows
                <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart" />s to be more expressive than just a letter repeated some number of times, making
                it easier to extend the set of allowed formats. Attributes are key value pairs of strings to simplify
                serialization.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.FormatAttributes.#ctor(System.Collections.Generic.IReadOnlyDictionary{System.String,System.String})">
            <summary>
                Wrap a dictionary of attributes.
            </summary>
            <param name="attributes">The <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.FormatAttributes.Attributes" /> to wrap.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.FormatAttributes.Attributes">
            <summary>
                The attributes wrapped by this. The value may be null for boolean attributes (i.e. presence of the attribute is
                true, omitting it is false).
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.FormatAttributes.Equals(Microsoft.ProgramSynthesis.DslLibrary.Dates.FormatAttributes)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.FormatAttributes.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.FormatAttributes.GetHashCode">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.FormatAttributes.FormatSuffix">
            <summary>
                When serializing a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart"/> to a human readable string, include these attributes by appending this string as a suffix to the base format string.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.FormatAttributes.TryMerge(Microsoft.ProgramSynthesis.DslLibrary.Dates.FormatAttributes,Microsoft.ProgramSynthesis.DslLibrary.Dates.FormatAttributes@)">
            <summary>
                Merge this with the other and create a new object that has the union of the two attributes.
            </summary>
            <param name="other">The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.FormatAttributes" /> to merge with.</param>
            <param name="result">The result <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.FormatAttributes" /> obtained by merging this with other.</param>
            <returns>Boolean indicating if the two dictionaries were consistent and merge was possible.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.FormatAttributes.ToString">
            <inheritdoc />
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.HeuristicsMode.AllowMostFormats">
            <summary>
                Heuristics for matching nearly any datetime format, forbidding only complete nonsense.
                This makes sense for learning datetimes with strong evidence.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.HeuristicsMode.FromAutocomplete">
            <summary>
                Heuristics for learning a format from autocompletion where the user is explicitly requesting a datetime format.
                This makes sense for learning datetimes with weak evidence.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.HeuristicsMode.FromAutocompleteAllowingDatetimeConstants">
            <summary>
                Heuristics for learning a format from autocompletion where the user is explicitly requesting a datetime format.
                This makes sense for learning datetimes with weak evidence. Like <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.HeuristicsMode.FromAutocomplete" /> but allows
                numbers and strings that look like datetimes to appear in constants.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.Heuristics">
            <summary>
                Heuristics for datetime parsing. These methods are used to select "reasonable" datetime matches out of the set of
                all valid datetime matches.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.Heuristics.AllowMostFormats">
            <summary>
                Heuristics for matching nearly any datetime format, forbidding only complete nonsense.
                This makes sense for learning datetimes with strong evidence.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.Heuristics.FromAutocomplete">
            <summary>
                Heuristics for matching only reasonable formats.
                This makes sense for learning datetimes with weak evidence.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.Heuristics.MaxConstantLength">
            <summary>
                Maximum length of constants between non-constant formats.
            </summary>
            <seealso cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.Heuristics.CreateDateTimeFormatIfReasonable(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart})"/>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.Heuristics.IsReasonableDateTimeMatchPrefix(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch)">
            <summary>
                Checks whether a match could be the prefix of a reasonable datetime match and therefore if longer matches starting
                with <paramref name="match" /> are worth considering.
            </summary>
            <param name="match">Prefix to consider.</param>
            <returns>True if it is worth considering longer matches with this prefix.</returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.Heuristics.IsReasonableDateTimeMatch(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.Heuristics.CreateDateTimeFormatIfReasonable(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart})">
            <summary>
                Constructs a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" /> only if <paramref name="formatParts" /> satisfies some heuristics of
                being a format a human would actually use.
            </summary>
            <param name="formatParts"><see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart" />s proposed to use in a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" />.</param>
            <returns>A <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat" /> or null if <paramref name="formatParts" /> is deemed unreasonable.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.Heuristics.IsReasonablePartMatch(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch,System.Boolean)">
            <summary>
                Checks of a match of a single <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart" /> should be used to build up larger matches.
            </summary>
            <param name="match">A match of a single <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart" />.</param>
            <returns><c>false</c> if <paramref name="match" /> is heuristically unlikely to be a real match.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart">
            <summary>
                A <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart"/> that matches a number.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart.MaximumValue">
            <summary>
                The maximum int value this may parse and therefore maximum input value to <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart._parseFunc"/>.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart.MinimumValue">
            <summary>
                The minimum int value this may parse and therefore minimum input value to <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart._parseFunc"/>.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart.AllowLeadingZeros">
            <summary>
                If true, when parsing, string may start with a zero ('0') even if it is longer than
                <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.MinimumLength" />.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart._outputFunc">
            <summary>
                Adjustment function to call on the internal value before outputting as a number string for this format.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart._parseFunc">
            <summary>
                Adjustment function to call to convert the parsed number into the internal value.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart.#ctor(System.Char,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart,System.Int32,System.Int32,System.Int32,System.Int32,System.Func{System.Int32,System.Int32},System.Func{System.Int32,System.Int32},System.String,System.String,Microsoft.ProgramSynthesis.DslLibrary.Dates.FormatAttributes)">
            <summary>
                Initializes a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart"/>.
            </summary>
            <param name="formatChar">The character for this format part. The format string is this character repeated <paramref name="minimumLength"/> times.</param>
            <param name="matchedPart">The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart"/> this parses values of.</param>
            <param name="minimumLength">The minimum number of characters for a number this parses/outputs.</param>
            <param name="maximumLength">The maximum number of characters for a number this parses/outputs.</param>
            <param name="minValue">The least valid value this may parse/output.</param>
            <param name="maxValue">The greatest valid value this may parse/output.</param>
            <param name="parseFunc">Optional function to call after parsing. Should be inverse of <paramref name="outputFunc"/>.</param>
            <param name="outputFunc">Optional function to call before outputting number. Should be inverse of <paramref name="parseFunc"/>.</param>
            <param name="posixOutputFormatString">
                The format string corresponding to this according to the POSIX <tt>strftime</tt>
                datetime formatting function.
            </param>
            <param name="posixParsingFormatString">
                The format string corresponding to this according to the POSIX <tt>strptime</tt>
                datetime parsing function.
            </param>
            <param name="attributes">Additional attributes of format.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart.TryParse(System.String,System.Int32,System.Int32)">
            <summary>
                Parse a substring of <paramref name="str" /> as a non-negative <see cref="T:System.Int32" /> written using ASCII digits. No
                overflow checking is performed, so <c><paramref name="end" />-<paramref name="start" /></c> must be at most 9 (the
                maximum number of digits guarenteed to fit in a 32-bit integer).
            </summary>
            <param name="str">String to substring of.</param>
            <param name="start">The start index (inclusive) in <paramref name="str" /> of the number.</param>
            <param name="end">The end index (exclusive) in <paramref name="str" /> of the number.</param>
            <returns>
                The non-negative number parsed from the specified substring or <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if the substring
                does not consist entirely of ASCII digits. If <c><paramref name="end" />-<paramref name="start" /> > 9</c>, then
                the behavior is undefined.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart.ParseAllNext(Microsoft.ProgramSynthesis.DslLibrary.StringRegion)">
            <summary>
                Finds all parses of this starting at the beginning of <paramref name="sr" />. Due to some datetime formats not
                being a fixed length, there may be ambiguity leading to more than one possible parse.
            </summary>
            <param name="sr">
                The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringRegion" /> to look for parses in, beginning at <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Start" />
                and ending anywhere before <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.End" />.
            </param>
            <returns>
                Every substring starting at <paramref name="sr" />'s <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Start" /> which could be parsed
                by this format in a record of the matched <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringRegion" /> and the value of the
                <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.MatchedPart" /> for that parse. The substrings are returned ordered by
                decreasing length. The return value is lazily evaluated.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart.ParseFullString(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart.ParseNext(Microsoft.ProgramSynthesis.DslLibrary.StringRegion)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart.ToString(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart.IsNumeric">
            <summary>
                Does this format parse only numbers (always returns true).
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart.RenderXML">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart.TryParseFromXML(System.Xml.Linq.XElement)">
            <summary>
                Load a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart" /> that had been serialized to XML using <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart.RenderXML" />.
            </summary>
            <param name="literal">An XML element generated by <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart.RenderXML" />.</param>
            <returns>The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.NumericDateTimeFormatPart" /> deserialized from <paramref name="literal" />.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTimeData">
            <summary>
                A fast and small (50 bytes) representation for the values stored in a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTimeData.Empty">
            <summary>
                Construct a new <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTimeData"/> object with no parts set.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTimeData.SetParts">
            <summary>
                A set specifying which date parts are set in the current instance.
                Bits are indexed by the values of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTimeData.Values">
            <summary>
                A vector that stores the values for all date parts represented by the current instance.
                If a bit for a certain <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart" /> kind is set in <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTimeData.SetParts" />, then
                the corresponding vector element at the same index contains the value of this date part kind.
                If a bit is not set, the corresponding vector element is <c>0</c>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTimeData.TryAdd(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart,System.Int32)">
            <summary>
                Set value if it is absent or return <c>false</c> if existing value is different.
            </summary>
            <param name="part">
                <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart" /> to set value for; if currently set, will be checked if it agrees with
                <paramref name="newValue" />.
            </param>
            <param name="newValue">Value to set for <paramref name="part" />.</param>
            <returns><c>true</c> if this now has value <paramref name="newValue" /> for <paramref name="part" />.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime">
            <summary>
                A <see cref="T:System.DateTime" /> that may be missing information. For example, a date with a day of the month and a year
                but not a month.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime._hourValueWas24">
            <summary>
                Boolean flag denoting if hour value was 24. Internally, Hour is always in the closed range [0,23].
                We have to keep this flag around because we can not eagerly replace 24 by 0. We might see day, month,
                and year much later, for e.g. when parsing 24:00 Aug 3, 2015. A partial date time object is never final,
                so, we have to keep this flag to remember that we have to increment a day if (day, month, year) values
                become available.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.Empty">
            <summary>
                A <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime" /> with no information stored in it. All fields are
                <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.Parts">
            <summary>
                The set of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart" /> this contains information on. This corresponds to which properties are not
                <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" />.
            </summary>
            <seealso cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.Get(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart)" />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.Year">
            <summary>
                <see cref="P:System.DateTime.Year" />
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.Month">
            <summary>
                <see cref="P:System.DateTime.Month" />
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.Day">
            <summary>
                <see cref="P:System.DateTime.Day" />
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.DayOfWeek">
            <summary>
                <see cref="P:System.DateTime.DayOfWeek" />
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.DayOfYear">
            <summary>
                <see cref="P:System.DateTime.DayOfYear" />
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.DayOfWeekInMonth">
            <summary>
                <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.DayOfWeekInMonth" />
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.WeekYear">
            <summary>
                <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.WeekYear" />
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.WeekOfYear">
            <summary>
                <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.WeekOfYear" />
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.Hour">
            <summary>
                <see cref="P:System.DateTime.Hour" />
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.HourInPeriod">
            <summary>
                <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.HourInPeriod" />
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.Period">
            <summary>
                <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart.Period" />
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.Minute">
            <summary>
                <see cref="P:System.DateTime.Minute" />
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.Second">
            <summary>
                <see cref="P:System.DateTime.Second" />
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.Millisecond">
            <summary>
                <see cref="P:System.DateTime.Millisecond" />
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.Quarter">
            <summary>
                The quarter (1-4) of the year. Computed from the month.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.Equals(Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime)">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.Contains(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart)">
            <summary>
                Indicates whether the current object contains a value for the date part specified by <paramref name="part" />.
            </summary>
            <param name="part">The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart" /> to check.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.Get(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart)">
            <summary>
                Returns the value of the specified <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart" /> of this or <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if
                this does not contain information on <paramref name="part" />.
            </summary>
            <param name="part">The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart" /> whose value is returned.</param>
            <returns>The value of <paramref name="part" /> or <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.GetAsString(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart)">
            <summary>
                Returns the human-readable string of the specified <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart" /> of this or
                <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if this does not contain information on <paramref name="part" />. This exists
                because some parts like <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.DayOfWeek" /> have friendly string representations separate from their
                <see cref="T:System.Int32" /> representations.
            </summary>
            <param name="part">The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart" /> whose value is returned.</param>
            <returns>The human-readable value of <paramref name="part" /> or <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.Create(System.DateTime)">
            <summary>
                Creates a complete <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime" /> with all of the information from <paramref name="dt" />. Since
                <paramref name="dt" /> is a concrete <see cref="T:System.DateTime" />, the resulting <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime" /> will
                have all fields filled in.
            </summary>
            <param name="dt"><see cref="T:System.DateTime" /> to convert to a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime" />.</param>
            <returns>A <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime" /> equivalent to <paramref name="dt" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.Create(System.DateTimeOffset)">
            <summary>
                Creates a complete <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime" /> with all of the information from <paramref name="dt" />. Since
                <paramref name="dt" /> is a concrete <see cref="T:System.DateTimeOffset" />, the resulting <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime" /> will
                have all fields filled in.
            </summary>
            <param name="dto"><see cref="T:System.DateTimeOffset" /> to convert to a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime" />.</param>
            <returns>A <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime" /> equivalent to <paramref name="dto" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.ToDateTime">
            <summary>
                Creates a <see cref="T:System.DateTime" /> which is equivalent to this for all fields for which this has a value. All fields
                for which this has <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" />, the returned <see cref="T:System.DateTime" /> may have any value.
            </summary>
            <returns>A <see cref="T:System.DateTime" /> representation of this.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.Explains(Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime)">
            <summary>
                Checks if the information in this is a superset of the information in another <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime" />. Used
                to determine if <paramref name="toExplain" /> is a valid output if this is the input.
            </summary>
            <param name="toExplain">Values that may have come from this.</param>
            <returns>True if <paramref name="toExplain" /> can be computed from this.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.CombineWith(Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime)">
            <summary>
                Combines two <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime" />s into a single <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime" /> containing the
                information from both.
            </summary>
            <param name="other"><see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime" /> to combine with this.</param>
            <returns>
                A combined <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime" /> or <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if this is inconsistent with
                <paramref name="other" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.With(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart,System.Int32)">
            <summary>
                Creates a new <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime" /> with the information from this and also a <paramref name="part" />
                value of <paramref name="value" />.
            </summary>
            <param name="part">The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart" /> of the new information.</param>
            <param name="value">The value of the new information.</param>
            <returns>
                A <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime" /> identical to this except it also has a <paramref name="part" /> of
                <paramref name="value" />, or <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if that is inconsistent.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.Without(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart)">
            <summary>
                Creates a new <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime" /> with the information from this except for
                explicit information about <paramref name="part" />. Note the value may be implied by other values.
            </summary>
            <param name="part">The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart" /> to remove information for.</param>
            <returns>
                A <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime" /> identical to this except it is missing a <paramref name="part" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.Equals(System.Object)">
            <summary>
                Determines whether the specified <see cref="T:System.Object" /> is equal to the current
                <see cref="T:System.Object" />.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.GetHashCode">
            <summary>
                Serves as a hash function for a particular type.
            </summary>
            <returns>
                A hash code for the current <see cref="T:System.Object" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.op_Equality(Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime,Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime)">
            <summary>
                Checks if two partial date times are equal.
            </summary>
            <param name="left">The first partial date time.</param>
            <param name="right">The second partial date time.</param>
            <returns>
                True if <paramref name="left" /> and <paramref name="right" /> represent the same date time.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.op_Inequality(Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime,Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime)">
            <summary>
                Checks if two partial date times are not equal.
            </summary>
            <param name="left">The first partial date time.</param>
            <param name="right">The second partial date time.</param>
            <returns>
                False if <paramref name="left" /> and <paramref name="right" /> represent the same date time.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.ToString">
            <summary>
                Returns a string that represents the current object.
            </summary>
            <returns>
                A string that represents the current object.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.RenderHumanReadable">
            <summary>
                Render this as a human-readable string representation. This should be parseable by the corresponding
                <see cref="P:Microsoft.ProgramSynthesis.Utils.ParseableAttribute.ParseHumanReadableString" /> method.
            </summary>
            <returns>A compact string representation of this object that is easy for a human to understand.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime.RenderXML">
            <summary>
                Render this as XML. This should be parseable by the corresponding <see cref="P:Microsoft.ProgramSynthesis.Utils.ParseableAttribute.ParseXML" />
                method.
            </summary>
            <returns>An XML representation of this object.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.PowerAppsDateTimeFormatTranslator">
            <summary>
                Power Apps-specific datetime format translator.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.RewritingDateTimeFormatTranslator">
            <summary>
                Datetime format translator that implements a generic translation which additionally allows
                any implementation to specify whether certain fragments of the date time format should be
                rewritten into a specialized short format.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.RewritingDateTimeFormatTranslator.Rewrites">
            <summary>
                List of rewrites that are to be applied. 
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.RewritingDateTimeFormatTranslator.TranslateWithSegmentInfo(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.MomentJsDateTimeFormatTranslator">
            <summary>
                Datetime format translator for momentjs.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.MomentJsDateTimeFormatTranslator.Rewrites">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DayJsDateTimeFormatTranslator">
            <summary>
                Datetime format translator for dayjs (requires LocalizedFormat plugin).
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.DayJsDateTimeFormatTranslator.Rewrites">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart">
            <summary>
                A <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart" /> that matches a word. Each word matched has a distinct corresponding
                <see cref="T:System.Int32" /> value.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart.#ctor(System.String,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart,System.Collections.Immutable.IImmutableDictionary{System.Int32,System.String},Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart,System.String,System.String,Microsoft.ProgramSynthesis.DslLibrary.Dates.FormatAttributes)">
            <summary>
                Constructs a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart" />.
            </summary>
            <param name="formatString">The .NET <see cref="T:System.DateTime" /> format string for this.</param>
            <param name="matchedPart">The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimePart" /> this matches.</param>
            <param name="stringLookup">The correspondence between matched strings and the parsed values.</param>
            <param name="abbreviationOf">
                If not <c>null</c>, then this is an abbreviation of a longer format. Useful because values
                of this format maybe prefixes of values of that format.
            </param>
            <param name="posixOutputFormatString">
                The format string corresponding to this according to the POSIX <tt>strftime</tt>
                datetime formatting function.
            </param>
            <param name="posixParsingFormatString">
                The format string corresponding to this according to the POSIX <tt>strptime</tt>
                datetime parsing function.
            </param>
            <param name="attributes">Additional attributes of format.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart.StringLookup">
            <summary>
                The correspondence of values to words.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart.AllValues">
            <summary>
                All the values this format part can take.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart.AbbreviationOf">
            <summary>
                If not <c>null</c>, then this is an abbreviation of a longer format. Useful because values
                of this format maybe prefixes of values of that format.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart.ParseNext(Microsoft.ProgramSynthesis.DslLibrary.StringRegion)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart.ToString(System.Int32)">
            <summary>
                Convert a value to a string according to this date format.
                The inverse of <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatPart.ParseFullString(System.String)" />
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart.RenderXML">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart.TryParseFromXML(System.Xml.Linq.XElement)">
            <summary>
                Load a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart" /> that had been serialized to XML using <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart.RenderXML" />.
            </summary>
            <param name="literal">An XML element generated by <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart.RenderXML" />.</param>
            <returns>The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart" /> deserialized from <paramref name="literal" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart.CreateDayOfWeek(System.String,System.String,Microsoft.ProgramSynthesis.DslLibrary.Dates.FormatAttributes)">
            <summary>
                Creates a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart" /> that matches a day of the week. Uses the
                <paramref name="formatString" /> parameter and <see cref="T:System.DateTime" /> to get the values for
                <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />.
            </summary>
            <param name="formatString">
                The .NET <see cref="T:System.DateTime" /> format string to create a
                <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart" /> for. Used to determine what strings to use.
            </param>
            <param name="posixFormat">The corresponding POSIX format string.</param>
            <param name="attributes">Additional attributes of format.</param>
            <returns>A <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart" /> equivalent to <paramref name="formatString" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart.CreateMonth(System.String,System.String,Microsoft.ProgramSynthesis.DslLibrary.Dates.FormatAttributes)">
            <summary>
                Creates a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart" /> that matches a month name. Uses the
                <paramref name="formatString" /> parameter and <see cref="T:System.DateTime" /> to get the values for
                <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />.
            </summary>
            <param name="formatString">
                The .NET <see cref="T:System.DateTime" /> format string to create a
                <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart" /> for. Used to determine what strings to use.
            </param>
            <param name="posixFormat">The corresponding POSIX format string.</param>
            <param name="attributes">Additional attributes of format.</param>
            <returns>A <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart" /> equivalent to <paramref name="formatString" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart.CreatePeriod(System.String,Microsoft.ProgramSynthesis.DslLibrary.Dates.FormatAttributes)">
            <summary>
                Creates a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart" /> that matches a period designator. Uses the
                <paramref name="formatString" /> parameter and <see cref="T:System.DateTime" /> to get the values for
                <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />.
            </summary>
            <param name="formatString">
                The .NET <see cref="T:System.DateTime" /> format string to create a
                <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart" /> for. Used to determine what strings to use.
            </param>
            <param name="attributes">Additional attributes of format.</param>
            <returns>A <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart" /> equivalent to <paramref name="formatString" />.</returns>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Dates.StringDateTimeFormatPart.DateValueStrings">
            <summary>
                A list of strings which are almost certainly are date values of some sort (e.g. a month or day of week).
                This only includes abbreviations because the unabbreviated values contain the abbreviated values as
                substrings.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.TimeZoneOffsetFormatPart.RenderXML">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.TimeZoneOffsetFormatPart.TryParseFromXML(System.Xml.Linq.XElement)">
            <summary>
                Load a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.TimeZoneOffsetFormatPart" /> that had been serialized to XML using <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.TimeZoneOffsetFormatPart.RenderXML" />.
            </summary>
            <param name="literal">An XML element generated by <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Dates.TimeZoneOffsetFormatPart.RenderXML" />.</param>
            <returns>The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.TimeZoneOffsetFormatPart" /> deserialized from <paramref name="literal" />.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.EntityDetectors.EntityDetector">
            <summary>
            Defines a contract as an abstract class that any Entity Detector to be plugged in the learning/execution of programs should abide by.
            The class also contains the serialization and deserialization logic used while serializing programs.
            While serializing we use the entity name string, while deserializing we pick up the corresponding <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.EntityDetectors.EntityDetector"/> object from the <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.EntityDetectors.EntityDetectorsMap"/>>
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.EntityDetectors.EntityDetector.Name">
            <summary>
                Unique property defined for every entity detector object.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.EntityDetectors.EntityDetector.InputMaxLengthLimit">
            <summary>
                Property defined for every entity detector to limit the length of input text it will be operating on.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.EntityDetectors.EntityDetector.GetMatches(System.String)">
            <summary>
                A method that intends to contain the entity detection logic and return set of possible matches
            </summary>
            <param name="input">The text on which the entity detection logic should operate.</param>
            <returns>An enumerable of having the set of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.PositionMatch"/> at which entity is matched. </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.EntityDetectors.EntityDetector.HasEntity(System.String)">
            <summary>
                A method that intends to detect the presence of an entity in the input string.
            </summary>
            <param name="input">The string on which the entity detection logic should operate.</param>
            <returns>A boolean value indicating entity presence. </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.EntityDetectors.EntityDetector.RenderHumanReadable">
            <summary>
                Render entity name (string value) for output in a human-readable AST.
            </summary>
            <returns>A human-readable code string of this entity name.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.EntityDetectors.EntityDetector.RenderXML">
            <summary>
                Render entity name (string value) as an attribute for EntityDetector named element for output in an XML AST.
            </summary>
            <returns>An <see cref="T:System.Xml.Linq.XElement" /> with Name as an attribute.</returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.DslLibrary.EntityDetectors.EntityDetector.TryParseFromXML(System.Xml.Linq.XElement,Microsoft.ProgramSynthesis.AST.DeserializationContext)" />
            <seealso cref="M:Microsoft.ProgramSynthesis.DslLibrary.Token.ToXml" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.EntityDetectors.EntityDetector.TryParseFromXML(System.Xml.Linq.XElement,Microsoft.ProgramSynthesis.AST.DeserializationContext)">
            <summary>
                Loads an <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.EntityDetectors.EntityDetector" /> with Name being the value of name which had been serialized as an attribute to XML using <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.EntityDetectors.EntityDetector.RenderXML" />.
            </summary>
            <param name="literal">An XML element generated by <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.EntityDetectors.EntityDetector.RenderXML" />.</param>
            <param name="context">A context to pass through to all deserialization methods.</param>
            <returns>The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.EntityDetectors.EntityDetector" /> object obtained from the dictionary of Name and corresponding  EntityDetector Objects with Name as the key deserialized from <paramref name="literal" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.EntityDetectors.EntityDetector.TryParseHumanReadable(System.String,Microsoft.ProgramSynthesis.AST.DeserializationContext)">
            <summary>
                Loads an <see cref="!:PluggableEntityDetector" /> with Name being the value serialized to HumanReadable code using <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.EntityDetectors.EntityDetector.RenderHumanReadable" />.
            </summary>
            <param name="literal">A human-readable code string of this entity name generated by <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.EntityDetectors.EntityDetector.RenderHumanReadable" />.</param>
            <param name="context">A context to pass through to all deserialization methods.</param>
            <returns>The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.EntityDetectors.EntityDetector" /> object obtained from the dictionary of Name and corresponding  EntityDetector Objects with Name as the key deserialized from <paramref name="literal" />.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.EntityDetectors.EntityDetectorsMap">
            <summary>
                The class maintains a map of Entity Detectors, with the name as key and corresponding entity detector instance as
                value.
                This is passed down as DeserializationContext and helps to handle serialization of programs using Entity Detectors.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.EntityDetectors.IEntityDetectorWrapper">
            <summary>
                Interface for types to use to advertise they wrap one or more <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.EntityDetectors.EntityDetector" />s.
                Used by <see cref="!:EntityDetectorsMapConstraint" /> to check that
                only valid <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.EntityDetectors.EntityDetector" />s are referenced.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.ExternalEntityToken.GetMatches(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.ExternalEntityToken.ToXml">
            <summary>
                This is used during XML serialization, overriden to take care of ExternalEntityTokens.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring">
            <summary>
                A <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Substring"/> with a string learning cache included.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring.#ctor(System.String,System.Collections.Generic.IReadOnlyDictionary{System.String,Microsoft.ProgramSynthesis.DslLibrary.Token})">
            <summary>
                Creates a region for <paramref name="s" />.
            </summary>
            <param name="s">The document region.</param>
            <param name="tokens">The tokens used to build the cache.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring.Cache">
            <summary>
                The learning cache for <see cref="!:S" /> which is used during learning.
                This cache is shared among different regions in <see cref="!:S" />.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Numbers.NumberOptions.DecimalMarkOptions">
            <summary>
                The options for the decimal mark.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Numbers.RoundingMode">
            <summary>
                Specifies what logic to use to decide to round up or down.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Numbers.RoundingMode.Nearest">
            <summary>
                Round to the nearest number, greater on ties.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Numbers.RoundingMode.Down">
            <summary>
                Always round down.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Numbers.RoundingMode.Up">
            <summary>
                Always round up.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Numbers.RoundingMode.UpOrNext">
            <summary>
                Always increase value: if already rounded, go to the next value up.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Numbers.RoundingMode.TowardZero">
            <summary>
                Never change more significant digits. Same as <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Numbers.RoundingMode.Down" /> for positive numbers and <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Numbers.RoundingMode.Up" /> for
                negative numbers.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Numbers.RoundingMode.AwayFromZero">
            <summary>
                Round away from zero. Opposite of <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Numbers.RoundingMode.TowardZero" />. Same as <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Numbers.RoundingMode.Up" /> for positive numbers and
                <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Numbers.RoundingMode.Down" /> for negative numbers.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Substring">
            <summary>
                An efficient representation for substrings.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Substring.SubstringHash(System.String,System.Int32,System.Int32)">
            <summary>
                Compute a hashcode for a substring of a string. This hashcode depends only on the values of the characters in
                <paramref name="s" /> between <paramref name="startIndex" /> (inclusive) and <paramref name="endIndex" />
                (exclusive).
            </summary>
            <param name="s">Entire string.</param>
            <param name="startIndex">Start index (inclusive).</param>
            <param name="endIndex">End index (exclusive).</param>
            <returns>A hash code on the specified substring value.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Source">
            <summary>
                The original string.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Start">
            <summary>
                The starting position of this region in <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Source" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.End">
            <summary>
                The ending position of this region in <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Source" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.IsValueAlreadyComputed">
            <summary>
                If <c>true</c>, then <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Value" /> will not do any computation. This allows subtypes to make performance
                trade-offs of going on a fast path with the cost of the allocation for <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Value" /> vs. a slower path that
                avoids the allocation for <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Value" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Value">
            <summary>
                The string value of this region. This is the substring of <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.SubstringInfo.Source" /> determined by
                <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.SubstringInfo.Start" /> and
                <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.SubstringInfo.End" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Length">
            <summary>
                Returns the length of this region.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Item(System.UInt32)">
            <summary>
                Returns the <see cref="T:System.Char" /> at the position <paramref name="index" />.
            </summary>
            <param name="index">The index.</param>
            <returns>
                The character at the position <paramref name="index" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegexToken.#ctor(System.Text.RegularExpressions.Regex,System.String,System.Int32,System.Double,System.Func{System.String,System.Double},System.Boolean,System.Boolean,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegexToken.#ctor(System.String,System.String,System.Int32,System.Double,System.Func{System.String,System.Double},System.Boolean,System.Boolean,System.String)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression">
            <summary>
                A regular expression is a sequence of tokens. Its length is limited to 3 tokens for performance reasons.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.DefaultTokenCount">
            <summary>
                The default number of tokens in a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.#ctor(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.DslLibrary.Token},System.Int32)">
            <summary>
                Constructs a regular expression from a sequence of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Token" />s. Use <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.Create(System.Int32)" /> and
                its overloads instead of calling this constructor directory.
            </summary>
            <param name="tokens">The first token, or null if regular expression has zero tokens.</param>
            <param name="exampleCount">The <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.ExampleCount" />.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.Tokens">
            <summary>
                The constituent tokens.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.Count">
            <summary>
                How many <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Token" />s in this regular expression (up to 3).
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.ExampleCount">
            <summary>
                The number of examples provided by the user in a current learning session.
            </summary>
            <seealso cref="!:StringLearningCache.ExampleCount" />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.Score">
            <summary>
                The ranking score of the regular expression. The higher the better.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.Regex">
            <summary>
                Converts this to an equivalent <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.Regex" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.RenderHumanReadable">
            <summary>
                Render regular expression for output in a human-readable AST.
            </summary>
            <returns>A human-readable code string of this regular expression.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.RenderXML">
            <summary>
                Render regular expression for output in an XML AST.
            </summary>
            <returns>An <see cref="T:System.Xml.Linq.XElement" /> of this regular expression.</returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.TryParseFromXML(System.Xml.Linq.XElement,Microsoft.ProgramSynthesis.AST.DeserializationContext)" />
            <seealso cref="M:Microsoft.ProgramSynthesis.DslLibrary.Token.ToXml" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.Run(Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring)">
            <summary>
                Return all matching positions within a range in a string.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.MatchesAt(Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring,System.UInt32)">
            <summary>
                Checks if this regular expression matches the string at <paramref name="position" /> within a substring.
            </summary>
            <param name="s">The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring" /> to match on.</param>
            <param name="position">The position to look for a match at.</param>
            <returns>
                True if this regular expression match a string starting at <paramref name="position" />.
            </returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.LeftMatchesAt(Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring,System.UInt32)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.LeftMatchesAt(Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring,System.UInt32)">
            <summary>
                Checks if this regular expression matches a string ending at <paramref name="position" /> within a substring.
            </summary>
            <param name="s">The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring" /> to match on.</param>
            <param name="position">The position to look for a match ending at.</param>
            <returns>
                True if this regular expression matches a substring ending at <paramref name="position" />.
            </returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.MatchesAt(Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring,System.UInt32)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.Equals(System.Object)">
            <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="other">The object to compare with the current object. </param>
            <seealso cref="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.Equals(Microsoft.ProgramSynthesis.DslLibrary.RegularExpression)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.ToString">
            <summary>
                Returns a string representation of this regular expression.
            </summary>
            <returns>A string representation of this regular expression.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.GetHashCode">
            <summary>
                Serves as the default hash function.
            </summary>
            <returns>
                A hash code for the current object.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.TryParseFromXML(System.Xml.Linq.XElement,Microsoft.ProgramSynthesis.AST.DeserializationContext)">
            <summary>
                Loads a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression" /> that had been serialized to XML using <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.RenderXML" />.
            </summary>
            <param name="literal">An XML element generated by <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.RenderXML" />.</param>
            <param name="context">Context passed along in order to support deserialization, specifically needed for programs learned using pluggable entity detectors />.</param>
            <returns>The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression" /> deserialized from <paramref name="literal" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.ToRegexJsonArray">
            <summary>
                Returns the associated complete regular expression.
                Use this to let the user re-match this regular expression on his text.
            </summary>
            <returns>
                A string array of tokens suitable for constructing <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.Regex" /> objects equivalent to the tokens which
                concatenated together make up this regular expression.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.Create(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.DslLibrary.Token},System.Int32)">
            <summary>
                Constructs a regular expression matching a sequence tokens concatenated together.
            </summary>
            <param name="tokens">The sequence of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Token" />s this regular expression matches.</param>
            <param name="exampleCount">The <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.ExampleCount" />.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.LearnFullMatches(Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring,System.Int32,System.Int32)">
            <summary>
                Learns a list of regexes that matches <paramref name="s" /> entirely.
            </summary>
            <param name="s">The string region to learn from.</param>
            <param name="maxTokenCount">The maximum number of tokens in the returned <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression" />.</param>
            <param name="exampleCount">The number of given examples.</param>
            <returns>A list of matching <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression" />s.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.LearnRightMatches(Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring,System.UInt32,System.Int32,System.Int32)">
            <summary>
                Learns a list of regexes that matches <paramref name="pos" /> on its right in a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring" />.
            </summary>
            <param name="s">The string region to learn from.</param>
            <param name="pos">The matching position.</param>
            <param name="maxTokenCount">The maximum number of tokens in the returned <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression" />.</param>
            <param name="exampleCount">The number of given examples.</param>
            <returns>A list of matching <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression" />s.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.LearnRightMatches(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Utils.Record{Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring,System.UInt32}},System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Utils.Record{Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring,System.UInt32}},System.Int32,System.Int32)">
            <summary>
                Learns a list of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression" />s that matches all positions in
                <paramref name="positivePosInSubstrings" />
                on their right in a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring" /> and does not match any positions in
                <paramref name="negativePosInSubstrings" />.
            </summary>
            <param name="positivePosInSubstrings">
                The list of positions within a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring" /> which the learned <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression" />s should
                match on the right.
            </param>
            <param name="negativePosInSubstrings">
                The list of positions within a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring" /> which the learned <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression" />s should
                NOT match on the right.
            </param>
            <param name="maxTokenCount">The maximum number of tokens in the returned <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression" />.</param>
            <param name="exampleCount">The number of given examples.</param>
            <returns>A list of matching <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression" />s.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.LearnRightMatches(Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring,System.UInt32,System.Int32,System.Boolean,System.Int32)">
            <summary>
                Learns a list of regexes that matches <paramref name="pos" /> on its right in a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring" />.
                If <paramref name="fullMatch" /> is set, will only return regexes that that will have matches of length (end -
                pos).
            </summary>
            <param name="s">The string region to learn from.</param>
            <param name="pos">The matching position.</param>
            <param name="maxTokenCount">The maximum number of tokens in the returned <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression" />.</param>
            <param name="fullMatch">
                Specify whether the <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression" /> should match the entire
                <paramref name="s" /> or not.
            </param>
            <param name="exampleCount">The number of given examples.</param>
            <returns>A list of matching <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression" />s.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.LearnLeftMatches(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Utils.Record{Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring,System.UInt32}},System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Utils.Record{Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring,System.UInt32}},System.Int32,System.Int32)">
            <summary>
                Learns a list of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression" />s that matches all positions in
                <paramref name="positivePosInSubstrings" />
                on their left in a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring" /> and does not match any positions in
                <paramref name="negativePosInSubstrings" />.
            </summary>
            <param name="positivePosInSubstrings">
                The list of positions within a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring" /> which the learned <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression" />s should
                match on the left.
            </param>
            <param name="negativePosInSubstrings">
                The list of positions within a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring" /> which the learned <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression" />s should
                NOT match on the left.
            </param>
            <param name="maxTokenCount">The maximum number of tokens in the returned <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression" />.</param>
            <param name="exampleCount">The number of given examples.</param>
            <returns>A list of matching <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression" />s.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.LearnLeftMatches(Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring,System.UInt32,System.Int32,System.Int32)">
            <summary>
                Learns a list of regexes that matches <paramref name="pos" /> on its left.
            </summary>
            <param name="s">The string region to learn from.</param>
            <param name="pos">The matching position.</param>
            <param name="maxTokenCount">The maximum number of tokens in the returned <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression" />.</param>
            <param name="exampleCount">The number of given examples.</param>
            <returns>A list of matching <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression" />s.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.Create(System.Int32)">
            <summary>
                Constructs an empty regular expression with the given <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.ExampleCount" />.
            </summary>
            <param name="exampleCount">The <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.ExampleCount" />.</param>
            <returns>A regular expression matching the empty string.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.Create(Microsoft.ProgramSynthesis.DslLibrary.Token,System.Int32)">
            <summary>
                Constructs a regular expression containing a single token.
            </summary>
            <param name="token">The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Token" /> this regular expression matches.</param>
            <param name="exampleCount">The <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.ExampleCount" />.</param>
            <returns>A regular expression matching <paramref name="token" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.Create(Microsoft.ProgramSynthesis.DslLibrary.Token,Microsoft.ProgramSynthesis.DslLibrary.Token,System.Int32)">
            <summary>
                Constructs a regular expression matching two tokens concatenated together.
            </summary>
            <param name="token1">The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Token" /> this regular expression matches first.</param>
            <param name="token2">The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Token" /> this regular expression matches second.</param>
            <param name="exampleCount">The <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.ExampleCount" />.</param>
            <returns>A regular expression matching <paramref name="token1" /> followed by <paramref name="token2" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.Create(Microsoft.ProgramSynthesis.DslLibrary.Token,Microsoft.ProgramSynthesis.DslLibrary.Token,Microsoft.ProgramSynthesis.DslLibrary.Token,System.Int32)">
            <summary>
                Constructs a regular expression matching three tokens concatenated together.
            </summary>
            <param name="token1">The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Token" /> this regular expression matches first.</param>
            <param name="token2">The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Token" /> this regular expression matches second.</param>
            <param name="token3">The <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Token" /> this regular expression matches third.</param>
            <param name="exampleCount">The <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression.ExampleCount" />.</param>
            <returns>
                A regular expression matching <paramref name="token1" /> followed by <paramref name="token2" /> followed by
                <paramref name="token3" />.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpressionPositions">
            <summary>
                Semantics and utilities for <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression"/>s and positions in strings.
            </summary>
            <remarks>
                These were originally in Extraction.Text but are also used by Transformation.Text.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpressionPositions.RegexPosition(Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring,Microsoft.ProgramSynthesis.Utils.Record{Microsoft.ProgramSynthesis.DslLibrary.RegularExpression,Microsoft.ProgramSynthesis.DslLibrary.RegularExpression},System.Int32)">
            <summary>
                Finds the <paramref name="k" />-th match of regular expression <paramref name="rr" /> in <paramref name="s" />.
                If <paramref name="k" /> is negative finds the <paramref name="k" />-th match from the end.
            </summary>
            <param name="s">String to look for matches in.</param>
            <param name="rr">
                Regular expression to find matches for. Matches are for the two regular expressions concatenated
                together and the index is the index between the matches for the two regular expressions.
            </param>
            <param name="k">
                A non-zero index into the matches: positive indexes count from the start with 1 being the first match
                and negative indexes count from the end with -1 being the last match.
            </param>
            <returns>
                The index where the match for the first regular expression in <paramref name="rr" /> ends and the match for
                the second regular expression in <paramref name="rr" /> begins.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpressionPositions.RunRR(Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring,Microsoft.ProgramSynthesis.Utils.Record{Microsoft.ProgramSynthesis.DslLibrary.RegularExpression,Microsoft.ProgramSynthesis.DslLibrary.RegularExpression})">
            <summary>
                Returns all positions where <paramref name="rr" />.Item1 matches to the left and
                <paramref name="rr" />.Item2 matches to the right.
            </summary>
            <param name="s">String to find matches in.</param>
            <param name="rr">A record defining the left (Item1) and right (Item2) boundary regular expressions.</param>
            <returns>A sequence of positions in <paramref name="s" /> that match.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpressionPositions.GetRegexesAtPositions(Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring,System.Collections.Generic.IEnumerable{System.UInt32},System.Int32)">
            <summary>
                Find all pairs of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression"/>s that bracket any of the given positions in the
                string.
            </summary>
            <param name="substring">The string to search in.</param>
            <param name="positions">A sequence of positions to locate using <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression"/>s.</param>
            <param name="exampleCount">The number of given examples.</param>
            <returns>
                A sequence of pairs of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression"/>s that bracket any of the positions in
                <paramref name="positions" /> in the string <paramref name="substring"/>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.RegularExpressionPositions.GetRegexesAndIndexesAtPositions(Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring,System.Collections.Generic.IEnumerable{System.UInt32},System.Int32,System.Nullable{System.Int32},System.Boolean)">
            <summary>
                Find all pairs of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression"/>s and the indexed location of occurrences of each
                pair that bracket any of the given positions in the string.
            </summary>
            <param name="substring">The string to search in.</param>
            <param name="positions">A sequence of positions to locate using <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression"/>s.</param>
            <param name="exampleCount">The number of given examples.</param>
            <param name="tokenCount">The number of tokens in a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression"/>.</param>
            <param name="allowRegexPair">Allows both <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression"/>s to be non-empty.</param>
            <returns>
                A set of pairs of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression"/>s and indexed locations of those pairs that bracket any
                of the positions in <paramref name="positions" /> in the string <paramref name="substring"/>.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache">
            <summary>
                Represents the token matching cache for a string.
                It contains the tokens (both static and dynamics) and their matches in the string.
                Implemented as Singleton.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache._endingTokenMatches">
            <summary>
                Stores all matches that end at a position.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache._matchPositions">
            <summary>
                Store all matching position of all tokens
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache._startingTokenMatches">
            <summary>
                Stores all matches that start at a position.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache._tokens">
            <summary>
                All tokens in the cache (both static and dynamic)
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache._populatedTokenCaches">
            <summary>
                Indicates that we have populated the caches for static tokens.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache._specializedCaches">
            <summary>
                Holds other caches of information relevant to <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache.Content" />.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache.StaticTokens">
            <summary>
                The list of static tokens in the cache.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache.#ctor(System.String,System.Collections.Generic.IReadOnlyDictionary{System.String,Microsoft.ProgramSynthesis.DslLibrary.Token})">
            <summary>
                Constructs the cache for a string.
            </summary>
            <param name="s">The string to construct cache for.</param>
            <param name="tokens">The tokens used to build the cache.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache.Content">
            <summary>
                The (modified) string content.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache.StartPosition">
            <summary>
                The starting position.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache.EndPosition">
            <summary>
                Determines the validity of the start position of the boundary.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache.TryGetAllMatchesStartingAt(System.UInt32,Microsoft.ProgramSynthesis.Utils.Caching.UnboundedCache{Microsoft.ProgramSynthesis.DslLibrary.Token,Microsoft.ProgramSynthesis.DslLibrary.TokenMatch}@)">
            <summary>
                Gets all token matches at a specific location.
            </summary>
            <param name="pos">The look up location.</param>
            <param name="matches">The matches at the location if found, null otherwise.</param>
            <returns>true if there exists matches at the location.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache.TryGetTokenMatchStartingAt(System.UInt32,Microsoft.ProgramSynthesis.DslLibrary.Token,Microsoft.ProgramSynthesis.DslLibrary.PositionMatch@)">
            <summary>
                Gets all the matches for a token at a specific location.
            </summary>
            <param name="pos">The look up location.</param>
            <param name="token">The token to look up.</param>
            <param name="match">The match if found, <c>default</c> otherwise.</param>
            <returns>true if there exists a match at the location.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache.TryGetAllMatchesEndingAt(System.UInt32,Microsoft.ProgramSynthesis.Utils.Caching.UnboundedCache{Microsoft.ProgramSynthesis.DslLibrary.Token,Microsoft.ProgramSynthesis.DslLibrary.TokenMatch}@)">
            <summary>
                Gets all token matches that <b>end</b> at a specific location.
            </summary>
            <param name="pos">The look up location.</param>
            <param name="matches">The matches if found, null otherwise.</param>
            <returns>true if there exists matches ending at the location.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache.TryGetTokenMatchEndingAt(System.UInt32,Microsoft.ProgramSynthesis.DslLibrary.Token,Microsoft.ProgramSynthesis.DslLibrary.PositionMatch@)">
            <summary>
                Gets all the matches that end at a specific location for a token.
            </summary>
            <param name="pos">The look up location.</param>
            <param name="token">The token to look up.</param>
            <param name="match">The match if found, <c>default</c> otherwise.</param>
            <returns>true if there exists a match ending at the location.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache.TryGetMatchPositionsFor(Microsoft.ProgramSynthesis.DslLibrary.Token,Microsoft.ProgramSynthesis.DslLibrary.CachedList@)">
            <summary>
                Gets all matches of a token.
            </summary>
            <param name="token">The token to get matches for.</param>
            <param name="matchPositions">The matches if found, null otherwise.</param>
            <returns>true if there exists matches for the token.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache.GetAllTokensMatchPositions(System.UInt32,System.UInt32)">
            <summary>
                Gets all matches of all tokens within <paramref name="start" /> and <paramref name="end" /> (inclusive).
            </summary>
            <param name="start">The starting of the range.</param>
            <param name="end">The ending of the range.</param>
            <returns>All token matches.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache.GetStaticTokenByName(System.String)">
            <summary>
                Gets the token by its name.
            </summary>
            <param name="name">The name of the token.</param>
            <returns>The token if found, null otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache.InitializeStaticTokens(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.DslLibrary.Token})">
            <summary>
                Initializes the static tokens with some tokens.
            </summary>
            <param name="supportedTokens">The list of tokens to initialize.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache.AddTokens(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.DslLibrary.Token})">
            <summary>
                Adds a sequence of tokens to the cache.
            </summary>
            <param name="tokens">The tokens to add.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache.AddMatch(Microsoft.ProgramSynthesis.DslLibrary.Token,Microsoft.ProgramSynthesis.DslLibrary.PositionMatch)">
            <summary>
                Adds a match for <paramref name="token" />.
            </summary>
            <param name="token">The token which has been matched.</param>
            <param name="match">The position at which <paramref name="token" /> has matched in this <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringRegion" />.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache.MatchStartPositions">
            <summary>
                Collection of all positions at which any token starts. These are the positions that
                <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache.TryGetAllMatchesStartingAt(System.UInt32,Microsoft.ProgramSynthesis.Utils.Caching.UnboundedCache{Microsoft.ProgramSynthesis.DslLibrary.Token,Microsoft.ProgramSynthesis.DslLibrary.TokenMatch}@)" /> works for.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache.MatchEndPositions">
            <summary>
                Collection of all positions at which any token ends. These are the positions that
                <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache.TryGetAllMatchesEndingAt(System.UInt32,Microsoft.ProgramSynthesis.Utils.Caching.UnboundedCache{Microsoft.ProgramSynthesis.DslLibrary.Token,Microsoft.ProgramSynthesis.DslLibrary.TokenMatch}@)" /> works for.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache.GetSpecializedCache``1(System.Func{Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache,``0})">
            <summary>
                Gets the specialized cache of type <typeparamref name="TCache" /> associated with this. Specialized caches contain
                information other than just regular expression matches about a string which can be used during learning.
                <paramref name="createFunc" /> is used to construct the cache if it doesn't exist yet.
            </summary>
            <typeparam name="TCache">Type of the cache.</typeparam>
            <param name="createFunc">Constructor for a cache of type <typeparamref name="TCache" />.</param>
            <returns>The cache of type <typeparamref name="TCache" /> for the same string this is a cache for.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache.CloneWithCurrentCacheState">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache.ClearCaches">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache.Microsoft#ProgramSynthesis#Utils#Caching#ICachefulObject#CloneWithCurrentCacheState">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.StringRegion">
            <summary>
                Represents a substring in a string which has a learning cache and defines equality by identity.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringRegion.#ctor(System.String,System.Collections.Generic.IReadOnlyDictionary{System.String,Microsoft.ProgramSynthesis.DslLibrary.Token})">
            <summary>
                Creates a region for <paramref name="s" />.
            </summary>
            <param name="s">The document region.</param>
            <param name="tokens">The tokens used to build the cache.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.StringRegion.StartPositionIsPrecise">
            <summary>
                Determines the validity of the start position of the boundary.
                True if this position is precise, which allows the program to make reference to the starting position.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.StringRegion.EndPositionIsPrecise">
            <summary>
                Determine the validity of the end position of the boundary.
                True if this position is precise, which allows the program to make reference to the ending position.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.StringRegion.WholeRegion">
            <summary>
                Gets the <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringRegion" /> covering the entire document this is a substring of.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringRegion.Equals(Microsoft.ProgramSynthesis.DslLibrary.StringRegion)">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringRegion.CompareTo(Microsoft.ProgramSynthesis.DslLibrary.StringRegion)">
            <summary>
                Compares the current instance with another object of the same type and returns an integer that indicates whether
                the current instance precedes, follows, or occurs in the same position in the sort order as the other object.
                Regions are sorted by their <see cref="!:LearningCacheSubstring.Start" /> position and then by their <see cref="!:LearningCacheSubstring.End" /> position.
            </summary>
            <returns>
                A value that indicates the relative order of the objects being compared. The return value has these meanings: Value
                Meaning Less than zero This instance precedes <paramref name="other" /> in the sort order.  Zero This instance
                occurs in the same position in the sort order as <paramref name="other" />. Greater than zero This instance follows
                <paramref name="other" /> in the sort order.
            </returns>
            <param name="other">An object to compare with this instance. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringRegion.IntersectNonEmpty(Microsoft.ProgramSynthesis.DslLibrary.StringRegion)">
            <summary>
                Checks if this region intersects with <paramref name="region" />.
            </summary>
            <param name="region">The region needs to check for intersection.</param>
            <returns>True if they intersect, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringRegion.Contains(Microsoft.ProgramSynthesis.DslLibrary.StringRegion)">
            <summary>
                Checks if this region contains <paramref name="other" /> region.
            </summary>
            <param name="other">The region to look for in this region.</param>
            <returns>True if <paramref name="other" /> is a region in the same document contained inside or equal to this region.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringRegion.IsBefore(Microsoft.ProgramSynthesis.DslLibrary.StringRegion)">
            <summary>
                Checks if this region starts before <paramref name="other" /> starts and ends before <paramref name="other" />
                ends. Note that the regions may still be overlapping.
            </summary>
            <param name="other">Region to compare against.</param>
            <returns>True if this both starts first and ends first.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringRegion.ClipBefore(Microsoft.ProgramSynthesis.DslLibrary.StringRegion)">
            <summary>
                Clip this region to end before <paramref name="other" /> if they overlap.
            </summary>
            <param name="other">A region starting after this one.</param>
            <returns>
                A region that starts at the same position but ends at the same position or immediately before
                <paramref name="other" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringRegion.GetHashCode">
            <summary>
                Serves as the default hash function.
            </summary>
            <returns>
                A hash code for the current object.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringRegion.Microsoft#ProgramSynthesis#Utils#Caching#ICachefulObject#CloneWithCurrentCacheState">
            <summary>
                Returns a clone of the object with a snapshot/copy of the cache state before the call.
                The object returned will be of the same type as <c>this</c> object, and can be safely
                cast.
            </summary>
            <returns>A clone of <c>this</c> object.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringRegion.ClearCaches">
            <summary>
                Clears all the cached state in <c>this</c> object.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringRegion.op_Equality(Microsoft.ProgramSynthesis.DslLibrary.StringRegion,Microsoft.ProgramSynthesis.DslLibrary.StringRegion)">
            <summary>
                Checks if <paramref name="left" /> and <paramref name="right" /> are the same region.
            </summary>
            <param name="left">The first <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringRegion" /> to compare.</param>
            <param name="right">The second <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringRegion" /> to compare.</param>
            <returns>
                True if <paramref name="left" /> and <paramref name="right" /> have the same <see cref="!:LearningCacheSubstring.S" />,
                <see cref="!:LearningCacheSubstring.Value" />, <see cref="!:LearningCacheSubstring.Start" />, and <see cref="!:LearningCacheSubstring.End" />.
            </returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.DslLibrary.StringRegion.Equals(Microsoft.ProgramSynthesis.DslLibrary.StringRegion)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringRegion.op_Inequality(Microsoft.ProgramSynthesis.DslLibrary.StringRegion,Microsoft.ProgramSynthesis.DslLibrary.StringRegion)">
            <summary>
                Checks if <paramref name="left" /> and <paramref name="right" /> are different regions.
            </summary>
            <param name="left">The first <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringRegion" /> to compare.</param>
            <param name="right">The second <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringRegion" /> to compare.</param>
            <returns>
                False if <paramref name="left" /> and <paramref name="right" /> have the same <see cref="!:LearningCacheSubstring.S" />,
                <see cref="!:LearningCacheSubstring.Value" />, <see cref="!:LearningCacheSubstring.Start" />, and <see cref="!:LearningCacheSubstring.End" />.
            </returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.DslLibrary.StringRegion.Equals(Microsoft.ProgramSynthesis.DslLibrary.StringRegion)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringRegion.CloneWithCurrentCacheState">
            <summary>
                Returns a clone of the object with a snapshot/copy of the cache state before the call.
            </summary>
            <returns>A clone of <c>this</c> object.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringRegion.ToString">
            <summary>
                Returns a string showing the <see cref="!:LearningCacheSubstring.Value" /> of this.
            </summary>
            <returns>
                A human- and machine-readable string including <see cref="!:LearningCacheSubstring.Value" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringRegion.Slice(System.UInt32,System.UInt32)">
            <summary>
                Return a sub-region of <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.SubstringInfo.Source" /> between <paramref name="start" /> and <paramref name="end" />
                .
            </summary>
            <param name="start">The starting position of the slice.</param>
            <param name="end">The ending position of the slice.</param>
            <returns>The sliced sub-region.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringRegion.Equals(System.Object)">
            <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringRegion.AbsoluteSlice(System.UInt32,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringRegion.RelativeSlice(System.UInt32,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringRegionSerializer.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
                Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringRegionSerializer.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
                Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>
                The object value.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringRegionSerializer.CanConvert(System.Type)">
            <summary>
                Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
                <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.StringToken">
            <summary>
                A <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Token" /> that matches an exact literal string.
            </summary>
            <remarks>
                <c>StringToken</c> is an <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.AbstractRegexToken" /> so code that doesn't care whether it's a
                <c>StringToken</c> can still access the <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.AbstractRegexToken.Regex" />.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.StringToken.GetMatches(System.String)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.SubstringUtils">
            <summary>
                Extension methods for providing additional functionality for <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.LearningCacheSubstring"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.SubstringUtils.StartsWith(Microsoft.ProgramSynthesis.DslLibrary.Substring,Microsoft.ProgramSynthesis.DslLibrary.Substring)">
            <summary>
                Checks if <paramref name="fullString" /> starts with <paramref name="start" />. This method does not perform
                Unicode normalization.
            </summary>
            <param name="fullString">The substring to compare.</param>
            <param name="start">The substring to look for at the beginning of <paramref name="fullString" />.</param>
            <returns>
                True if the <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Value" /> of <paramref name="fullString" /> starts with the
                <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Value" /> of <paramref name="start" />, false otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.SubstringUtils.StartsWith(Microsoft.ProgramSynthesis.DslLibrary.Substring,System.String)">
            <summary>
                Checks if <paramref name="fullString" /> starts with <paramref name="start" />. This method does not perform
                Unicode normalization.
            </summary>
            <param name="fullString">The substring to compare.</param>
            <param name="start">The substring to look for at the beginning of <paramref name="fullString" />.</param>
            <returns>
                True if the <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Value" /> of <paramref name="fullString" /> starts with the
                <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Value" /> of <paramref name="start" />, false otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.SubstringUtils.EndsWith(Microsoft.ProgramSynthesis.DslLibrary.Substring,Microsoft.ProgramSynthesis.DslLibrary.Substring)">
            <summary>
                Checks if <paramref name="fullString" /> ends with <paramref name="end" />. This method does not perform
                Unicode normalization.
            </summary>
            <param name="fullString">The substring to compare.</param>
            <param name="end">The substring to look for at the ending of <paramref name="fullString" />.</param>
            <returns>
                True if the <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Value" /> of <paramref name="fullString" /> ends with the
                <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Value" /> of <paramref name="end" />, false otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.SubstringUtils.EndsWith(Microsoft.ProgramSynthesis.DslLibrary.Substring,System.String)">
            <summary>
                Checks if <paramref name="fullString" /> ends with <paramref name="end" />. This method does not perform
                Unicode normalization.
            </summary>
            <param name="fullString">The substring to compare.</param>
            <param name="end">The substring to look for at the ending of <paramref name="fullString" />.</param>
            <returns>
                True if the <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Value" /> of <paramref name="fullString" /> ends with the
                <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Value" /> of <paramref name="end" />, false otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.SubstringUtils.PositionOf(Microsoft.ProgramSynthesis.DslLibrary.Substring,System.String,System.UInt32,System.UInt32,System.StringComparison)">
            <summary>
                Returns the position into <paramref name="substring" /> of the next match of <paramref name="needle" /> at or after
                the position <paramref name="start" /> and before <paramref name="end" />.
            </summary>
            <param name="substring">Substring to search in.</param>
            <param name="needle">String to search for.</param>
            <param name="start">
                First position to search at where <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Start" /> is the start of
                <paramref name="substring" />.
            </param>
            <param name="end">
                Position to end search at where <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.End" /> is the end of <paramref name="substring" />.
            </param>
            <param name="stringComparison">String comparison method to use.</param>
            <returns>
                The position into <paramref name="substring" /> of the next instance of <paramref name="needle" /> or
                <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if it does not occur in the bounds given.
            </returns>
            <seealso cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.SubstringUtils.PositionOf(Microsoft.ProgramSynthesis.DslLibrary.Substring,System.String,System.UInt32,System.StringComparison)">
            <summary>
                Returns the position into <paramref name="substring" /> of the next match of <paramref name="needle" /> at or after
                the position <paramref name="start" />.
            </summary>
            <param name="substring">Substring to search in.</param>
            <param name="needle">String to search for.</param>
            <param name="start">
                First position to search at where <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Start" /> is the start of
                <paramref name="substring" />.
            </param>
            <param name="stringComparison">String comparison method to use.</param>
            <returns>
                The position into <paramref name="substring" /> of the next instance of <paramref name="needle" /> or
                <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if it does not occur in the bound given.
            </returns>
            <seealso cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.SubstringUtils.PositionOf(Microsoft.ProgramSynthesis.DslLibrary.Substring,System.String,System.StringComparison)">
            <summary>
                Returns the position into <paramref name="substring" /> of the next match of <paramref name="needle" />.
            </summary>
            <param name="substring">Substring to search in.</param>
            <param name="needle">String to search for.</param>
            <param name="stringComparison">String comparison method to use.</param>
            <returns>
                The position into <paramref name="substring" /> of the next instance of <paramref name="needle" /> or
                <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if it does not occur.
            </returns>
            <seealso cref="M:System.String.IndexOf(System.String,System.StringComparison)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.SubstringUtils.PositionOf(Microsoft.ProgramSynthesis.DslLibrary.Substring,System.Char)">
            <summary>
                Returns the position into <paramref name="substring" /> of the first occurence <paramref name="c" />.
            </summary>
            <param name="substring">Substring to search in.</param>
            <param name="c">Character to search for.</param>
            <returns>
                The position into <paramref name="substring" /> of the first occurence  of <paramref name="c" /> or
                <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if it does not occur.
            </returns>
            <seealso cref="!:string.IndexOf(string,char)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.SubstringUtils.PositionOfAny(Microsoft.ProgramSynthesis.DslLibrary.Substring,System.Char[])">
            <summary>
                Returns the position into <paramref name="substring" /> of the first occurence of any character
                in <paramref name="anyOf" />.
            </summary>
            <param name="substring">Substring to search in.</param>
            <param name="anyOf">The array containing one or more characters to seek.</param>
            <returns>
                The position into <paramref name="substring" /> of the first occurence of any character in
                <paramref name="anyOf" /> or <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if it does not occur.
            </returns>
            <seealso cref="!:string.IndexOfAny(string,char[])" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.SubstringUtils.IndexOfRelative(Microsoft.ProgramSynthesis.DslLibrary.Substring,System.String,System.UInt32,System.UInt32,System.StringComparison)">
            <summary>
                Returns the index into <paramref name="substring" /> of the next match of <paramref name="needle" /> at or after
                the index <paramref name="start" /> and before <paramref name="end" />.
            </summary>
            <param name="substring">Substring to search in.</param>
            <param name="needle">String to search for.</param>
            <param name="start">First index to search at where <c>0</c> is the start of <paramref name="substring" />.</param>
            <param name="end">
                Index to end search at where <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Substring.Length" /> is the end of <paramref name="substring" />.
            </param>
            <param name="stringComparison">String comparison method to use.</param>
            <returns>
                The index into <paramref name="substring" /> of the next instance of <paramref name="needle" /> or
                <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if it does not occur in the bounds given.
            </returns>
            <seealso cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.SubstringUtils.IndexOfRelative(Microsoft.ProgramSynthesis.DslLibrary.Substring,System.String,System.UInt32,System.StringComparison)">
            <summary>
                Returns the index into <paramref name="substring" /> of the next match of <paramref name="needle" /> at or after
                the index <paramref name="start" />.
            </summary>
            <param name="substring">Substring to search in.</param>
            <param name="needle">String to search for.</param>
            <param name="start">First index to search at where <c>0</c> is the start of <paramref name="substring" />.</param>
            <param name="stringComparison">String comparison method to use.</param>
            <returns>
                The index into <paramref name="substring" /> of the next instance of <paramref name="needle" /> or
                <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if it does not occur in the bounds given.
            </returns>
            <seealso cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.SubstringUtils.LastPositionOf(Microsoft.ProgramSynthesis.DslLibrary.Substring,System.String,System.StringComparison)">
            <summary>
                Returns the position into <paramref name="substring" /> of the last match of <paramref name="needle" />.
            </summary>
            <param name="substring">Substring to search in.</param>
            <param name="needle">String to search for.</param>
            <param name="stringComparison">String comparison method to use.</param>
            <returns>
                The position into <paramref name="substring" /> of the last instance of <paramref name="needle" /> or
                <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if it does not occur in the bound given.
            </returns>
            <seealso cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.SubstringUtils.LastPositionOf(Microsoft.ProgramSynthesis.DslLibrary.Substring,System.String,System.UInt32,System.StringComparison)">
            <summary>
                Returns the position into <paramref name="substring" /> of the last match of <paramref name="needle" /> at or before
                the position <paramref name="start" />.
            </summary>
            <param name="substring">Substring to search in.</param>
            <param name="needle">String to search for.</param>
            <param name="start">    Position to search backward. </param>
            <param name="stringComparison">String comparison method to use.</param>
            <returns>
                The position into <paramref name="substring" /> of the last instance of <paramref name="needle" /> or
                <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if it does not occur in the bound given.
            </returns>
            <seealso cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.SubstringUtils.MaybeFirstChar(Microsoft.ProgramSynthesis.DslLibrary.Substring)">
            <summary>
                Returns the first <see cref="T:System.Char" /> of the substring or <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if the substring is
                empty.
            </summary>
            <param name="substring">The substring.</param>
            <returns>The beginning of the substring.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.SubstringUtils.MaybeLastChar(Microsoft.ProgramSynthesis.DslLibrary.Substring)">
            <summary>
                Returns the last <see cref="T:System.Char" /> of the substring or <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if the substring is
                empty.
            </summary>
            <param name="substring">The substring.</param>
            <returns>The end of the substring.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.SubstringUtils.MaybePreviousChar(Microsoft.ProgramSynthesis.DslLibrary.Substring)">
            <summary>
                Returns the <see cref="T:System.Char" /> immediately before the substring or <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if the
                substring is at the start of the entire string.
            </summary>
            <param name="substring">The substring.</param>
            <returns>The character before the beginning of the substring.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.SubstringUtils.MaybeNextChar(Microsoft.ProgramSynthesis.DslLibrary.Substring)">
            <summary>
                Returns the <see cref="T:System.Char" /> immediately after the substring or <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if the
                substring is at the end of the entire string.
            </summary>
            <param name="substring">The substring.</param>
            <returns>The character after the end of the substring.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.SubstringUtils.IsNullOrWhiteSpace(Microsoft.ProgramSynthesis.DslLibrary.Substring)">
            <summary>
            Returns <c>true</c> if the string is null or contains only whitespace, <c>false</c> otherwise.
            </summary>
            <param name="substring">The string.</param>
            <returns><c>true</c> if the string is null or contains only whitespace, <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.SubstringInfo">
            <summary>
                Represents a substring as a <see cref="T:System.String" /> and <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.SubstringInfo.Start" /> and <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.SubstringInfo.End" /> indexes into that
                string.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.SubstringInfo.#ctor(System.String,System.UInt32,System.UInt32)">
            <summary>
                Initializes a new instance of the <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.SubstringInfo" /> class.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.SubstringInfo.Source">
            <summary>
                The original string.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.SubstringInfo.Start">
            <summary>
                The starting position of this region in <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.SubstringInfo.Source" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.SubstringInfo.End">
            <summary>
                The ending position of this region in <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.SubstringInfo.Source" />.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.Token">
            <summary>
                A token is a sequence of characters of a particular kind.
                There are two kinds of token: static tokens (predefined) and dynamic tokens (string literal that are learned from
                the context).
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Token.Tokens">
            <summary>
                The list of tokens to learn from.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Token.TokensAscii">
            <summary>
                The list of tokens to learn from. Do not use Unicode categories in the regex.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Token.NonDisjunctiveTokens">
            <summary>
                The list of non disjunctive tokens. This list is similar to <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Token.Tokens" /> except that the
                alphabet and alphanumeric token do not contain "-" and ".".
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Token.NonDisjunctiveTokensAscii">
            <summary>
                The list of non disjunctive tokens, the version with no unicode categories.
                This list is similar to <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Token.TokensAscii" /> except that the
                alphabet and alphanumeric token do not contain "-" and ".".
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Token.MinScore">
            <summary>
                The minimum <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Token.Score" /> for a token.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Token.VariableLengthPenalty">
            <summary>
                A penalty to the log likelihood for tokens have an unknown length <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.Token.EvaluateLogLikelihood(System.String)" />.
                Ideally you would define a prior distribution over lengths.  Equivalent to an uninformative prior
                (https://en.wikipedia.org/wiki/Prior_probability#Improper_priors) -2.3 was chosen because there are
                about order ten plausible lengths, and log(1/10)~-2.3
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Token.LogDefaultStaticPrior">
            <summary>
                A log prior probability of a particular static token <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Token.LogPrior" />.
                20% static tokens, ~50 static tokens, so ln(0.2) - ln(50) ~ -5.5
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Token.LineSeparatorName">
            <summary>
                The name for the token matching the line separator (new line character or start/end of line).
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Token.DateName">
            <summary>
                The name for the token matching a date.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Token.AlphanumericName">
            <summary>
                The name for the token matching the alphanumeric.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Token.CamelCaseName">
            <summary>
                The name for the token matching the CamelCase word.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Token.LowerCaseName">
            <summary>
                The name for the token matching the lower case word.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Token.UpperCaseName">
            <summary>
                The name for the token matching the upper case word.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Token.NumberName">
            <summary>
                The name for the token matching the number.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Token.SignedNumberName">
            <summary>
                The name for the token matching the signed number.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Token.DigitsName">
            <summary>
                The name for the token matching the digits.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Token.WordDotHyphenName">
            <summary>
                The name for the token matching the word/dot/hyphen.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Token.AlphabetName">
            <summary>
                The name for the token matching the alphabet.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Token.AlphanumName">
            <summary>
                The name for the token matching the alphanumeric.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Token.PositiveIntegerName">
            <summary>
                The name for the token matching the positive integer.
            </summary>
            <summary>
                The name for the token matching the alphanumeric.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Token.DoubleQuoteName">
            <summary>
                The name for the token matching the double quote character.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Token.DynamicLogPrior">
            <summary>
                Arbitrary large penalty on using a dynamic token.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Token.DynamicLogPriorPerCharacter">
            <summary>
                Cost per character of a dynamic token: -ln(26 * 2 + 10)
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Token.#ctor(System.String,System.Int32,System.Double,System.Boolean,System.Boolean,System.String,System.Func{System.String,System.Double})">
            <summary>
                Constructor for Token class, required for derived classes
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Token.AllDslsTokens">
            <summary>
                The list of tokens from all DSLs used for parsing.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Token.RegisterTokens(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,Microsoft.ProgramSynthesis.DslLibrary.Token}})">
            <summary>
                Registers the DSLs' tokens for parsing.
            </summary>
            <param name="tokens">The tokens to register.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Token.Name">
            <summary>
                Human-readable description of what this token matches. For dynamic tokens, this should just be the string it
                matches enclosed in double quotes (").
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Token.GetMatches(System.String)">
            <summary>
                Returns IEnumerable of <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.PositionMatch" /> that are compared against while adding a new token in the <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache" />
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Token.CanonicalRepresentation">
            <summary>
                A canonical string that matches this token, or null if one does not exist.
                For example, the canonical representation of the whitespace token is " ",
                while the canonical representation of Alphanumeric is null.
                You can think of this as a default string for this token;
                tokens like FirstName and Digits don't have a default,
                but tokens like Percent have the canonical representation "%", etc.
                For <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegexToken" />s, we enforce that the <see cref="T:System.Text.RegularExpressions.Regex" /> matches CanonicalRepresentation.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Token.Score">
            <summary>
                The ranking score of the token. The higher the better.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Token.LogPrior">
            <summary>
                The log prior probability of the token, which is in (-\infty, 0).
                Higher values (closer to zero) indicate more common tokens.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Token.EvaluateLogLikelihood(System.String)">
            <summary>
                The log likelihood of a string given the token, which is in (-\infty, 0].
                The higher (closer to zero) the more representative the string is of the token.
                The likelihood calculation assumes that the string matches the regular expression.
            </summary>
            <param name="x">The candidate string.</param>
            <returns>\log P(x|this)</returns>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.Token._evaluateLogLikelihood">
            <summary>
                Callback function that evaluates the log likelihood of the string given this token.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Token.UseForLearning">
            <summary>
                If true, this token may be part of learned <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.RegularExpression" />s. Otherwise, it exists just for
                <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.StringLearningCache" /> to cache matches of it.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Token.IsSymbol">
            <summary>
                Does this match one or more symbols (as opposed to alphanumeric characters)?
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.Token.IsDynamicToken">
            <summary>
                Was this token learned (as opposed to appearing in a hard-coded list of static tokens)?
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Token.FromRegex(System.Text.RegularExpressions.Regex,System.Int32)">
            <summary>
                Builds a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Token" /> from a <see cref="T:System.Text.RegularExpressions.Regex" /> so no explicit name is required.
            </summary>
            <param name="regex">
                The <see cref="T:System.Text.RegularExpressions.Regex" /> the token will wrap. Should be compiled (
                <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />).
            </param>
            <param name="score">
                The score of this token used to determine how good programs are that use it. Tokens with higher
                scores are preferred. Static token scores should not be below <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.Token.MinScore" />.
            </param>
            <returns>A <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Token" /> which matches <paramref name="regex" /> and has score <paramref name="score" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Token.Clone">
            <summary>
            Returns a cloned object of the token.
            </summary>
            <returns>The cloned token.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Token.op_Equality(Microsoft.ProgramSynthesis.DslLibrary.Token,Microsoft.ProgramSynthesis.DslLibrary.Token)">
            <summary>
                Checks if <paramref name="left" /> and <paramref name="right" /> are equivalent tokens.
            </summary>
            <param name="left">The first token to check.</param>
            <param name="right">The second token to check.</param>
            <returns>True if <paramref name="left" /> and <paramref name="right" /> have the same <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Token.Name" />.</returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.DslLibrary.Token.Equals(Microsoft.ProgramSynthesis.DslLibrary.Token)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Token.op_Inequality(Microsoft.ProgramSynthesis.DslLibrary.Token,Microsoft.ProgramSynthesis.DslLibrary.Token)">
            <summary>
                Checks if <paramref name="left" /> and <paramref name="right" /> are different tokens.
            </summary>
            <param name="left">The first token to check.</param>
            <param name="right">The second token to check.</param>
            <returns>False if <paramref name="left" /> and <paramref name="right" /> have the same <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Token.Name" />.</returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.DslLibrary.Token.Equals(Microsoft.ProgramSynthesis.DslLibrary.Token)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Token.Equals(Microsoft.ProgramSynthesis.DslLibrary.Token)">
            <summary>
                Indicates whether the current <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Token" /> is equal to another <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Token" />.
            </summary>
            <returns>
                true if the current <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Token" /> has the same <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.Token.Name" /> as the <paramref name="other" />
                parameter; otherwise, false.
            </returns>
            <param name="other">A <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Token" /> to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Token.Equals(System.Object)">
            <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Token.GetHashCode">
            <summary>
                Serves as the default hash function.
            </summary>
            <returns>
                A hash code for the current object.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.Token.ToString">
            <summary>
                Returns a human-readable string describing this token.
            </summary>
            <returns>
                A string that describes this token.
            </returns>
            <seealso cref="P:Microsoft.ProgramSynthesis.DslLibrary.Token.Name" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.PositionMatch">
            <summary>
                A position match contains a matching position and a matching length (of a match of tokens or regular expressions).
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.PositionMatch.Position">
            <summary>
                The starting index of the match.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.PositionMatch.Length">
            <summary>
                The string length of the match.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.PositionMatch.Right">
            <summary>
                The ending index of the match (exclusive).
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.PositionMatch.#ctor(System.UInt32,System.UInt32)">
            <summary>
                Constructs a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.PositionMatch" />.
            </summary>
            <param name="position">The starting index of the match.</param>
            <param name="length">The string length of the match.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.PositionMatch.From(System.Text.RegularExpressions.Match)">
            <summary>
                Converts a sucessful <see cref="T:System.Text.RegularExpressions.Match" /> into a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.PositionMatch" /> corresponding to the entire matched
                string.
            </summary>
            <param name="match">
                A match result from a regular expression match. Only the <see cref="P:System.Text.RegularExpressions.Group.Success" />,
                <see cref="P:System.Text.RegularExpressions.Capture.Index" />, and <see cref="P:System.Text.RegularExpressions.Capture.Length" /> properties are read. The
                <see cref="P:System.Text.RegularExpressions.Match.Groups" /> and all other properties are ignored.
            </param>
            <returns>
                <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if <paramref name="match" /> is not a successful match, otherwise
                <c>Some</c> of a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.PositionMatch" /> with the same position and length.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.DslLibrary.TokenMatch">
            <summary>
                A token match is a token and the string length of the match from a regular expression matching operation.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.DslLibrary.TokenMatch.Token">
            <summary>
                The token matched.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.DslLibrary.TokenMatch.Length">
            <summary>
                The string length of the match.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.TokenMatch.#ctor(Microsoft.ProgramSynthesis.DslLibrary.Token,System.UInt32)">
            <summary>
                Constructs a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.TokenMatch" />/
            </summary>
            <param name="t">The <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.TokenMatch.Token" /> matched.</param>
            <param name="l">The string length of the match.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.TokenMatch.Equals(Microsoft.ProgramSynthesis.DslLibrary.TokenMatch)">
            <summary>
                Indicates whether the current match is equal to another match.
            </summary>
            <returns>
                true if the current token has the same <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.TokenMatch.Token" /> and <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.TokenMatch.Length" /> as the
                <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">A <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.TokenMatch" /> to compare with this.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.TokenMatch.Equals(System.Object)">
            <summary>
                Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
                true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current instance. </param>
            <see cref="M:Microsoft.ProgramSynthesis.DslLibrary.TokenMatch.Equals(Microsoft.ProgramSynthesis.DslLibrary.TokenMatch)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.TokenMatch.GetHashCode">
            <summary>
                Returns the hash code for this instance.
            </summary>
            <returns>
                A 32-bit signed integer that is the hash code for this instance.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.TokenMatch.op_Equality(Microsoft.ProgramSynthesis.DslLibrary.TokenMatch,Microsoft.ProgramSynthesis.DslLibrary.TokenMatch)">
            <summary>
                Checks if <paramref name="left" /> and <paramref name="right" /> are equivalent.
            </summary>
            <param name="left">The first <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.TokenMatch" /> to compare.</param>
            <param name="right">The second <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.TokenMatch" /> to compare.</param>
            <returns>
                True if <paramref name="left" /> and <paramref name="right" /> have the same <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.TokenMatch.Token" /> and
                <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.TokenMatch.Length" />.
            </returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.DslLibrary.TokenMatch.Equals(Microsoft.ProgramSynthesis.DslLibrary.TokenMatch)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.DslLibrary.TokenMatch.op_Inequality(Microsoft.ProgramSynthesis.DslLibrary.TokenMatch,Microsoft.ProgramSynthesis.DslLibrary.TokenMatch)">
            <summary>
                Checks if <paramref name="left" /> and <paramref name="right" /> are different.
            </summary>
            <param name="left">The first <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.TokenMatch" /> to compare.</param>
            <param name="right">The second <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.TokenMatch" /> to compare.</param>
            <returns>
                False if <paramref name="left" /> and <paramref name="right" /> have the same <see cref="P:Microsoft.ProgramSynthesis.DslLibrary.TokenMatch.Token" /> and
                <see cref="F:Microsoft.ProgramSynthesis.DslLibrary.TokenMatch.Length" />.
            </returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.DslLibrary.TokenMatch.Equals(Microsoft.ProgramSynthesis.DslLibrary.TokenMatch)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Extensions.ConversionRulesTo(Microsoft.ProgramSynthesis.Symbol,Microsoft.ProgramSynthesis.Symbol)">
            <summary>
                Finds a list of conversion rules to convert <paramref name="original" /> to <paramref name="target" />.
            </summary>
            <param name="original">The original symbol.</param>
            <param name="target">The target symbol.</param>
            <returns>
                The rules to convert <paramref name="original" /> to <paramref name="target" />
                or an empty list if no such rules exist or <paramref name="original" /> is already
                a <paramref name="target"/>.
            </returns>
            <remarks>If multiple paths exist, this returns an arbitrary one of shortest length.</remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.NumberExtensions.Truncate(System.Double,System.Int32)">
            <summary>
                Truncate the digits to the right of the decimal point (scale) without rounding.
            </summary>
            <param name="subject"></param>
            <param name="scale">digits to the right of the decimal point</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.NumberExtensions.Truncate(System.Decimal,System.Int32)">
            <summary>
                Truncate the digits to the right of the decimal point (scale) without rounding.
            </summary>
            <param name="subject"></param>
            <param name="scale">digits to the right of the decimal point</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.IFeature.GetFeatureValueForVariable(Microsoft.ProgramSynthesis.AST.VariableNode)">
            <summary>
                Calculates the value of the feature represented by the current instance
                for a given <see cref="T:Microsoft.ProgramSynthesis.AST.VariableNode" /> program <paramref name="variable" />.
            </summary>
            <param name="variable"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.IFeature.Calculate(Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.Features.LearningInfo)">
            <summary>
                Calculates the value of this feature for <paramref name="program" /> possibly using the additional information in
                <paramref name="learningInfo" />. This method is responsible for calling
                <see cref="M:Microsoft.ProgramSynthesis.Features.LearningInfoUtils.WithProgramNode(Microsoft.ProgramSynthesis.Features.FeatureCalculationContext,Microsoft.ProgramSynthesis.AST.ProgramNode)" /> on its
                <paramref name="learningInfo" /> argument with <paramref name="program" />.
            </summary>
            <param name="program"><see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> to compute feature value on.</param>
            <param name="learningInfo">Optional additional <see cref="T:Microsoft.ProgramSynthesis.Features.LearningInfo" /> the feature calculator may use.</param>
            <returns>The value of this feature for <paramref name="program" />.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.IFeature.UseComputedInputsForFccEquality">
            <summary>
                If <c>true</c> then the actual inputs will be computed and used to compare for equality
                of <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext"/> objects. Otherwise, the default behavior is to
                use a heuristic equality comparison that does not actually compute the inputs in the
                <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext"/> objects. This heuristic equality could result in
                false negatives, i.e., <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext"/> objects that are equal might
                be compared as unequal. The heuristic equality, however, is faster. In some circumstances,
                it might be better to perform equality checks accurately: when the increased rate of
                hits on the internal caches maintained by the PROSE framework overcomes the performance
                overhead of additional computation performed during equality checks.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.Feature`1.UseComputedInputsForFccEquality">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.Feature`1.GetFeatureValueForVariable(Microsoft.ProgramSynthesis.AST.VariableNode)">
            <summary>
                Calculates the value of the feature represented by the current instance
                for a given <see cref="T:Microsoft.ProgramSynthesis.AST.VariableNode" /> program <paramref name="variable" />.
            </summary>
            <param name="variable"></param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Features.Feature`1.FeatureInfoResolution.Declared">
            <summary>
                Consider only features that are defined in the language grammar.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Features.Feature`1.FeatureInfoResolution.CreateIfMissing">
            <summary>
                Find a feature with the given name in the language grammar. If missing, create a new
                <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureInfo" /> from the provided parameters.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Features.Feature`1.FeatureInfoResolution.AlwaysCreate">
            <summary>
                Create a new <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureInfo" /> from the provided parameters, ignoring the language grammar.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext">
            <summary>
                Represents all information necessary to perform calculation for an <see cref="T:Microsoft.ProgramSynthesis.Features.IFeature" />.
                This includes <see cref="P:Microsoft.ProgramSynthesis.Specifications.Spec.ProvidedInputs" />, the additional inputs from the learning task,
                as well as a set of options for feature calculators encapsulated within an <see cref="T:Microsoft.ProgramSynthesis.Features.IFeatureOptions" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.ReferenceSpecInputs">
            <summary>
                The input values for a <see cref="T:Microsoft.ProgramSynthesis.Specifications.Spec" /> before any necessary transformation has been applied.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.ReferenceAdditionalInputs">
            <summary>
                The additional input values for a <see cref="T:Microsoft.ProgramSynthesis.Specifications.Spec" /> before any necessary transformation has
                been applied.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.Options">
            <summary>
                The options that control the behavior of feature calculators.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.ComputeSpecInputs">
            <summary>
                Inputs that appear in the specification (usually examples) in <see cref="P:Microsoft.ProgramSynthesis.Specifications.Spec.ProvidedInputs" />.
                This does not materialize (see <see cref="M:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.MaterializeSpecInputs" /> the values.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.MaterializeSpecInputs">
            <summary>
                Inputs that appear in the specification (usually examples) in <see cref="P:Microsoft.ProgramSynthesis.Specifications.Spec.ProvidedInputs" />.
                After calling <see cref="M:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.MaterializeSpecInputs" />, any <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext" /> derived
                from this context will use the materialized values as the reference ones.  This can affect hashing
                and equality because different (original) reference state and transformations can evaluate to the
                same values.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.AdditionalInputs">
            <summary>
                Additional inputs for which no specification is given (note these are not guaranteed to be distinct from
                the elements in <see cref="M:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.MaterializeSpecInputs" />).
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.AllInputs">
            <summary>
                All known inputs; the concatenation of distinct values from <see cref="M:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.MaterializeSpecInputs" /> and
                <see cref="P:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.AdditionalInputs" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.Create(System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.State},System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.State},Microsoft.ProgramSynthesis.Features.IFeatureOptions)">
            <summary>
                Creates a new <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext" />.
            </summary>
            <param name="specInputs">The <see cref="P:Microsoft.ProgramSynthesis.Specifications.Spec.ProvidedInputs" />.</param>
            <param name="additionalInputs">The additional inputs from the learning task.</param>
            <param name="options">A set of options for the feature calculators.</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.Empty">
            <summary>
                A <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext" /> with no states and <c>null</c> <see cref="P:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.Options" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.AllInputsCount">
            <summary>
                The sum of counts of <see cref="M:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.MaterializeSpecInputs" /> and <see cref="P:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.AdditionalInputs" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.TransformForChild(Microsoft.ProgramSynthesis.AST.ProgramNode,System.Int32)">
            <summary>
                Computes a new <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext" /> for the child at index <paramref name="childIndex" /> of
                <paramref name="program" />, assuming that <c>this</c> is valid for <paramref name="program" />.
            </summary>
            <param name="program">The program.</param>
            <param name="childIndex">The index of child.</param>
            <returns>
                A <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext" /> that is valid for the child at <paramref name="childIndex" /> of
                <paramref name="program" />, provided <c>this</c> is valid for <paramref name="program" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.Equals(Microsoft.ProgramSynthesis.Features.FeatureCalculationContext)">
            <summary>Indicates whether the current object is equal to another object of the same type.</summary>
            <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
            <returns>true if the specified object  is equal to the current object; otherwise, false.</returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.GetHashCode">
            <summary>Serves as the default hash function. </summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.GetInputs(Microsoft.ProgramSynthesis.Features.InputKind)">
            <summary>
                Returns the inputs of the specified <paramref name="kind" />.
            </summary>
            <param name="kind">The <see cref="T:Microsoft.ProgramSynthesis.Features.InputKind" /> to select.</param>
            <returns>The specification, additional, or all inputs depending on <paramref name="kind" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.ComputedInputsEqualityComparer.Equals(Microsoft.ProgramSynthesis.Features.FeatureCalculationContext,Microsoft.ProgramSynthesis.Features.FeatureCalculationContext)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.ComputedInputsEqualityComparer.GetHashCode(Microsoft.ProgramSynthesis.Features.FeatureCalculationContext)">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.EqualityComparerOnComputedInputs">
            <summary>
                An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> that compares <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext"/>s
                after materializing the inputs. This approach is sound, as opposed to the default equality
                comparison, which performs a heuristic equality comparison. The heuristic equality comparison
                is unsound and may result in false-negatives (but no false positives).
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Features.InputKind">
            <summary>
                Identifies the three sets of inputs.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Features.InputKind.Spec">
            <summary>
                Inputs that appear in the specification (usually examples) in <see cref="P:Microsoft.ProgramSynthesis.Specifications.Spec.ProvidedInputs" />.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Features.InputKind.Additional">
            <summary>
                Additional inputs for which no specification is given (note these are not guaranteed to be distinct from
                <see cref="F:Microsoft.ProgramSynthesis.Features.InputKind.Spec" />).
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Features.InputKind.All">
            <summary>
                All known inputs; the concatenation of distinct values from
                <see cref="M:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.MaterializeSpecInputs" /> and
                <see cref="P:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext.AdditionalInputs" />.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Features.FeatureCalculationContextEx">
            <summary>
                Additional helper and extension methods related to <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.FeatureCalculationContextEx.GetFccEqualityComparer(Microsoft.ProgramSynthesis.Features.IFeature)">
            <summary>
                Returns an <see cref="T:System.Collections.Generic.EqualityComparer`1"/> for <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext"/> objects,
                based on whether the <see cref="T:Microsoft.ProgramSynthesis.Features.IFeature"/> in question expects to use computed inputs.
            </summary>
            <param name="feature"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Features.FeatureCalculationContextInputs">
             <summary>
                 This class provides an abstraction for two input context types that are shared across
                 <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext"/>s:
                 1) An already computed list of inputs (<see cref="T:Microsoft.ProgramSynthesis.Features.ReferenceFeatureCalculationContextInputs"/>).
                 2) A list of inputs that is computed by applying a transformation to another list of inputs
                     (<see cref="T:Microsoft.ProgramSynthesis.Features.TransformedFeatureCalculationContextInputs"/>).
            
                 Transformations can be chained.  The transformation calculations are lazily applied.
             </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.FeatureCalculationContextInputs.ReferenceSpecInputs">
            <summary>
                The input values for a <see cref="!:Spec" /> before <see cref="N:Microsoft.ProgramSynthesis.Features.InputTransformation"/> has
                been applied.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.FeatureCalculationContextInputs.ReferenceAdditionalInputs">
            <summary>
                The additional input values for a  <see cref="!:Spec" /> before <see cref="N:Microsoft.ProgramSynthesis.Features.InputTransformation"/> has
                been applied.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.FeatureCalculationContextInputs.ComputeSpecInputs">
            <summary>
                Calculate, but do not materialize, the transformed inputs values for this context.
                New contexts that are derived from this one will continue to be generated with the same
                <see cref="P:Microsoft.ProgramSynthesis.Features.FeatureCalculationContextInputs.ReferenceSpecInputs"/> until <see cref="M:Microsoft.ProgramSynthesis.Features.FeatureCalculationContextInputs.MaterializeSpecInputs"/> is called.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.FeatureCalculationContextInputs.MaterializeSpecInputs">
            <summary>
                Calculate and materialize the transformed inputs values for this context.
                After <see cref="M:Microsoft.ProgramSynthesis.Features.FeatureCalculationContextInputs.MaterializeSpecInputs"/> is called, new contexts that are derived
                from this one will use the transformed input values as their
                <see cref="P:Microsoft.ProgramSynthesis.Features.FeatureCalculationContextInputs.ReferenceSpecInputs"/> until <see cref="M:Microsoft.ProgramSynthesis.Features.FeatureCalculationContextInputs.MaterializeSpecInputs"/> is called.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.FeatureCalculationContextInputs.GetBaseContextInputsForTransform">
            <summary>
                Returns the context that should be used as the reference values for a new,
                transformed context.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.FeatureCalculationContextInputs.ComputeHashCode">
            <summary>
                Perform the actual calculation to determine the hash code.  <see cref="M:Microsoft.ProgramSynthesis.Features.FeatureCalculationContextInputs.GetHashCode"/>
                is responsible for caching the value.
            </summary>
            <returns>The hash value.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.FeatureInfo.IsComplete">
            <summary>
            Complete features must be defined on the entire grammar.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Features.FeatureMissingException">
            <summary>
            Thrown when attempting to lookup a feature that is not defined in a given <see cref="P:Microsoft.ProgramSynthesis.Features.FeatureMissingException.Grammar"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Features.FeatureUndefinedException">
            <summary>
                Thrown when attempting to calculate a feature on a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" />
                for which that feature is undefined.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Features.FeatureOptions">
            <summary>
                A convenience class that provides default implementations for an <see cref="T:Microsoft.ProgramSynthesis.Features.IFeatureOptions" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.FeatureOptions.Substitutions">
            <summary>
                All the substitutions that are in effect.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.FeatureOptions.Equals(Microsoft.ProgramSynthesis.Features.IFeatureOptions)">
            <summary>Indicates whether the current object is equal to another object of the same type.</summary>
            <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.FeatureOptions.Equals(Microsoft.ProgramSynthesis.Features.FeatureOptions)">
            <summary>Indicates whether the current object is equal to another object of the same type.</summary>
            <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.FeatureOptions.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
            <returns>true if the specified object  is equal to the current object; otherwise, false.</returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.FeatureOptions.GetHashCode">
            <summary>Serves as the default hash function. </summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.FeatureOptions.ToString">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.FeatureOptions.GetSubstitutionFor(Microsoft.ProgramSynthesis.Symbol)">
            <summary>
                Retrieve the substitution for <paramref name="symbol" />.
            </summary>
            <param name="symbol">The grammar symbol whose substitution is sought.</param>
            <returns>A symbol that represents the substitution, if one exists, the input <paramref name="symbol" /> otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.FeatureOptions.CloneWithNewSubstitutions(System.Collections.Generic.IReadOnlyDictionary{Microsoft.ProgramSynthesis.Symbol,Microsoft.ProgramSynthesis.Symbol})">
            <summary>
                Returns an <see cref="T:Microsoft.ProgramSynthesis.Features.IFeatureOptions" /> objects that is a clone of <c>this</c> object, except
                that <see cref="P:Microsoft.ProgramSynthesis.Features.IFeatureOptions.Substitutions" /> will be replaced by <paramref name="newSubstitutions" />.
            </summary>
            <param name="newSubstitutions">The new substitution map.</param>
            <returns>See summary.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.FeatureOptions.WithAddedSubstitutions(System.Collections.Generic.IReadOnlyDictionary{Microsoft.ProgramSynthesis.Symbol,Microsoft.ProgramSynthesis.Symbol})">
            <summary>
                Returns an <see cref="T:Microsoft.ProgramSynthesis.Features.IFeatureOptions" /> objects that is a clone of <c>this</c> object, except
                that <see cref="P:Microsoft.ProgramSynthesis.Features.IFeatureOptions.Substitutions" /> will be augmented with
                <paramref name="additionalSubstitutions" />.
            </summary>
            <param name="additionalSubstitutions">The additional substitution map.</param>
            <returns>See summary.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.FeatureOptions.Clone">
            <summary>
                Clones this object.
            </summary>
            <returns>A clone of this object.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Features.IFeatureOptions">
            <summary>
                An interface for passing options down to feature calculators in an <see cref="T:Microsoft.ProgramSynthesis.Features.IFeature" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.IFeatureOptions.GetSubstitutionFor(Microsoft.ProgramSynthesis.Symbol)">
            <summary>
                Retrieve the substitution for <paramref name="symbol" />.
            </summary>
            <param name="symbol">The grammar symbol whose substitution is sought.</param>
            <returns>A symbol that represents the substitution, if one exists, the input <paramref name="symbol" /> otherwise.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.IFeatureOptions.Substitutions">
            <summary>
                All the substitutions that are in effect.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.IFeatureOptions.CloneWithNewSubstitutions(System.Collections.Generic.IReadOnlyDictionary{Microsoft.ProgramSynthesis.Symbol,Microsoft.ProgramSynthesis.Symbol})">
            <summary>
                Returns an <see cref="T:Microsoft.ProgramSynthesis.Features.IFeatureOptions"/> objects that is a clone of <c>this</c> object, except
                that <see cref="P:Microsoft.ProgramSynthesis.Features.IFeatureOptions.Substitutions"/> will be replaced by <paramref name="newSubstitutions"/>.
            </summary>
            <param name="newSubstitutions">The new substitution map.</param>
            <returns>See summary.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.IFeatureOptions.WithAddedSubstitutions(System.Collections.Generic.IReadOnlyDictionary{Microsoft.ProgramSynthesis.Symbol,Microsoft.ProgramSynthesis.Symbol})">
            <summary>
                Returns an <see cref="T:Microsoft.ProgramSynthesis.Features.IFeatureOptions"/> objects that is a clone of <c>this</c> object, except
                that <see cref="P:Microsoft.ProgramSynthesis.Features.IFeatureOptions.Substitutions"/> will be augmented with <paramref name="additionalSubstitutions"/>.
            </summary>
            <param name="additionalSubstitutions">The additional substitution map.</param>
            <returns>See summary.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer">
            <summary>
                An interface for input transformers.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer.Transform(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.State})">
            <summary>
                Transforms the provided inputs.
            </summary>
            <param name="inputs">A sequence of <see cref="T:Microsoft.ProgramSynthesis.State" />s.</param>
            <returns>A sequence of states resulting from the transformation of <paramref name="inputs" />.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Features.InputTransformation.LambdaBodyInputTransformer">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer" /> that transforms <see cref="T:Microsoft.ProgramSynthesis.State" />s applicable to a <see cref="T:Microsoft.ProgramSynthesis.Rules.LambdaRule" />
                or <see cref="T:Microsoft.ProgramSynthesis.AST.LambdaNode" /> to <see cref="T:Microsoft.ProgramSynthesis.State" />s that are applicable to the body of the
                <see cref="T:Microsoft.ProgramSynthesis.Rules.LambdaRule" /> or <see cref="T:Microsoft.ProgramSynthesis.AST.LambdaNode" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.InputTransformation.LambdaBodyInputTransformer.LambdaVariable">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.Rules.LambdaRule" /> associated with this transform.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.InputTransformation.LambdaBodyInputTransformer.#ctor(Microsoft.ProgramSynthesis.Symbol)">
            <summary>
                Constructor.
            </summary>
            <param name="lambdaVariable">The variable from the <see cref="T:Microsoft.ProgramSynthesis.Rules.LambdaRule" />.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.InputTransformation.LambdaBodyInputTransformer.Equals(Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.InputTransformation.LambdaBodyInputTransformer.Equals(Microsoft.ProgramSynthesis.Features.InputTransformation.LambdaBodyInputTransformer)">
            <summary>
                Checks if <c>this</c> and <paramref name="other" /> are equal.
            </summary>
            <param name="other">The other <see cref="T:Microsoft.ProgramSynthesis.Features.InputTransformation.LambdaBodyInputTransformer" />.</param>
            <returns><c>true</c> if <c>this</c> is equal to <paramref name="other" />, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.InputTransformation.LambdaBodyInputTransformer.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.InputTransformation.LambdaBodyInputTransformer.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.InputTransformation.LambdaBodyInputTransformer.Transform(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.State})">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Features.InputTransformation.LetBodyInputTransformer">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer" /> that transforms <see cref="T:Microsoft.ProgramSynthesis.State" />s that are applicable to a
                <see cref="P:Microsoft.ProgramSynthesis.Features.InputTransformation.LetBodyInputTransformer.LetRule" /> or <see cref="T:Microsoft.ProgramSynthesis.AST.LetNode" /> to <see cref="T:Microsoft.ProgramSynthesis.State" />s that are applicable for the body of the
                <see cref="T:Microsoft.ProgramSynthesis.AST.LetNode" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.InputTransformation.LetBodyInputTransformer.BindingProgram">
            <summary>
                The program that generates the  value that is to be bound to the variable of <see cref="P:Microsoft.ProgramSynthesis.Features.InputTransformation.LetBodyInputTransformer.LetRule" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.InputTransformation.LetBodyInputTransformer.LetRule">
            <summary>
                The <see cref="P:Microsoft.ProgramSynthesis.Features.InputTransformation.LetBodyInputTransformer.LetRule" /> associated with this transform.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.InputTransformation.LetBodyInputTransformer.#ctor(Microsoft.ProgramSynthesis.Rules.LetRule,Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Constructor.
            </summary>
            <param name="letRule">The <see cref="P:Microsoft.ProgramSynthesis.Features.InputTransformation.LetBodyInputTransformer.LetRule" />.</param>
            <param name="bindingProgram">The <see cref="P:Microsoft.ProgramSynthesis.Features.InputTransformation.LetBodyInputTransformer.BindingProgram" />.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.InputTransformation.LetBodyInputTransformer.Equals(Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.InputTransformation.LetBodyInputTransformer.Equals(Microsoft.ProgramSynthesis.Features.InputTransformation.LetBodyInputTransformer)">
            <summary>
                Checks if <c>this</c> and <paramref name="other" /> are equal.
            </summary>
            <param name="other">The other <see cref="T:Microsoft.ProgramSynthesis.Features.InputTransformation.LambdaBodyInputTransformer" />.</param>
            <returns><c>true</c> if <c>this</c> is equal to <paramref name="other" />, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.InputTransformation.LetBodyInputTransformer.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.InputTransformation.LetBodyInputTransformer.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.InputTransformation.LetBodyInputTransformer.Transform(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.State})">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Features.InputTransformation.SequenceTransformConceptLambdaInputTransformer">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer" /> that transforms <see cref="T:Microsoft.ProgramSynthesis.State" />s that are applicable to a
                <see cref="T:Microsoft.ProgramSynthesis.Rules.Concepts.ConceptRule" /> --- which is a sequence transformer, i.e., the <see cref="T:Microsoft.ProgramSynthesis.Rules.Concepts.ConceptRule" /> takes a
                sequence of values and returns a transformed (filtered, mapped, etc) sequence of values --- and transforms it into
                a sequence of <see cref="T:Microsoft.ProgramSynthesis.State" />s that are applicable to the transformation program (usually represented as a
                <see cref="T:Microsoft.ProgramSynthesis.AST.LambdaNode" /> or <see cref="T:Microsoft.ProgramSynthesis.Rules.LambdaRule" />) in the <see cref="T:Microsoft.ProgramSynthesis.Rules.Concepts.ConceptRule" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.InputTransformation.SequenceTransformConceptLambdaInputTransformer.SequenceGenerator">
            <summary>
                The subprogram of the <see cref="T:Microsoft.ProgramSynthesis.Rules.Concepts.ConceptRule"/> program that generates a sequence of values.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.InputTransformation.SequenceTransformConceptLambdaInputTransformer.SymbolToBindSequenceElementsTo">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.Symbol" /> to bind each of the values generated by <see cref="P:Microsoft.ProgramSynthesis.Features.InputTransformation.SequenceTransformConceptLambdaInputTransformer.SequenceGenerator" /> to. If
                <c>null</c>, then
                each of the generated values will result in a state with the value bound to <see cref="P:Microsoft.ProgramSynthesis.State.FunctionalInput" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.InputTransformation.SequenceTransformConceptLambdaInputTransformer.#ctor(Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.Symbol)">
            <summary>
                Constructor.
            </summary>
            <param name="sequenceGenerator">See <see cref="P:Microsoft.ProgramSynthesis.Features.InputTransformation.SequenceTransformConceptLambdaInputTransformer.SequenceGenerator"/>.</param>
            <param name="symbolToBindSequenceElementsTo">See <see cref="P:Microsoft.ProgramSynthesis.Features.InputTransformation.SequenceTransformConceptLambdaInputTransformer.SymbolToBindSequenceElementsTo"/>.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.InputTransformation.SequenceTransformConceptLambdaInputTransformer.Equals(Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.InputTransformation.SequenceTransformConceptLambdaInputTransformer.Equals(Microsoft.ProgramSynthesis.Features.InputTransformation.SequenceTransformConceptLambdaInputTransformer)">
            <summary>
                Checks if <c>this</c> and <paramref name="other" /> are equal.
            </summary>
            <param name="other">The other <see cref="T:Microsoft.ProgramSynthesis.Features.InputTransformation.LambdaBodyInputTransformer" />.</param>
            <returns><c>true</c> if <c>this</c> is equal to <paramref name="other" />, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.InputTransformation.SequenceTransformConceptLambdaInputTransformer.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.InputTransformation.SequenceTransformConceptLambdaInputTransformer.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.InputTransformation.SequenceTransformConceptLambdaInputTransformer.Transform(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.State})">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Features.InputTransformation.SubstitutionInputTransformer">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer" /> that performs variable substitution.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.InputTransformation.SubstitutionInputTransformer.OldSymbol">
            <summary>
                The symbol that will be replaced.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.InputTransformation.SubstitutionInputTransformer.NewSymbol">
            <summary>
                The symbol that will replace all occurences of <see cref="P:Microsoft.ProgramSynthesis.Features.InputTransformation.SubstitutionInputTransformer.OldSymbol"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.InputTransformation.SubstitutionInputTransformer.#ctor(Microsoft.ProgramSynthesis.Symbol,Microsoft.ProgramSynthesis.Symbol)">
            <summary>
                Constructor.
            </summary>
            <param name="oldSymbol">See <see cref="P:Microsoft.ProgramSynthesis.Features.InputTransformation.SubstitutionInputTransformer.OldSymbol"/>.</param>
            <param name="newSymbol">See <see cref="P:Microsoft.ProgramSynthesis.Features.InputTransformation.SubstitutionInputTransformer.NewSymbol"/>.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.InputTransformation.SubstitutionInputTransformer.Equals(Microsoft.ProgramSynthesis.Features.InputTransformation.SubstitutionInputTransformer)">
            <summary>
                Returns <c>true</c> iff <c>this</c> is equal to <paramref name="other" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.InputTransformation.SubstitutionInputTransformer.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.InputTransformation.SubstitutionInputTransformer.Equals(Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.InputTransformation.SubstitutionInputTransformer.Transform(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.State})">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Features.LearningInfo">
            <summary>
                Information about the learning session to be given to a <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureCalculator" /> that requests it. This
                wraps a <see cref="P:Microsoft.ProgramSynthesis.Features.LearningInfo.FeatureCalculationContext" /> and the <see cref="P:Microsoft.ProgramSynthesis.Features.LearningInfo.ProgramNode" /> whose feature is being
                computed, so the
                <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureCalculator" /> may invoke the program on the inputs.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.LearningInfo.ProgramNode">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> whose feature is currently being computed.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.LearningInfo.FeatureCalculationContext">
            <summary>
                The FeatureCalculationContext associated with this <see cref="T:Microsoft.ProgramSynthesis.Features.LearningInfo" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.LearningInfo.Options">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.Features.IFeatureOptions" /> that are part of the <see cref="P:Microsoft.ProgramSynthesis.Features.LearningInfo.FeatureCalculationContext" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.LearningInfo.SpecInputs">
            <summary>
                The spec inputs that are part of the <see cref="P:Microsoft.ProgramSynthesis.Features.LearningInfo.FeatureCalculationContext" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.LearningInfo.AdditionalInputs">
            <summary>
                The additional inputs that are part of the <see cref="P:Microsoft.ProgramSynthesis.Features.LearningInfo.FeatureCalculationContext" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.LearningInfo.AllInputs">
            <summary>
                All inputs that are part of the <see cref="P:Microsoft.ProgramSynthesis.Features.LearningInfo.FeatureCalculationContext" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.LearningInfo.GetOutputs(Microsoft.ProgramSynthesis.Features.InputKind)">
            <summary>
                Runs <see cref="P:Microsoft.ProgramSynthesis.Features.LearningInfo.ProgramNode" /> on the <paramref name="kind" /> inputs.
            </summary>
            <param name="kind">
                Which <see cref="T:Microsoft.ProgramSynthesis.Features.InputKind" /> of inputs to run
                <see cref="P:Microsoft.ProgramSynthesis.Features.LearningInfo.ProgramNode" /> on.
            </param>
            <returns>The outputs of <see cref="P:Microsoft.ProgramSynthesis.Features.LearningInfo.ProgramNode" /> on the <paramref name="kind" /> inputs.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.LearningInfo.GetInputOutputPairs(Microsoft.ProgramSynthesis.Features.InputKind)">
            <summary>
                Runs <see cref="P:Microsoft.ProgramSynthesis.Features.LearningInfo.ProgramNode" /> on the <paramref name="kind" /> inputs and returns the inputs and outputs. Note
                that this returns an <see cref="T:System.Collections.Generic.IEnumerable`1" />; the program may not be invoked until the
                <see cref="T:System.Collections.Generic.IEnumerable`1" /> is actually enumerated.
            </summary>
            <param name="kind">
                Which <see cref="T:Microsoft.ProgramSynthesis.Features.InputKind" /> of inputs to run <see cref="P:Microsoft.ProgramSynthesis.Features.LearningInfo.ProgramNode" /> on.
            </param>
            <returns>
                <see cref="T:System.Collections.Generic.KeyValuePair`2" />s where the keys are the <paramref name="kind" /> inputs and the values are
                their outputs on <see cref="P:Microsoft.ProgramSynthesis.Features.LearningInfo.ProgramNode" />.
            </returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.Features.LearningInfo.GetOutputMapping(Microsoft.ProgramSynthesis.Features.InputKind)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.LearningInfo.GetOutputMapping(Microsoft.ProgramSynthesis.Features.InputKind)">
            <summary>
                Runs <see cref="P:Microsoft.ProgramSynthesis.Features.LearningInfo.ProgramNode" /> on the <paramref name="kind" /> inputs and returns a dictionary mapping the inputs
                to the outputs.
            </summary>
            <param name="kind">
                Which <see cref="T:Microsoft.ProgramSynthesis.Features.InputKind" /> of inputs to run <see cref="P:Microsoft.ProgramSynthesis.Features.LearningInfo.ProgramNode" /> on.
            </param>
            <returns>
                A dictionary mapping the <paramref name="kind" /> inputs to their outputs on <see cref="P:Microsoft.ProgramSynthesis.Features.LearningInfo.ProgramNode" />.
            </returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.Features.LearningInfo.GetInputOutputPairs(Microsoft.ProgramSynthesis.Features.InputKind)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.LearningInfo.ForChild(System.Int32)">
            <summary>
                Computes the <see cref="T:Microsoft.ProgramSynthesis.Features.LearningInfo" /> relevant to a subprogram of <see cref="P:Microsoft.ProgramSynthesis.Features.LearningInfo.ProgramNode" />.
            </summary>
            <param name="childIndex">The index of the child/subprogram.</param>
            <returns>
                A <see cref="T:Microsoft.ProgramSynthesis.Features.LearningInfo" /> object that is applicable to child/subprogram specified via
                <paramref name="childIndex" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.LearningInfo.Equals(Microsoft.ProgramSynthesis.Features.LearningInfo)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.LearningInfo.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.LearningInfo.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Features.LearningInfoUtils">
            <summary>
                Utility functions for <see cref="T:Microsoft.ProgramSynthesis.Features.LearningInfo" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.LearningInfoUtils.WithProgramNode(Microsoft.ProgramSynthesis.Features.FeatureCalculationContext,Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Returns a <see cref="T:Microsoft.ProgramSynthesis.Features.LearningInfo" /> wrapping <paramref name="context" /> and
                <paramref name="programNode" />.
            </summary>
            <param name="context">The <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext" /> with the inputs to the learning call.</param>
            <param name="programNode">The <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> to provide information for.</param>
            <returns>
                A <see cref="T:Microsoft.ProgramSynthesis.Features.LearningInfo" /> object to be passed to a <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureCalculator" /> for
                <paramref name="programNode" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.LearningInfoUtils.WithProgramNode(Microsoft.ProgramSynthesis.Features.LearningInfo,Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Constructs a new <see cref="T:Microsoft.ProgramSynthesis.Features.LearningInfo" /> with the same <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext" /> as
                <paramref name="learningInfo" /> but a different <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" />.
            </summary>
            <param name="learningInfo">The <see cref="T:Microsoft.ProgramSynthesis.Features.LearningInfo" /> with the inputs to the learning call.</param>
            <param name="programNode">The <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> to provide information for.</param>
            <returns>
                A <see cref="T:Microsoft.ProgramSynthesis.Features.LearningInfo" /> object to be passed to a <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureCalculator" /> for
                <paramref name="programNode" />.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Features.ReferenceFeatureCalculationContextInputs">
            <summary>
                A list of inputs that have already been computed.  A chain of
                <see cref="T:Microsoft.ProgramSynthesis.Features.TransformedFeatureCalculationContextInputs"/> will terminate with a
                <see cref="T:Microsoft.ProgramSynthesis.Features.ReferenceFeatureCalculationContextInputs"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Features.ITrainingBenchmarkSource">
            <summary>
                Interface marking a class which can act as a source for trained feature benchmarks--that is scenarios
                which can be used to generate logs necessary for training an ML model to supply feature values.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.ITrainingBenchmarkSource.GetBenchmarks">
            <summary>
                Produces a series of <see cref="T:Microsoft.ProgramSynthesis.Features.ITrainingBenchmark`1" /> which ModelUpdater will use to produce
                ML training data.
            </summary>
            <returns>The benchmark objects.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Features.ITrainingBenchmark">
            <summary>
                A single scenario which may be used to learn a set of programs from a DSL and then test the correctness
                of those programs.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.ITrainingBenchmark.Name">
            <summary>
                A name for the benchmark--used in providing progress messages during model updates.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.ITrainingBenchmark.Learn(System.Int32,System.Int32[])">
            <summary>
                Initiates synthesis for the specified benchmark.
            </summary>
            <param name="k">Approximate number of programs to learn.</param>
            <param name="trainingIndices">
                Optional: indices of the inputs in <see cref="!:Inputs"/> to be used as training examples.
                If unspecified, defaults to the first N inputs, where N is domain- and benchmark-specific (typically
                specified in the benchmark's JSON description).
            </param>
            <returns>Learned programs.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.ITrainingBenchmark.BuildFeatureCalculationContext(System.Int32[])">
            <summary>
                Build the initial context for learning and ranking for the benchmark.
            </summary>
            <remarks>
                This is the minimal information required for logging context ids.  This could potentially be
                generalized or combined with aspects from sessions or the normal testing framework.
            </remarks>
            <param name="trainingIndices">
                Optional: indices of the inputs in <see cref="!:Inputs"/> to be used as training examples.
                If unspecified, defaults to the first N inputs, where N is domain- and benchmark-specific (typically
                specified in the benchmark's JSON description).
            </param>
            <returns>The initial context for the benchmark.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.ITrainingBenchmark.GetCorrectness(Microsoft.ProgramSynthesis.IProgram)">
            <summary>
                Runs one of the learned programs against a set of test data to determine its correctness.
            </summary>
            <param name="program">One of the programs returned by a previous call to <see cref="M:Microsoft.ProgramSynthesis.Features.ITrainingBenchmark.Learn(System.Int32,System.Int32[])"/>.</param>
            <returns>
                A value between 0 and 1 (inclusive) where 1 means the program produced the expected results on all
                test data and lesser values indicate a percentage of tests for which the program gave correct results.
            </returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.ITrainingBenchmark`1.Inputs">
            <summary>
                All the input rows in the benchmark.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Features.TransformedFeatureCalculationContextInputs">
            <summary>
                A list of inputs that is computed by applying a transformation to another list of inputs.
                The transformation is evaluated lazily, and the results can be said to be
                "Computed" or "Materialized".  When materialized, the transformed values become the reference
                inputs for further transformed values (see <see cref="M:Microsoft.ProgramSynthesis.Features.TransformedFeatureCalculationContextInputs.GetBaseContextInputsForTransform"/> ).
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.FormatParsing.Dates.DateTimeFormatParserBuilder">
            <summary>
                A <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder`5"/> for
                building datetime parsers.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.Dates.DateTimeFormatParserBuilder.AppendSpacer(System.String)">
            <summary>
                Appends a <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.SpacerDateTimeFormatPart"/>.
            </summary>
            <param name="spacerName">The name of the <see cref="T:Microsoft.ProgramSynthesis.DslLibrary.Dates.SpacerDateTimeFormatPart"/>.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.FormatParsing.Dates.DateTimeSpacerFormatParser">
            <summary>
                A <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4"/> that represents a spacer in a
                date-time parser.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.FormatParsing.Dates.DateTimeSpacerFormatParser.AllowComma">
            <summary>
                Should commas be allowed as a spacer?
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.Dates.DateTimeSpacerFormatParser.CreatePartialParse(Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState{Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch,Microsoft.ProgramSynthesis.DslLibrary.Dates.PartialDateTime,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormat,Microsoft.ProgramSynthesis.DslLibrary.StringRegion},System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.Dates.DateTimeSpacerFormatParser.SpacerCompatibilityChecker(Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch,Microsoft.ProgramSynthesis.DslLibrary.Dates.DateTimeFormatMatch)">
            <summary>
                Checks if two spacers are compatible, based on heuristics to parse date-times.
            </summary>
            <param name="dependentMatch">The first spacer.</param>
            <param name="independentMatch">The second spacer.</param>
            <returns><c>true</c> iff <paramref name="dependentMatch" /> and <paramref name="independentMatch" /> are compatible.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState`4">
            <summary>
                A class that represents the state of parsing a formatted object.
            </summary>
            <typeparam name="TPartialParse">The type used to represent partial parses of the formatted object.</typeparam>
            <typeparam name="TFullParse">The type used to represent complete parses of the formatted object.</typeparam>
            <typeparam name="TFormatPart">The type used to represent the composable parts of the formatted object.</typeparam>
            <typeparam name="TSubstring">The type used to represent a slice-able substring.</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState`4.CumulativeParse">
            <summary>
                The cumulative parse of the formatted object represented by this
                <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState`4" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState`4.UnparsedSuffix">
            <summary>
                The part of the formatted object that remains to be parsed.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState`4.ParsedValues">
            <summary>
                The dictionary of parsed values for components that are cross-referenced.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState`4.Equals(Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState{`0,`1,`2,`3})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState`4.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState`4.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState`4.ToFullState">
            <summary>
                Returns a <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FullFormatMatchState`4" />
                that represents the same state as <c>this</c> object.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState`4.CreateFullState(`3)">
            <summary>
                Creates a <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FullFormatMatchState`4" />.
            </summary>
            <param name="unparsedSuffix">The unparsed suffix region.</param>
            <returns>
                A <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FullFormatMatchState`4" /> that
                has matched nothing so far and can be used to parse <paramref name="unparsedSuffix" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState`4.CreateFullState(`3,`0,System.Collections.Immutable.ImmutableDictionary{System.Int32,`0})">
            <summary>
                Creates a <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FullFormatMatchState`4" />.
            </summary>
            <param name="unparsedSuffix">See <see cref="P:Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState`4.UnparsedSuffix" />.</param>
            <param name="cumulativeParse">See <see cref="P:Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState`4.CumulativeParse" />.</param>
            <param name="parsedValues">See <see cref="P:Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState`4.ParsedValues" />.</param>
            <returns>A <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FullFormatMatchState`4" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState`4.Sequence(`0,System.Collections.Immutable.ImmutableDictionary{System.Int32,`0},`3)">
            <summary>
                Compose this <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState`4" /> with another.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState`4.Sequence(System.Func{`3,`0})">
            <summary>
                Compose this <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState`4" /> with
                an empty <see cref="!:TPartialParse" />.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.FormatParsing.FullFormatMatchState`4">
            <summary>
                A <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState`4" /> that represents a
                complete state.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FullFormatMatchState`4.Create(`3)">
            <summary>
                Creates a new empty <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FullFormatMatchState`4" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FullFormatMatchState`4.Create(`3,`0,System.Collections.Immutable.ImmutableDictionary{System.Int32,`0})">
            <summary>
                Creates a new <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FullFormatMatchState`4" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FullFormatMatchState`4.ToFullState">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.FormatParsing.DeltaFormatMatchState`4">
            <summary>
                Represents a <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState`4" /> delta. This is
                identical
                to <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FullFormatMatchState`4" />, except that it provides
                access to the last parsed fragment.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.FormatParsing.DeltaFormatMatchState`4.Origin">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState`4" /> that this delta
                derives from.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.FormatParsing.DeltaFormatMatchState`4.PartialParse">
            <summary>
                The last parsed fragmet of the formatted object.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.DeltaFormatMatchState`4.ToFullState">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.DeltaFormatMatchState`4.Create(Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState{`0,`1,`2,`3},`0,System.Collections.Immutable.ImmutableDictionary{System.Int32,`0},`3)">
            <summary>
                Creates a new <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.DeltaFormatMatchState`4" />.
            </summary>
            <param name="origin">See <see cref="P:Microsoft.ProgramSynthesis.FormatParsing.DeltaFormatMatchState`4.Origin" />.</param>
            <param name="partialParse">See <see cref="P:Microsoft.ProgramSynthesis.FormatParsing.DeltaFormatMatchState`4.PartialParse" />.</param>
            <param name="parsedValues">
                See
                <see cref="P:Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState`4.ParsedValues" />.
            </param>
            <param name="unparsedSuffix">
                See
                <see cref="P:Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState`4.UnparsedSuffix" />
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.DeltaFormatMatchState`4.Squash">
            <summary>
                Squashes a chain of deltas into a single delta.
            </summary>
            <returns>
                A squashed <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.DeltaFormatMatchState`4" /> whose
                <see cref="P:Microsoft.ProgramSynthesis.FormatParsing.DeltaFormatMatchState`4.Origin" /> is a <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FullFormatMatchState`4" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.DeltaFormatMatchState`4.WithResolution(System.Int32,`0)">
            <summary>
                Creates a new <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.DeltaFormatMatchState`4" />
                with an additional resolution in
                <see cref="P:Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState`4.ParsedValues" />.
            </summary>
            <param name="globalId">The identifier of the <see cref="!:TFormatPart" /> that has been resolved.</param>
            <param name="value">
                The value that has been parsed for the <see cref="!:TFormatPart" /> with ID
                <paramref name="globalId" />.
            </param>
            <returns>
                A new <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.DeltaFormatMatchState`4" /> which is identical
                to <c>this</c>, but has the additional resolution provided.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.FormatParsing.RepetitionMode">
            <summary>
                An enumerated type describing how repetitions in <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4"/>s
                are to be handled during parsing.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.FormatParsing.RepetitionMode.Lazy">
            <summary>
                Match repetitions lazily: matching stops when the minimum number of repetitions are
                encountered.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.FormatParsing.RepetitionMode.Greedy">
            <summary>
                Match repetitions lazily: matching tries to match the repeated group as many times
                as possible, up to a maximum of the specified limit.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.FormatParsing.RepetitionMode.Exhaustive">
            <summary>
                Match repetitions exhaustively: one match object is generated for every value
                of the repetition.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.FormatParsing.UnionMatchingMode">
            <summary>
                An enumerated type that is used to define how unions in <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4"/>s
                are matched.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.FormatParsing.UnionMatchingMode.First">
            <summary>
                Only return the match corresponding to the earliest specified alternative that matched.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.FormatParsing.UnionMatchingMode.LongestMatch">
            <summary>
                Only return the the longest matches from among the alternatives.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.FormatParsing.UnionMatchingMode.FirstLongestMatch">
            <summary>
                Similar to <see cref="F:Microsoft.ProgramSynthesis.FormatParsing.UnionMatchingMode.LongestMatch" />, except that if there's more than one longest match, then only the longest
                match corresponding to the earliest specified alternative will be returned. Operationally, this involves:
                1. Compute all the matches.
                2. Get the set of matches that have the longest length.
                3. Return only the matches from step 2 that correspond to the matches for the earliest specified alternative.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.FormatParsing.UnionMatchingMode.Exhaustive">
            <summary>
                Return all matches.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.FormatParsing.ParseConfig">
            <summary>
                A configuration object that controls the behavior of <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4"/>.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.FormatParsing.ParseConfig.RepetitionMode">
            <summary>
                The <see cref="P:Microsoft.ProgramSynthesis.FormatParsing.ParseConfig.RepetitionMode"/> to use while parsing.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.FormatParsing.ParseConfig.UnionMatchingMode">
            <summary>
                The <see cref="P:Microsoft.ProgramSynthesis.FormatParsing.ParseConfig.UnionMatchingMode"/> to use while parsing.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.ParseConfig.#ctor(Microsoft.ProgramSynthesis.FormatParsing.RepetitionMode,Microsoft.ProgramSynthesis.FormatParsing.UnionMatchingMode)">
            <summary>
                Constructor.
            </summary>
            <param name="repetitionMode">See <see cref="P:Microsoft.ProgramSynthesis.FormatParsing.ParseConfig.RepetitionMode"/>.</param>
            <param name="unionMatchingMode">See <see cref="P:Microsoft.ProgramSynthesis.FormatParsing.ParseConfig.UnionMatchingMode"/>.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.FormatParsing.ParseConfig.Default">
            <summary>
                The default configuration.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4">
            <summary>
                An abstract class that represents a parser for formatted objects.
            </summary>
            <typeparam name="TFormatPart">The type used to represent composable parts of the formatted objects being parsed.</typeparam>
            <typeparam name="TPartialParse">The type used to represent partially parsed formatted objects.</typeparam>
            <typeparam name="TFullParse">The type used to represent fully parsed formatted objects.</typeparam>
            <typeparam name="TSubstring">
                The sliceable substring type used for serialized/stringified representation of formatted
                objects.
            </typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4.EmptyPartialParseFactory">
            <summary>
                A function that represents empty instances of <see cref="!:TPartialParse"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4.Parse(`3,Microsoft.ProgramSynthesis.FormatParsing.ParseConfig)">
            <summary>
                Parses the formatted object represented by <paramref name="region"/>.
            </summary>
            <param name="region">The serialized/stringified representation the formatted object to be parsed.</param>
            <param name="config">The <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.ParseConfig"/> to use.</param>
            <returns>A sequence of parses obtained by parsing <paramref name="region"/>.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4.ComputeDeltas(Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState{`1,`2,`0,`3},Microsoft.ProgramSynthesis.FormatParsing.ParseConfig)">
            <summary>
                Compute the deltas obtained by starting from <paramref name="state"/> and parsing accoring this
                <c>this</c> <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4.ComputeDeltasImpl(Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState{`1,`2,`0,`3},Microsoft.ProgramSynthesis.FormatParsing.ParseConfig)">
            <summary>
                Computes all the non-empty deltas for exactly one match of this format set.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4.GetPossibleStartPositions(`3)">
            <summary>
                Returns an over-approximation of the set of positions where <c>this</c>
                <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4" />
                can start a match in <paramref name="region" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4.ToString">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4.AtomicFormatParser.ToString">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.FormatParsing.SpacerFormatParser`4">
            <summary>
                An abstract class that defines how a spacer is to be parsed.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.FormatParsing.SpacerFormatParser`4.MaxSpacerLength">
            <summary>
                The length of the maximum allowed spacer in a formatted object.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.SpacerFormatParser`4.CreatePartialParse(Microsoft.ProgramSynthesis.FormatParsing.FormatMatchState{`1,`2,`0,`3},System.Int32)">
            <summary>
                Create a <see cref="!:TPartialParse"/> for a spacer that begin with the unparsed suffix in <paramref name="stateBeforeDelimiter"/>
                and has length <paramref name="delimiterLength"/>.
            </summary>
            <returns>A valid <see cref="!:TPartialParse"/> if the spacer is valid, otherwise <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing"/>.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder`5">
            <summary>
                A helper class to build and compose <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4" />s.
            </summary>
            <typeparam name="TFormatPart">See <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4" />.</typeparam>
            <typeparam name="TPartialParse">See <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4" />.</typeparam>
            <typeparam name="TFullParse">See <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4" />.</typeparam>
            <typeparam name="TSubstring">See <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4" />.</typeparam>
            <typeparam name="TSpacerParser">
                The sub-type of
                <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4" /> used to parse spacers in the formatted
                objects.
            </typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder`5.EmptyPartialParseFactory">
            <summary>
                A function that returns an empty <see cref="!:TPartialParse" /> for a given <see cref="!:TSubstring" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder`5.#ctor(System.Func{`3,`1})">
            <summary>
                Constructor.
            </summary>
            <param name="emptyPartialParseFactory">See <see cref="P:Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder`5.EmptyPartialParseFactory" />.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder`5.Append(`0,System.String,System.Predicate{Microsoft.ProgramSynthesis.FormatParsing.DeltaFormatMatchState{`1,`2,`0,`3}},System.Boolean,System.Int32,System.Int32)">
            <summary>
                Append a <see cref="!:TFormatPart" /> to the
                <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4" /> being
                built.
            </summary>
            <param name="formatPart">The new <see cref="!:TFormatPart" /> to append.</param>
            <param name="componentName">The name of the new component.</param>
            <param name="filterPredicate">An optional predicate to filter matches of <paramref name="formatPart" />.</param>
            <param name="isPermutable">Is the <paramref name="formatPart" /> permutable?</param>
            <param name="minRepetitions">The minimum number of repetitions to match.</param>
            <param name="maxRepetitions">The maximum number of repetitions to match.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder`5.Append(Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder{`0,`1,`2,`3,`4},System.String,System.Predicate{Microsoft.ProgramSynthesis.FormatParsing.DeltaFormatMatchState{`1,`2,`0,`3}},System.Boolean,System.Int32,System.Int32)">
            <summary>
                Append the <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4" /> built up in
                <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder`5" />.
            </summary>
            <param name="builder">
                The new
                <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder`5" /> to append.
            </param>
            <param name="componentName">The name of the new component.</param>
            <param name="filterPredicate">
                An optional predicate to filter matches of the
                <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4" /> represented by
                <paramref name="builder" />.
            </param>
            <param name="isPermutable">Is the newly appended component permutable?</param>
            <param name="minRepetitions">The minimum number of repetitions to match.</param>
            <param name="maxRepetitions">The maximum number of repetitions to match.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder`5.AppendUnion(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder{`0,`1,`2,`3,`4}},System.Collections.Generic.IEnumerable{`0},System.String,System.Predicate{Microsoft.ProgramSynthesis.FormatParsing.DeltaFormatMatchState{`1,`2,`0,`3}},System.Boolean,System.Int32,System.Int32)">
            <summary>
                Append a <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4" /> that represents the union of
                the given <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder`5" />s
                and the given <see cref="!:TFormatPart" />s.
            </summary>
            <param name="formatParsersToUnion">
                The set of <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4" />s to union,
                where the <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4" />s are represented by the
                provided <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder`5" />s.
            </param>
            <param name="formatPartsToUnion">The set of <see cref="!:TFormatPart" />s to union.</param>
            <param name="componentName">The name of the new component.</param>
            <param name="filterPredicate">
                An optional predicate to filter matches of the
                <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4" /> represented by
                the newly appended union component.
            </param>
            <param name="isPermutable">Is the newly appended component permutable?</param>
            <param name="minRepetitions">The minimum number of repetitions to match.</param>
            <param name="maxRepetitions">The maximum number of repetitions to match.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder`5.AppendUnion(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder{`0,`1,`2,`3,`4}},System.String,System.Predicate{Microsoft.ProgramSynthesis.FormatParsing.DeltaFormatMatchState{`1,`2,`0,`3}},System.Boolean,System.Int32,System.Int32)">
            <summary>
                Similar to
                <see
                    cref="M:Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder`5.AppendUnion(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder{`0,`1,`2,`3,`4}},System.Collections.Generic.IEnumerable{`0},System.String,System.Predicate{Microsoft.ProgramSynthesis.FormatParsing.DeltaFormatMatchState{`1,`2,`0,`3}},System.Boolean,System.Int32,System.Int32)" />
                ,
                but only accepts a set of
                <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder`5" />s.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder`5.AppendUnion(System.Collections.Generic.IEnumerable{`0},System.String,System.Predicate{Microsoft.ProgramSynthesis.FormatParsing.DeltaFormatMatchState{`1,`2,`0,`3}},System.Boolean,System.Int32,System.Int32)">
            <summary>
                Similar to
                <see
                    cref="M:Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder`5.AppendUnion(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder{`0,`1,`2,`3,`4}},System.Collections.Generic.IEnumerable{`0},System.String,System.Predicate{Microsoft.ProgramSynthesis.FormatParsing.DeltaFormatMatchState{`1,`2,`0,`3}},System.Boolean,System.Int32,System.Int32)" />
                ,
                but only accepts a set of <see cref="!:TFormatPart" />s.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder`5.EndsWithSpacer">
            <summary>
                Does this <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder`5" /> end
                with
                a spacer?
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder`5.AppendSpacer(System.String,`4,System.Predicate{Microsoft.ProgramSynthesis.FormatParsing.DeltaFormatMatchState{`1,`2,`0,`3}})">
            <summary>
                Append a <see cref="!:TSpacerParser" />.
            </summary>
            <param name="componentName">The name of the new component.</param>
            <param name="spacerParser">The parser responsible for parsing this spacer.</param>
            <param name="filterPredicate">
                An optional predicate to filter matches of the
                <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4" /> represented by
                <paramref name="spacerParser" />.
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder`5.AssertDirectionalConstraint(System.String,System.Func{`1,System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.Utils.Optional{`1}},System.Boolean},System.String[])">
            <summary>
                Assert a constraint between a component named <paramref name="dependentComponentName" />,
                and a set of components named <paramref name="independentComponents" />.
            </summary>
            <param name="dependentComponentName">The component name of the dependent component.</param>
            <param name="dependencyConstraintChecker">A function that checks the required constraint.</param>
            <param name="independentComponents">The names of the independent components.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder`5.AssertGroupConstraint(System.Func{System.Int32,`1,System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.Utils.Optional{`1}},System.Boolean},System.String[])">
            <summary>
                Assert a group constraint between a set of components.
            </summary>
            <param name="dependencyConstraintChecker">The constraint checker.</param>
            <param name="componentNames">The names of the constrained components.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder`5.AssertDirectionalConstraint(System.String,System.Func{`1,System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.Utils.Optional{`1}},System.Boolean},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Assert a constraint between a component named <paramref name="dependentComponentName" />,
                and a set of components named <paramref name="independentComponents" />.
            </summary>
            <param name="dependentComponentName">The component name of the dependent component.</param>
            <param name="dependencyConstraintChecker">A function that checks the required constraint.</param>
            <param name="independentComponents">The names of the independent components.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder`5.AssertGroupConstraint(System.Func{System.Int32,`1,System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.Utils.Optional{`1}},System.Boolean},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Assert a group constraint between a set of components.
            </summary>
            <param name="dependencyConstraintChecker">The constraint checker.</param>
            <param name="componentNames">The names of the constrained components.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder`5.Build">
            <summary>
                Construct the built-up <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder`5.Clear">
            <summary>
                Clear any built-up <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.FormatParser`4" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.FormatParsing.FormatParserBuilder`5.FormatParserBuilderComponent.Dependents">
            <summary>
                The set of components whose values are constrained on my values.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.FormatParsing.IFormatPart`4">
            <summary>
                An interface that represents format parts.
            </summary>
            <typeparam name="TPartialParse">The type of the partial parse objects produced by this format part.</typeparam>
            <typeparam name="TFullParse">The type of the complete parse objects produced by <see cref="!:TPartialParse" /> objects.</typeparam>
            <typeparam name="TSubstring">The type of the <see cref="T:Microsoft.ProgramSynthesis.ISubstring`1" /> parsed by this format part.</typeparam>
            <typeparam name="TFormatPart">The type implementing this interface.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.IFormatPart`4.GetNextPossibleMatchPosition(`2)">
            <summary>
                Gets the next possible match position in <paramref name="unparsedSuffix" />. Returns
                <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" />
                if this format part does not contain a match in <paramref name="unparsedSuffix" />.
            </summary>
            <param name="unparsedSuffix"></param>
            <returns>
                An integer that contains the next match position for this part, wrapped in an <see cref="T:Microsoft.ProgramSynthesis.Utils.Optional`1" /> if
                one exists. Otherwise,  <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.IFormatPart`4.GetAllPossibleMatchPositions(`2)">
            <summary>
                Returns all the possible match positions for this format part in <paramref name="unparsedSuffix" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.IFormatPart`4.Parse(`2)">
            <summary>
                Returns all possible parses for this format part, starting at <see cref="!:unparsedSuffix" />.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.FormatParsing.IPartialParse`4">
            <summary>
                An interface that represents partial results of parsing.
            </summary>
            <typeparam name="TFullParse">The type representing full (complete) parses.</typeparam>
            <typeparam name="TFormatPart">The type representing format parts.</typeparam>
            <typeparam name="TSubstring">The type representing substrings.</typeparam>
            <typeparam name="TPartialParse">
                The type implementing
                <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.IPartialParse`4" />.
            </typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.FormatParsing.IPartialParse`4.ParsedRegion">
            <summary>
                The <see cref="!:TSubstring" /> object that represents the region parsed by this
                <see cref="T:Microsoft.ProgramSynthesis.FormatParsing.IPartialParse`4" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.FormatParsing.IPartialParse`4.CompleteParse">
            <summary>
                The value of the completed parse.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.FormatParsing.IPartialParse`4.Sequence(`3)">
            <summary>
                Sequence this <see cref="!:TPartialParse" /> with another <see cref="!:TPartialParse" /> object.
            </summary>
            <param name="other">The other <see cref="!:TPartialParse" /> object to sequence after this <see cref="!:TPartialParse" />.</param>
            <returns>
                A <see cref="!:TPartialParse" /> object that represents the sequencing, wrapped in an <see cref="T:Microsoft.ProgramSynthesis.Utils.Optional`1" />
                , if the sequencing was successful. Otherwise <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" />
            </returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.FormatParsing.IPartialParse`4.ContainsOnlyEmptyParse">
            <summary>
                Does this partial parse consist only of an empty part?
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Grammar.IsRecursionLimited">
            <summary>
                Does any rule have a recursion limit on it?
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Grammar.#ctor(System.String,Microsoft.ProgramSynthesis.DiagnosticsContext)">
            <summary>
                Construct an empty grammar from a given name and diagnostics context.
                Symbols, rules, semantics, features and learners can be added to this grammar using
                <see cref="M:Microsoft.ProgramSynthesis.Grammar.AddSymbol(System.String,Microsoft.ProgramSynthesis.Utils.GrammarType,System.Boolean)"/>,
                <see cref="M:Microsoft.ProgramSynthesis.Grammar.AddRule(Microsoft.ProgramSynthesis.Rules.GrammarRule)"/>,
                <see cref="!:AddSemanticsLocation(Type)"/>,
                <see cref="M:Microsoft.ProgramSynthesis.Grammar.AddFeature(System.Type,System.String,System.Collections.Generic.IEnumerable{System.Type},System.Boolean)"/>, and
                <see cref="!:AddLearnerLocation(Type)"/>.
                Once these objects are added, <see cref="M:Microsoft.ProgramSynthesis.Grammar.Validate(Microsoft.ProgramSynthesis.DiagnosticsContext)"/> must be called
                to perform some final checks on the validity of the grammar.
            </summary>
            <param name="name">Name of the grammar.</param>
            <param name="diagnosticsContext">All error and warning diagnostics during construction are added into this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Grammar.Validate(Microsoft.ProgramSynthesis.DiagnosticsContext)">
            <summary>
                Perform sanity checks on the grammar and add any errors and warnings discovered
                into <paramref name="diagnosticsContext"/>.
            </summary>
            <param name="diagnosticsContext">The diagnostics context to add any warnings and errors encountered.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Grammar.CalculateFreeVariableHeight(Microsoft.ProgramSynthesis.Symbol,System.Collections.Immutable.ImmutableDictionary{Microsoft.ProgramSynthesis.Symbol,System.Int32},System.Collections.Immutable.ImmutableDictionary{Microsoft.ProgramSynthesis.Symbol,System.Int32},System.Int32)">
            <summary>
            Perform a DFS on the grammar, starting from <paramref name="current"/>.
            As usual in a DFS, keep track of visited symbols (with the number of times they were visited) in <paramref name="seen"/>.
            Also, for each symbol, keep track of the longest path (as measured by variable bindings) from <see cref="P:Microsoft.ProgramSynthesis.Grammar.StartSymbol"/>
            to this symbol in <paramref name="longestPaths"/>.
            This is needed for detecting cycles with bindings, which cause infinite <see cref="P:Microsoft.ProgramSynthesis.Grammar.FreeVariableHeight"/>.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Grammar.FreeVariableHeight">
            <summary>
            Returns the maximal number of free variables that can appear in any path from the root to leaves,
            or <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing"/> if it can be infinite.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.IProgram">
            <summary>
                The interface for all programs, which wraps a <see cref="P:Microsoft.ProgramSynthesis.IProgram.ProgramNode" /> with type information so it's more
                convenient to use.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.IProgram.ProgramNode">
            <summary>
                The <see cref="P:Microsoft.ProgramSynthesis.IProgram.ProgramNode" /> object which contains the actual program.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.IProgram.RawProgramNode">
            <summary>
                Internal use only. If available, the program node that was learned, before any post-processing has been applied.
                If this program was created in any way other than directly from a <c>.Learn()</c> call, the contents of this
                property may be nonsense.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.IProgram.Score">
            <summary>
                The ranking score of the program (the higher the better).
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.IProgram.Version">
            <summary>
                The version of the program.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.IProgram.Serialize(Microsoft.ProgramSynthesis.AST.ASTSerializationFormat)">
            <summary>
                Serializes the program to a string.
            </summary>
            <param name="serializationFormat">The desired serialization format (XML or human-readable).</param>
            <returns>The serialized program.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.IProgram.Serialize(Microsoft.ProgramSynthesis.AST.ASTSerializationSettings)">
            <summary>
                Serializes the program to a string.
            </summary>
            <param name="serializationSettings">The desired serialization settings (such as XML or human-readable).</param>
            <returns>The serialized program.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.IProgram.Describe(System.Globalization.CultureInfo)">
            <summary>
                Describes the functionality of the program at a high level.
                Returns null if program description is not available.
            </summary>
            <param name="cultureInfo">The culture info.</param>
            <returns>The program description (null if not available)</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.IProgram.Run(System.Object)">
            <summary>
                Executes the program on the <paramref name="input" /> to obtain the output.
            </summary>
            <param name="input">The input.</param>
            <returns>The program's output.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.ISubstring">
            <summary>
                An interface for classes that represent a substring.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.ISubstring.Source">
            <summary>
                The full string that this <see cref="T:Microsoft.ProgramSynthesis.ISubstring`1" /> represents a substring of.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.ISubstring.Start">
            <summary>
                The start index of this substring in <see cref="P:Microsoft.ProgramSynthesis.ISubstring.Source" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.ISubstring.End">
            <summary>
                The end index (exclusive) of this substring in <see cref="P:Microsoft.ProgramSynthesis.ISubstring.Source" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.ISubstring.Length">
            <summary>
                The length of this substring.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.ISubstring.Value">
            <summary>
                The value of the substring represented by this object.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.ISubstring`1.AbsoluteSlice(System.UInt32,System.UInt32)">
            <summary>
                Returns an absolute slice of this <see cref="T:Microsoft.ProgramSynthesis.ISubstring`1" />.
            </summary>
            <param name="start">
                The start index of the desired slice. Must be greater than or equal to
                <see cref="P:Microsoft.ProgramSynthesis.ISubstring.Start" />.
            </param>
            <param name="end">The end index of the desired slice. Must be less than or equal to <see cref="P:Microsoft.ProgramSynthesis.ISubstring.End" />.</param>
            <returns>A new slice of this substring.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.ISubstring`1.RelativeSlice(System.UInt32,System.UInt32)">
            <summary>
                Returns a relative slice of this <see cref="T:Microsoft.ProgramSynthesis.ISubstring`1" />.
            </summary>
            <param name="start">The start index of the desired slice. Must be greater than or equal to <c>0</c>.</param>
            <param name="end">The end index of the desired slice. Must be less than or equal to <see cref="P:Microsoft.ProgramSynthesis.ISubstring.Length" />.</param>
            <returns>A new slice of this substring.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Learning.ProgramSamplingStrategy">
            <summary>
                Sampling strategies for <see cref="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.Sample(System.Random,Microsoft.ProgramSynthesis.Learning.ProgramSamplingStrategy)" />.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Learning.ProgramSamplingStrategy.UniformRandom">
            <summary>
                Sample uniformly, at random. This means that each of the unioned sets of a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.UnionProgramSet" />
                has a probability of being sampled, which is proportional to the size of the unioned set.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Learning.ProgramSamplingStrategy.UniformAcrossUnions">
            <summary>
                Sample uniformly across unioned sets. This means that the probability of picking a program across unioned sets
                is 1/(Number of sets in the union).
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Learning.PruningRequest">
            <summary>
                A class the represents any pruning to be performed while learning.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.PruningRequest.K">
            <summary>
                The number of top programs to retain.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.PruningRequest.RandomK">
            <summary>
                The number of random programs to sample.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.PruningRequest.ProgramSamplingStrategy">
            <summary>
                The <see cref="P:Microsoft.ProgramSynthesis.Learning.PruningRequest.ProgramSamplingStrategy"/> to use if <see cref="P:Microsoft.ProgramSynthesis.Learning.PruningRequest.RandomK"/> is non-null.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.PruningRequest.TopProgramsFeature">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.Features.IFeature" /> with respect to which the top ranked programs are
                chosen, when <see cref="P:Microsoft.ProgramSynthesis.Learning.PruningRequest.K" /> is set.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.PruningRequest.TopProgramsFeatureOptions">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.Features.IFeatureOptions" /> to be used in conjunction with <see cref="P:Microsoft.ProgramSynthesis.Learning.PruningRequest.TopProgramsFeature" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.PruningRequest.IsEmpty">
            <summary>
                Is this <see cref="T:Microsoft.ProgramSynthesis.Learning.PruningRequest" /> empty? A <see cref="T:Microsoft.ProgramSynthesis.Learning.PruningRequest" /> is empty is both
                the <see cref="P:Microsoft.ProgramSynthesis.Learning.PruningRequest.K" /> and <see cref="P:Microsoft.ProgramSynthesis.Learning.PruningRequest.RandomK" /> properties are <c>null</c>.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.PruningRequest.Empty">
            <summary>
                The single instance of the empty <see cref="T:Microsoft.ProgramSynthesis.Learning.PruningRequest" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.PruningRequest.Equals(Microsoft.ProgramSynthesis.Learning.PruningRequest)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.PruningRequest.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.PruningRequest.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.PruningRequest.ToString">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.PruningRequest.AugmentWithTopProgramsK(System.Int32,Microsoft.ProgramSynthesis.Features.IFeature,Microsoft.ProgramSynthesis.Features.IFeatureOptions)">
            <summary>
                Creates a new <see cref="T:Microsoft.ProgramSynthesis.Learning.PruningRequest" /> by augmenting <c>this</c> request by a
                top-K request. Raises an exception if <c>this</c> request already has a top-K request
                associated with it.
            </summary>
            <param name="topProgramsK">The number of top-ranked programs to retain.</param>
            <param name="topProgramsFeature">The feature by which the programs are ranked.</param>
            <param name="topProgramsFeatureOptions">
                The <see cref="T:Microsoft.ProgramSynthesis.Features.IFeatureOptions" /> to be used in conjunction with
                <paramref name="topProgramsFeature" />.
            </param>
            <returns>A new <see cref="T:Microsoft.ProgramSynthesis.Learning.PruningRequest" /> with a top-K request added as described in the summary.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.PruningRequest.ReplaceWithTopProgramsK(System.Int32,Microsoft.ProgramSynthesis.Features.IFeature,Microsoft.ProgramSynthesis.Features.IFeatureOptions)">
            <summary>
                Similar to <see cref="M:Microsoft.ProgramSynthesis.Learning.PruningRequest.AugmentWithTopProgramsK(System.Int32,Microsoft.ProgramSynthesis.Features.IFeature,Microsoft.ProgramSynthesis.Features.IFeatureOptions)" />, except that any existing top-K request is replaced.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.PruningRequest.WithNewTopProgramsK(System.Int32)">
            <summary>
                Creates a new <see cref="T:Microsoft.ProgramSynthesis.Learning.PruningRequest" /> with a different number of top programs to be retained, without
                changing
                <see cref="P:Microsoft.ProgramSynthesis.Learning.PruningRequest.TopProgramsFeature" /> or <see cref="P:Microsoft.ProgramSynthesis.Learning.PruningRequest.TopProgramsFeatureOptions" />.
                Requires that <c>this</c> <see cref="T:Microsoft.ProgramSynthesis.Learning.PruningRequest" /> already have a top-K request associated with it.
            </summary>
            <param name="newTopProgramsK">The new count of top programs to retain.</param>
            <returns>A new <see cref="T:Microsoft.ProgramSynthesis.Learning.PruningRequest" /> as described in the summary.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.PruningRequest.AugmentWithRandomProgramsK(System.Int32)">
            <summary>
                Creates a new <see cref="T:Microsoft.ProgramSynthesis.Learning.PruningRequest" /> by augmenting <c>this</c> request by a
                random-K request. Raises an exception if <c>this</c> request already has a random-K request
                associated with it.
            </summary>
            <param name="randomK">The number of randomly chosen programs to retain.</param>
            <returns>A new <see cref="T:Microsoft.ProgramSynthesis.Learning.PruningRequest" /> with a random-K request added as described in the summary.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.PruningRequest.ReplaceWithRandomProgramsK(System.Int32,System.Nullable{Microsoft.ProgramSynthesis.Learning.ProgramSamplingStrategy})">
            <summary>
                Similar to <see cref="M:Microsoft.ProgramSynthesis.Learning.PruningRequest.AugmentWithRandomProgramsK(System.Int32)" />, except that any existing random-K request is
                simply replaced with the new value.
            </summary>
            <param name="newRandomK">The number of randomly chosen programs to retain.</param>
            <param name="programSamplingStrategy">
                The new <see cref="P:Microsoft.ProgramSynthesis.Learning.PruningRequest.ProgramSamplingStrategy" />, if <c>null</c>, the existing
                <see cref="P:Microsoft.ProgramSynthesis.Learning.PruningRequest.ProgramSamplingStrategy" /> will be used.
            </param>
            <returns>A new <see cref="T:Microsoft.ProgramSynthesis.Learning.PruningRequest" /> with the new random-K request as described in the summary.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.PruningRequest.WithoutRandomK">
            <summary>
                Returns a new <see cref="T:Microsoft.ProgramSynthesis.Learning.PruningRequest" /> with any random-K requests removed.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.PruningRequest.WithoutTopK">
            <summary>
                Returns a new <see cref="T:Microsoft.ProgramSynthesis.Learning.PruningRequest" /> with any top-K requests removed.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Learning.LearningTask">
            <summary>
                A task that consolidates all the information required for the learning API call: the symbol, spec, and additional
                request parameters.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.LearningTask.Language">
            <summary>
                The language from which a caller wants to synthesize programs.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.LearningTask.Symbol">
            <summary>
                The root symbol for the language from which a caller wants to synthesize programs.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.LearningTask.Spec">
            <summary>
                The spec that the synthesized programs have to satisfy.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.LearningTask.AdditionalInputs">
            <summary>
                Optional additional representative inputs, provided during the learning process
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.LearningTask.PruningRequest">
            <summary>
                The <see cref="P:Microsoft.ProgramSynthesis.Learning.LearningTask.PruningRequest"/> associate with this task.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.LearningTask.IsOneShot">
            <summary>
                True if the learning is one-shot, i.e., requested on a <see cref="P:Microsoft.ProgramSynthesis.Learning.LearningTask.Grammar" />;
                false if the learning is incremental, i.e., requested on a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.LearningTask.RecursionDepths">
            <summary>
                The number of times grammar symbols appeared in the synthesis call stack up to and including this call.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.LearningTask.K">
            <summary>
                An optional restriction on the number of synthesized programs.
                A caller may request only top-K programs according to the specified feature value.
                If <see cref="P:Microsoft.ProgramSynthesis.Learning.LearningTask.RandomK" /> is also set, then the top ranked <see cref="P:Microsoft.ProgramSynthesis.Learning.LearningTask.K" />,
                (according to <see cref="P:Microsoft.ProgramSynthesis.Learning.LearningTask.TopProgramsFeature" />) are returned, along with <see cref="P:Microsoft.ProgramSynthesis.Learning.LearningTask.RandomK" />
                programs randomly sampled from the set of all programs.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.LearningTask.RandomK">
            <summary>
                An optional restriction on the number of synthesized programs.
                A called may request only <see cref="P:Microsoft.ProgramSynthesis.Learning.LearningTask.RandomK" /> programs.
                If <see cref="P:Microsoft.ProgramSynthesis.Learning.LearningTask.K" /> is also set, then the top ranked <see cref="P:Microsoft.ProgramSynthesis.Learning.LearningTask.K" />,
                (according to <see cref="P:Microsoft.ProgramSynthesis.Learning.LearningTask.TopProgramsFeature" />) are returned, along with <see cref="P:Microsoft.ProgramSynthesis.Learning.LearningTask.RandomK" />
                programs randomly sampled from the set of all programs.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.LearningTask.TopProgramsFeature">
            <summary>
                An optional ranking feature for selecting top-k synthesized programs.
                A caller may request only top-K programs according to the specified feature value.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.LearningTask.TopProgramsFeatureOptions">
            <summary>
                An optional <see cref="T:Microsoft.ProgramSynthesis.Features.IFeatureOptions" /> that are to be used when computing feature values.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.LearningTask.RequiresPruning">
            <summary>
                Does this task require pruning of the program sets?
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.LearningTask.ProvidedInputs">
            <summary>
                Returns a union of all input states provided in the task: the ones embedded in the spec and the ones provided
                additionally.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.LearningTask.FeatureCalculationContext">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext" /> object associated with this <see cref="T:Microsoft.ProgramSynthesis.Learning.LearningTask" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.LearningTask.Configuration">
            <summary>
                The optional learning configuration that callers may use to pass extra learning information.
                One example is the depth limit of recursion calls.
                This property affects <see cref="T:Microsoft.ProgramSynthesis.Learning.LearningTask" />'s equality (and therefore the cache key of
                <see cref="T:Microsoft.ProgramSynthesis.Learning.SynthesisEngine" />).
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.LearningTask.MakeSubtask(Microsoft.ProgramSynthesis.Rules.NonterminalRule,System.Int32,Microsoft.ProgramSynthesis.Specifications.Spec)">
            <summary>
                Creates a parameter learning subtask from a given learning task, and updates the tracked recursion info.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Learning.Logging.LogInfo">
            <summary>
                Specifies which events of a synthesis process to include in the generated log.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Learning.Logging.LogInfo.None">
            <summary>
                No logging.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Learning.Logging.LogInfo.Branch">
            <summary>
                Branch enter and exit events (i.e. grammar rules or <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.UnionProgramSet"/> alternatives)
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Learning.Logging.LogInfo.WitnessingPlan">
            <summary>
                Selected <see cref="T:Microsoft.ProgramSynthesis.Learning.IWitnessingPlan"/> for deductive synthesis.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Learning.Logging.LogInfo.Witness">
            <summary>
                Invocation of a witness function with its prerequisites and generated witness spec.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Learning.Logging.LogInfo.Cluster">
            <summary>
                Iteration over a single cluster of a prerequisite <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> in deductive synthesis.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Learning.Logging.LogInfo.ProgramSets">
            <summary>
                <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/>s that describe the results of each learning call and clusters in deductive synthesis.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Learning.Logging.LogInfo.BestProgram">
            <summary>
                The highest-ranking program for each branch (according to <see cref="P:Microsoft.ProgramSynthesis.Learning.Logging.LogListener.ScoreFeature"/>), along
                with its score and produced output.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Learning.Logging.LogInfo.TopK">
            <summary>
                Log top-k computations and which nodes are pruned.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Learning.Logging.LogInfo.MLTraining">
            <summary>
                Any data that is required for training an ML branch prioritization model.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Learning.Logging.LogInfo.AllAbbreviated">
            <summary>
                All events except the <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> results of each learning call.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Learning.Logging.LogInfo.All">
            <summary>
                All events.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Learning.NamespaceDoc">
            <summary>
                <see cref="T:Microsoft.ProgramSynthesis.Learning.SynthesisEngine"/> uses strategies (<see cref="T:Microsoft.ProgramSynthesis.Learning.ISynthesisStrategy"/>) to perform
                <see cref="T:Microsoft.ProgramSynthesis.Learning.LearningTask"/> tasks to learn a program.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.ProgramSetExtensions.Filter(Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.Specifications.Spec,Microsoft.ProgramSynthesis.Learning.SynthesisEngine,System.Threading.CancellationToken)">
            <summary>
                Filters a given <paramref name="set" /> down only to a programs that are consistent with a given
                <paramref name="spec" />.
            </summary>
            <param name="set">A program set to filter.</param>
            <param name="spec">A spec to satisfy.</param>
            <param name="engine">
                A synthesis engine that will be used to resolve learning calls generated during filtering. Must be
                initialized with a <see cref="T:Microsoft.ProgramSynthesis.Learning.Strategies.DeductiveSynthesis" /> strategy and a <see cref="T:Microsoft.ProgramSynthesis.Learning.DomainLearningLogic" /> suitable for
                the language of <paramref name="spec" />.
            </param>
            <param name="cancel">A cancellation token. Will be passed to the learning methods of <paramref name="engine" />.</param>
            <returns>
                A <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet" /> representing a subset of the programs contained in the current instance that
                satisfy <paramref name="spec" />.
            </returns>
            <remarks>
                When possible, this implementation should be preferred to <see cref="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.Filter(Microsoft.ProgramSynthesis.Specifications.Spec)"/>. Use the latter
                one only when this implementation fails to produce a satisfactory result.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.ProgramSetExtensions.ClearCaches(Microsoft.ProgramSynthesis.VersionSpace.ProgramSet)">
            <summary>
                Clear all internal caches from this set to reduce memory footprint.
            </summary>
            <param name="set">The set to clear caches from.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.Strategies.ComponentBasedSynthesis.#ctor(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Symbol},System.Func{Microsoft.ProgramSynthesis.Learning.Strategies.ComponentBasedSynthesis.LearnerState,Microsoft.ProgramSynthesis.Specifications.Spec,System.Boolean},System.Collections.Generic.IReadOnlyDictionary{Microsoft.ProgramSynthesis.Rules.TerminalRule,System.Func{System.Object,System.Collections.Generic.IEnumerable{System.Object}}},System.Func{Microsoft.ProgramSynthesis.Specifications.Spec,System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.AST.ProgramNode}})">
            <summary>
                Constructs an enumerative synthesizer.
            </summary>
            <param name="ignoredSymbols">
                A collection of symbols in the grammar which should treated as not existing.
                Default is <c>null</c> to indicate the entire grammar should be used.
            </param>
            <param name="intermediateStateFilter">
                Optional filter for intermediate states. Given a <see cref="T:Microsoft.ProgramSynthesis.Learning.Strategies.ComponentBasedSynthesis.LearnerState" /> and the <see cref="T:Microsoft.ProgramSynthesis.Specifications.Spec" /> being learned from,
                if it returns <c>false</c>, that <see cref="T:Microsoft.ProgramSynthesis.Learning.Strategies.ComponentBasedSynthesis.LearnerState" /> is discarded and not used to build further programs.
            </param>
            <param name="inputBasedLiteralGenerators">
                Optional generators for literals that are given an input and output the possible literals to use for that input.
            </param>
            <param name="initialProgramsFunc">Function to generate seed programs to start generation with from the Spec.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Learning.Strategies.ComponentBasedSynthesis.LearnerState">
            <summary>
                In a state <see cref="P:Microsoft.ProgramSynthesis.Learning.Strategies.ComponentBasedSynthesis.LearnerState.State"/> the program <see cref="P:Microsoft.ProgramSynthesis.Learning.Strategies.ComponentBasedSynthesis.LearnerState.Program"/> produced the value <see cref="P:Microsoft.ProgramSynthesis.Learning.Strategies.ComponentBasedSynthesis.LearnerState.Values"/>.
                The ranker gives the program a score of <see cref="P:Microsoft.ProgramSynthesis.Learning.Strategies.ComponentBasedSynthesis.LearnerState.Score"/>. The program was found after running the synthesizer
                for <see cref="P:Microsoft.ProgramSynthesis.Learning.Strategies.ComponentBasedSynthesis.LearnerState.Generation"/> iterations.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Learning.Strategies.DeductiveSynthesis">
            <summary>
                The deductive synthesis strategy, which leverages <see cref="T:Microsoft.ProgramSynthesis.Learning.WitnessFunction" /> instances for iterative refinement
                of the specification.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.Strategies.DeductiveSynthesis.FindMostApplicablePlans(Microsoft.ProgramSynthesis.Rules.GrammarRule,Microsoft.ProgramSynthesis.Specifications.Spec)">
            <summary>
                Find the most applicable plans for the <paramref name="rule" /> and the given <paramref name="spec" />.
                Prefer plans that are user-defined and accept more specific spec.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.Strategies.DeductiveSynthesis.Config.PrereqTopProgramsThreshold">
            <summary>
                <para>
                    Calculates the threshold for a program set with a future dependency during ordered program synthesis.
                </para>
                <para>
                    Consider a synthesis task <code>LearnSymbolTopK(N, spec, k)</code> where <code>N := F(A, B)</code> and a
                    witness function
                    for B depends on the value of A. In this case we only need to learn top-K programs for B, but (in general) we
                    have to learn
                    all programs for A, because we don't know the cluster of As that contains the parameter that will yield the
                    highest-ranked
                    F(A, B). <code>PrereqProgramsThreshold</code> is a function that takes as input the value of <code>k</code> and
                    outputs
                    the corresponding value of <code>k'</code> — the number of top programs to be learnt for the independent
                    parameter A.
                    If it outputs <code>null</code>, Microsoft.ProgramSynthesis learns all programs for A.
                </para>
                <remarks>
                    If the ranking function for the DSL is monotonic (higher scores for subexpressions yield higher scores for
                    expressions
                    that contain them), then <code>k' = 1</code> is guaranteed to produce the highest-ranked result.
                </remarks>
                <value>Defaults to <code>k => null</code>.</value>
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.Strategies.DeductiveSynthesis.Config.PrereqRandomProgramsThreshold">
            <summary>
                Similar to <see cref="P:Microsoft.ProgramSynthesis.Learning.Strategies.DeductiveSynthesis.Config.PrereqTopProgramsThreshold"/>, except that this property is applicable
                only when sampling random programs vs. top programs.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.Strategies.DeductiveSynthesis.Config.RandomSeed">
            <summary>
                The random seed used in deductive synthesis. This is used to seed a <see cref="T:System.Random"/>, which
                may then be used to sample random programs in response to a random-K request in a <see cref="T:Microsoft.ProgramSynthesis.Learning.LearningTask"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.RuleLearners.IRuleLearner">
            <summary>
                Interface for rule learners which can provide custom learning logic during deductive synthesis.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.RuleLearners.IRuleLearner.SpecType">
            <summary>
                Subtype of <see cref="T:Microsoft.ProgramSynthesis.Specifications.Spec" /> (may be <see cref="T:Microsoft.ProgramSynthesis.Specifications.Spec" /> itself) that this rule learner accepts.
                <see cref="M:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.RuleLearners.IRuleLearner.CanCall(Microsoft.ProgramSynthesis.Rules.GrammarRule,Microsoft.ProgramSynthesis.Specifications.Spec)" /> will check an instance of <see cref="T:Microsoft.ProgramSynthesis.Specifications.Spec" /> against this type (as well as possibly
                checking other properties).
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.RuleLearners.IRuleLearner.LearnRule(Microsoft.ProgramSynthesis.Learning.SynthesisEngine,Microsoft.ProgramSynthesis.Rules.GrammarRule,Microsoft.ProgramSynthesis.Learning.LearningTask,System.Threading.CancellationToken)">
            <summary>
                A custom learner for a specific grammar rule.
            </summary>
            <param name="engine">The synthesis engine being used; use this for recursive learning calls.</param>
            <param name="rule">The grammar rule to learn programs for.</param>
            <param name="task">The learning task giving the specification and other information on what to learn.</param>
            <param name="cancel">The cancellation token for aborting long-running learns.</param>
            <returns>
                Some <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet" /> of the programs learned or <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if this learner
                does not apply (and therefore other learning logic should be used).
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.RuleLearners.IRuleLearner.CanCall(Microsoft.ProgramSynthesis.Rules.GrammarRule,Microsoft.ProgramSynthesis.Specifications.Spec)">
            <summary>
                Checks if <see cref="M:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.RuleLearners.IRuleLearner.LearnRule(Microsoft.ProgramSynthesis.Learning.SynthesisEngine,Microsoft.ProgramSynthesis.Rules.GrammarRule,Microsoft.ProgramSynthesis.Learning.LearningTask,System.Threading.CancellationToken)" /> can be called with a given <paramref name="rule" /> and <paramref name="spec" />
                . <see cref="M:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.RuleLearners.IRuleLearner.LearnRule(Microsoft.ProgramSynthesis.Learning.SynthesisEngine,Microsoft.ProgramSynthesis.Rules.GrammarRule,Microsoft.ProgramSynthesis.Learning.LearningTask,System.Threading.CancellationToken)" /> may still return <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if it determines while learning that
                in, in fact, does not apply.
            </summary>
            <param name="rule">The grammar rule to learn programs for.</param>
            <param name="spec">The specification to rule for.</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.RuleLearners.RuleLearnerAttribute">
            <summary>
                Labels a method as a rule learner which implements custom learning logic for a grammar rule and returns either Some
                of the programs learned or <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> to indicate it does not apply to the given arguments
                so other learning logic should be used. This method should implement the spec of
                <see cref="M:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.RuleLearners.IRuleLearner.LearnRule(Microsoft.ProgramSynthesis.Learning.SynthesisEngine,Microsoft.ProgramSynthesis.Rules.GrammarRule,Microsoft.ProgramSynthesis.Learning.LearningTask,System.Threading.CancellationToken)" />. Multiple instances of this may be applied to the same method to use the same
                learning logic for multiple grammar rules.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.RuleLearners.RuleLearnerAttribute.RuleName">
            <summary>
                <see cref="P:Microsoft.ProgramSynthesis.Rules.GrammarRule.Id" /> of the <see cref="T:Microsoft.ProgramSynthesis.Rules.GrammarRule" /> to learn for.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.RuleLearners.RuleLearnerAttribute.#ctor(System.String)">
            <summary>
                Labels a method as a rule learner which implements custom learning logic for a grammar rule and returns either Some
                of the programs learned or <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> to indicate it does not apply to the given arguments
                so other learning logic should be used. This method should implement the spec of
                <see cref="M:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.RuleLearners.IRuleLearner.LearnRule(Microsoft.ProgramSynthesis.Learning.SynthesisEngine,Microsoft.ProgramSynthesis.Rules.GrammarRule,Microsoft.ProgramSynthesis.Learning.LearningTask,System.Threading.CancellationToken)" />. Multiple instances of this may be applied to the same method to use the same
                learning logic for multiple grammar rules.
            </summary>
            <param name="ruleName"><see cref="P:Microsoft.ProgramSynthesis.Rules.GrammarRule.Id" /> of the <see cref="T:Microsoft.ProgramSynthesis.Rules.GrammarRule" /> to learn for.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.RuleLearners.RuleLearner">
            <summary>
            A rule learner is a learning procedure for a specific DSL rule or a class of rules.
            <see cref="T:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.RuleLearners.RuleLearner.Static.RuleLearner"/> is a public delegate signature that clients implement in a method that is
            tracked by <see cref="P:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.RuleLearners.RuleLearner.OriginalLearner"/>.
            <see cref="T:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.RuleLearners.RuleLearner.Instance.RuleLearner"/> is an internal wrapper around it for non-static scenarios.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.RuleLearners.RuleLearner.RuleSpecIndex">
            <summary>
            Index of a "spec" parameter in <see cref="T:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.RuleLearners.RuleLearner.Static.RuleLearner"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.ITactic">
            <summary>
                Interface for tactics which can provide custom exploration during deductive synthesis.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.ITactic.LearnAlternative(Microsoft.ProgramSynthesis.IAlternatingLanguage,System.Func{Microsoft.ProgramSynthesis.ILanguage,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet})">
            <summary>
                A custom tactic for a specific grammar rule. 
            </summary>
            <param name="language">The grammar rule.</param>
            <param name="learner">The learner for one branch of<paramref name="language"/>.</param>
            <returns>The learned program set.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.TacticAttribute">
            <summary>
                Labels a method as a tactic which implements custom exploration for a grammar rule. 
                This method should implement the spec of <see cref="M:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.ITactic.LearnAlternative(Microsoft.ProgramSynthesis.IAlternatingLanguage,System.Func{Microsoft.ProgramSynthesis.ILanguage,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet})" />. 
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.TacticAttribute.#ctor(System.String)">
            <summary>
                Constructs an object.
            </summary>
            <param name="symbol">The symbol.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.TacticAttribute.Symbol">
            <summary>
                The symbol (LHS) of the rule to apply custom tactic.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.DefaultTacticAttribute">
            <summary>
                Labels a method as a default tactic which implements custom exploration for all grammar rules. 
                This method should implement the spec of <see cref="M:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.ITactic.LearnAlternative(Microsoft.ProgramSynthesis.IAlternatingLanguage,System.Func{Microsoft.ProgramSynthesis.ILanguage,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet})" />. 
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.StdTactic">
            <summary>
                The standard tactic, which learns each branch in the order of the grammar and union the result.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.StdTactic.LearnAlternative(Microsoft.ProgramSynthesis.IAlternatingLanguage,System.Func{Microsoft.ProgramSynthesis.ILanguage,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet})">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.ShortCircuitTactic">
            <summary>
                The short circuit tactic, which learns each branch in the order of the grammar 
                and stop as soon as a branch return some result.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.ShortCircuitTactic.LearnAlternative(Microsoft.ProgramSynthesis.IAlternatingLanguage,System.Func{Microsoft.ProgramSynthesis.ILanguage,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet})">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.CustomTactic.#ctor(System.Reflection.MethodInfo,Microsoft.ProgramSynthesis.Learning.DomainLearningLogic)">
            <summary>
                Creates a custom tactic.
            </summary>
            <param name="method">The method implementing the tactics.</param>
            <param name="domainLearningLogic">The associated <see cref="T:Microsoft.ProgramSynthesis.Learning.DomainLearningLogic"/>.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.CustomTactic.LearnAlternative(Microsoft.ProgramSynthesis.IAlternatingLanguage,System.Func{Microsoft.ProgramSynthesis.ILanguage,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet})">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.WitnessUtils.WitnessGenericProperty``2(Microsoft.ProgramSynthesis.Rules.BlackBoxRule,System.Int32,Microsoft.ProgramSynthesis.Specifications.BooleanExampleSpec,System.Func{``0,``1})">
            <summary>
            Witness function template for an equality predicate based on some property of the object passed into predicate.
            For example can be used to witness 'title' in IsTitleEqual(node, title) or 'color' in IsBackgroundColorEqual(cell, color)
            </summary>
            <typeparam name="TObjectType">Type of the underlying object</typeparam>
            <typeparam name="TPropertyType">Type of the property</typeparam>
            <param name="rule"></param>
            <param name="baseParamIndex">Index of the parameter referring to the underlying object</param>
            <param name="outerSpec">Boolean spec</param>
            <param name="getValFunc">Function that retrieves the value of the property</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.Strategies.Deductive.WitnessUtils.WitnessGenericProperty``2(Microsoft.ProgramSynthesis.Rules.BlackBoxRule,System.Int32,Microsoft.ProgramSynthesis.Specifications.BooleanExampleSpec,System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Witness function template for the predicate testing if some property of the object contains given value
            For example can be used to witness 'class' in IsClass(node, class)
            </summary>
            <typeparam name="TObjectType">Type of the underlying object</typeparam>
            <typeparam name="TPropertyType">Type of the property</typeparam>
            <param name="rule"></param>
            <param name="baseParamIndex">Index of the parameter referring to the underlying object</param>
            <param name="outerSpec">Boolean spec</param>
            <param name="getValFunc">Function that retrieves the a list of values of the property</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Learning.Strategies.DomainGuidedCBSLearningLogic">
            <summary>
                The learning logic used for domain-guided component-based synthesis strategy. This includes the desired ranking
                function and the strategy configuration parameters.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Learning.Strategies.LearnerState">
            <summary>
                A LearnerState represents the output produced on an input state by a certain program generated
                in the bottom-up enumeration (in a state <see cref="P:Microsoft.ProgramSynthesis.Learning.Strategies.LearnerState.State" /> the program <see cref="P:Microsoft.ProgramSynthesis.Learning.Strategies.LearnerState.Program" /> 
                produced the value <see cref="P:Microsoft.ProgramSynthesis.Learning.Strategies.LearnerState.Record" />). It also includes other meta properties such as whether 
                this state is to be used in the final ranking (<see cref="P:Microsoft.ProgramSynthesis.Learning.Strategies.LearnerState.UsedInRanking" />)
                and whether it has been generated in the latest bottom-up iteration (<see cref="P:Microsoft.ProgramSynthesis.Learning.Strategies.LearnerState.IsNew" />).
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.Strategies.LearnerState.#ctor(Microsoft.ProgramSynthesis.State,Microsoft.ProgramSynthesis.AST.ProgramNode,System.Boolean,System.Object[])">
            <summary>
                Creates a new learner state
            </summary>
            <param name="state">The variable environment state in which the program executes</param>
            <param name="program">The program</param>
            <param name="usedInRanking">
                Indicates if this state is used in ranking programs during domain guided bottom-up
                synthesis
            </param>
            <param name="record">The tuple of program outputs over a sequence of inputs</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Learning.Strategies.DomainGuidedCBS">
            <summary>
                The domain-guided component-based synthesis strategy. This is a bottom-up synthesis stategy which uses
                operator-specific lifting functions provided for any DSL operators and standard component-based synthesis when
                these are not provided.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Learning.Strategies.DomainGuidedCBS.ApplyRuleLiftingFunction(Microsoft.ProgramSynthesis.Rules.NonterminalRule,Microsoft.ProgramSynthesis.Rules.NonterminalRule,System.Collections.Generic.Dictionary{Microsoft.ProgramSynthesis.Symbol,System.Collections.Generic.Dictionary{System.Object[],Microsoft.ProgramSynthesis.Learning.Strategies.LearnerState}},System.Collections.Generic.List{Microsoft.ProgramSynthesis.Learning.Strategies.LearnerState},System.Threading.CancellationToken)">
            <summary>
                Apply the lifting function for the given rule to the given value cache.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Learning.Strategies.DomainGuidedCBS.Config">
            <summary>
                The configuration parameters for the bottom-up enumeration.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Learning.Strategies.NamespaceDoc">
            <summary>
                Contains multiple implementations of <see cref="T:Microsoft.ProgramSynthesis.Learning.Strategies.SynthesisStrategy`1"/>
                for different ways to learn a program.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.WitnessFunctionAttribute.Verify">
            <summary>
            True if the produced spec does not guarantee compositional equivalence of the learned program spaces
            for the rule parameters, and the composed programs should be verified.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Metrics.NormalizedDiscountedCumulativeGain">
            <summary>
                Evaluate the NDCG@k score relevance-scored collections.
                <see>https://en.wikipedia.org/wiki/Discounted_cumulative_gain</see>
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Metrics.NormalizedDiscountedCumulativeGain.Evaluate(System.Int32,System.Double[])">
            <summary>
            Evaluate NDCK@k on a concrete array of relevance scores.
            </summary>
            <param name="k">a non-zero truncation limit (i.e. ideal top k)</param>
            <param name="relevances">non-negative relevance scores</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.NamespaceDoc">
            <summary>
                Contains classes common to all uses of DSLs.
                <see cref="T:Microsoft.ProgramSynthesis.Grammar"/> and <see cref="T:Microsoft.ProgramSynthesis.Symbol"/> for defining DSLs
                and <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureInfo"/> for definition properties over DSLs.
                <see cref="T:Microsoft.ProgramSynthesis.State"/> is used for interpreting programs.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Common.OpenAI.ChatCompletionMessage">
            <summary>
            A message to be sent as part of a <see cref="T:Microsoft.ProgramSynthesis.Common.OpenAI.ChatCompletionRequest"/>
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.ChatCompletionMessage.Role">
            <summary>
            Who sent the message
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.ChatCompletionMessage.Content">
            <summary>
            Content of the message
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Common.OpenAI.ChatCompletionRequest">
            <summary>
            Represents a request to generate chat completions.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.ChatCompletionRequest.Messages">
            <summary>
            Gets or sets the messages to generate chat completions for, in the chat format.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.ChatCompletionRequest.Model">
            <summary>
            Gets or sets the ID of the model to use. Currently, only gpt-3.5-turbo and gpt-3.5-turbo-0301 are supported.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.ChatCompletionRequest.Temperature">
            <summary>
            Gets or sets the sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.ChatCompletionRequest.TopP">
            <summary>
            Gets or sets the value of p to use for nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.ChatCompletionRequest.N">
            <summary>
            Gets or sets the number of chat completion choices to generate for each input message.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.ChatCompletionRequest.Stream">
            <summary>
            Gets or sets a value indicating whether to send partial message deltas.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.ChatCompletionRequest.Stop">
            <summary>
            Gets or sets up to 4 sequences where the API will stop generating further tokens.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.ChatCompletionRequest.MaxTokens">
            <summary>
            Gets or sets the maximum number of tokens allowed for the generated answer. By default, the number of tokens the model can return will be (4096 - prompt tokens).
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.ChatCompletionRequest.PresencePenalty">
            <summary>
            Gets or sets a number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.ChatCompletionRequest.FrequencyPenalty">
            <summary>
            Gets or sets a number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.ChatCompletionRequest.LogitBias">
            <summary>
            Gets or sets the modification of the likelihood of specified tokens appearing in the completion.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionRequest">
            <summary>
                Represents a request to the Completions API. Matches the parameters in 
                <see href="https://platform.openai.com/docs/api-reference/completions">the OpenAI docs</see>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionRequest.#ctor(System.String[],System.String,System.Nullable{System.Int32},System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Int32},System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Int32},System.String[])">
            <summary>
                Creates a new <see cref="T:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionRequest"/> for the specified prompts.
            </summary>
            <param name="prompts">One or more prompts to generate from. Can be null for the sake of creating defaults.</param>
            <param name="max_tokens">How many tokens to complete to. Can return fewer if a stop sequence is hit.</param>
            <param name="temperature">
                What sampling temperature to use. Higher values means the model will take more risks. Try 0.9 for more
                creative applications, and 0 (argmax sampling) for ones with a well-defined answer. It is generally
                recommend to use this or <paramref name="top_p"/> but not both.</param>
            <param name="top_p">
                An alternative to sampling with temperature, called nucleus sampling, where the model considers the
                results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10%
                probability mass are considered. It is generally recommend to use this or <paramref name="temperature"/>
                but not both.
            </param>
            <param name="numOutputs">How many different choices to request for each prompt.</param>
            <param name="presencePenalty">
                The scale of the penalty applied if a token is already present at all.  Should generally be between 0
                and 1, although negative numbers are allowed to encourage token reuse.
            </param>
            <param name="frequencyPenalty">
                The scale of the penalty for how often a token is used.  Should generally be between 0 and 1, although
                negative numbers are allowed to encourage token reuse.
            </param>
            <param name="logProbs">
                Include the log probabilities on the logprobs most likely tokens, which can be found in 
                <see cref="!:CompletionResult.Choices"/> -> <see cref="P:Microsoft.ProgramSynthesis.Common.OpenAI.Choice.Logprobs"/>. So for example, if logprobs is
                10, the API will return a list of the 10 most likely tokens. If logprobs is supplied, the API will 
                always return the logprob of the sampled token, so there may be up to logprobs+1 elements in the
                response.
            </param>
            <param name="stopSequences">
                One or more sequences where the API will stop generating further tokens. The returned text will not
                contain the stop sequence.
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionRequest.#ctor(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Int32},System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Int32},System.String[])">
            <summary>
                Creates a new <see cref="T:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionRequest"/> for a single prompt.
            </summary>
            <param name="prompt">The prompt to generate from</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionRequest.#ctor(Microsoft.ProgramSynthesis.Common.OpenAI.CompletionRequest)">
            <summary>
                Creates a new <see cref="T:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionRequest"/>, inheriting any parameters set in <paramref name="basedOn"/>.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionRequest.CompiledPrompt">
            <summary>
                This is only used for serializing the request into JSON, do not use it directly.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionRequest.MultiplePrompts">
            <summary>
                If requesting more than one prompt, specify them as an array of strings.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionRequest.Prompt">
            <summary>
                For convenience, if you are only requesting a single prompt, set it here
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionRequest.Model">
            <summary>
                The model to use.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionRequest.MaxTokens">
            <summary>
                Number of tokens to generate in the completion. Can return fewer if stop sequence is hit.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionRequest.Temperature">
            <summary>
                Sampling temperature to use. Higher values increases randomness in the output. Use this or 
                <see cref="P:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionRequest.TopP"/> but not both.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionRequest.TopP">
            <summary>
                Alternative to sampling with temperature, called nucleus sampling, where the model considers the results
                of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10%
                probability mass are considered. It is generally recommend to use this or <see cref="P:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionRequest.Temperature"/> but
                not both.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionRequest.PresencePenalty">
            <summary>
                The scale of the penalty applied if a token is already present at all.  Should generally be between 0
                and 1, although negative numbers are allowed to encourage token reuse.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionRequest.FrequencyPenalty">
            <summary>
                The scale of the penalty for how often a token is used.  Should generally be between 0 and 1, although
                negative numbers are allowed to encourage token reuse.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionRequest.NumChoicesPerPrompt">
            <summary>
                How many different choices to request for each prompt.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionRequest.Stream">
            <summary>
                Specifies where the results should stream and be returned at one time. Not used.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionRequest.Logprobs">
            <summary>
                Include the log probabilities on the logprobs most likely tokens, which can be found in 
                <see cref="!:CompletionResult.Choices"/> -> <see cref="P:Microsoft.ProgramSynthesis.Common.OpenAI.Choice.Logprobs"/>. So for example, if logprobs is 
                10, the API will return a list of the 10 most likely tokens. If logprobs is supplied, the API will 
                always return the logprob of the sampled token, so there may be up to logprobs+1 elements in the
                response.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionRequest.CompiledStop">
            <summary>
                This is only used for serializing the request into JSON, do not use it directly.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionRequest.MultipleStopSequences">
            <summary>
                One or more sequences where the API will stop generating further tokens. The returned text will not
                contain the stop sequence.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionRequest.StopSequence">
            <summary>
                The stop sequence where the API will stop generating further tokens. The returned text will not contain
                the stop sequence.  For convenience, if you are only requesting a single stop sequence, set it here
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Common.OpenAI.Choice">
            <summary>
                Represents a completion choice returned by the Completion API.  
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.Choice.Text">
            <summary>
                The main text of the completion
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.Choice.Index">
            <summary>
                If multiple completion choices we returned, this is the index withing the various choices
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.Choice.Logprobs">
            <summary>
                If the request specified <see cref="P:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionRequest.Logprobs"/>, this contains the list of the most
                likely tokens.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.Choice.FinishReason">
            <summary>
                If this is the last segment of the completion result, this specifies why the completion has ended.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Common.OpenAI.Choice.ToString">
            <summary>
                Gets the main text of this completion.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionResult">
            <summary>
                Respresents a result from calling the Completion API
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionResult.Id">
            <summary>
                The identifier of the result, which may be used during troubleshooting
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionResult.CreatedUnixTime">
            <summary>
                The time when the result was generated in unix epoch format
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionResult.Created">
            <summary>
                The time when the result was generated
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionResult.Completions">
            <summary>
                The completions returned by the API.  Depending on your request, there may be 1 or many choices.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionResult.RequestId">
            <summary>
                The request id of this API call, as reported in the response headers.  This may be useful for
                troubleshooting or when contacting OpenAI support in reference to a specific request.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionResult.ToString">
            <summary>
                Gets the text of the first completion, representing the main result
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Common.OpenAI.EmbeddingRequest">
            <summary>
                Represents a request to the Embeddings API. Matches the parameters in 
                <see href="https://platform.openai.com/docs/api-reference/embeddings/create">the OpenAI docs</see>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Common.OpenAI.EmbeddingRequest.#ctor(System.String[],System.String,System.String)">
            <summary>
                Creates a new <see cref="T:Microsoft.ProgramSynthesis.Common.OpenAI.EmbeddingRequest"/> from multiple inputs.
            </summary>
            <param name="inputs">One or more inputs to generate embeddings for.</param>
            <param name="user">A unique identifier representing your end-user (to monitor and detect abuse).</param>
            <param name="model">The model to get embeddings from.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Common.OpenAI.EmbeddingRequest.#ctor(System.String,System.String,System.String)">
            <summary>
                Creates a new <see cref="T:Microsoft.ProgramSynthesis.Common.OpenAI.EmbeddingRequest"/> from a single input.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Common.OpenAI.EmbeddingRequest.#ctor(Microsoft.ProgramSynthesis.Common.OpenAI.EmbeddingRequest)">
            <summary>
                Creates a new <see cref="T:Microsoft.ProgramSynthesis.Common.OpenAI.EmbeddingRequest"/> inheriting any parameters set in <paramref name="basedOn"/>.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.EmbeddingRequest.CompiledInput">
            <summary>
                This is only used for serializing the request into JSON, do not use it directly.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.EmbeddingRequest.MultipleInputs">
            <summary>
                If requesting more than one inputs, specify them as an array of strings.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.EmbeddingRequest.Input">
            <summary>
                For convenience, if you are only requesting a single input, set it here.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.EmbeddingRequest.User">
            <summary>
                A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.EmbeddingRequest.Model">
            <summary>
                The model to obtain an embedding from.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Common.OpenAI.EmbeddingUsage">
            <summary>
                Information about usage for an Embedding request.  
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.EmbeddingUsage.PromptTokens">
            <summary>
                Total tokens in the prompt.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.EmbeddingUsage.TotalTokens">
            <summary>
                Total tokens. Will be same as <see cref="P:Microsoft.ProgramSynthesis.Common.OpenAI.EmbeddingUsage.PromptTokens"/> for embeddings.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.EmbeddingData.Embedding">
            <summary>
                Array representing the embedding.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.EmbeddingData.Index">
            <summary>
                Index of the string in the <see cref="P:Microsoft.ProgramSynthesis.Common.OpenAI.EmbeddingRequest.MultipleInputs"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Common.OpenAI.EmbeddingResult">
            <summary>
                Respresents a result from calling the Embeddings API.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.EmbeddingResult.Model">
            <summary>
                Model used to get embeddings.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.EmbeddingResult.Usage">
            <summary>
                Usage statistics of the request.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Common.OpenAI.EmbeddingResult.Data">
            <summary>
                The embedding data.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Common.OpenAI.ICompletionEndpoint">
            <summary>
            Gets results from a Completions endpoint of a large language model.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Common.OpenAI.IChatCompletionEndpoint">
            <summary>
            Gets results from a Chat Completions endpoint of a large language model.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Common.OpenAI.IEmbeddingEndpoint">
            <summary>
            Get embeddings from a large language model endpoint.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Common.OpenAI.IOpenAIEndpoint`2">
            <summary>
            An interface for the OpenAI endpoint.
            </summary>
            <remarks>
            We recommend using <see cref="T:Microsoft.ProgramSynthesis.Common.OpenAI.ICompletionEndpoint"/> or <see cref="T:Microsoft.ProgramSynthesis.Common.OpenAI.IChatCompletionEndpoint"/> instead.
            When using this interface, <typeparamref name="TRequest"/> and <typeparamref name="TResponse"/>
            should be <see cref="T:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionRequest"/> and <see cref="T:Microsoft.ProgramSynthesis.Common.OpenAI.CompletionResult"/> respectively,
            OR <see cref="T:Microsoft.ProgramSynthesis.Common.OpenAI.ChatCompletionRequest"/> and <see cref="T:Microsoft.ProgramSynthesis.Common.OpenAI.ChatCompletionResult"/> respectively.
            </remarks>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Common.OpenAI.IOpenAIEndpoint">
            <summary>
            A generic interface for the OpenAI endpoint.
            </summary>
            <remarks>
            DO NOT INHERIT FROM <see cref="T:Microsoft.ProgramSynthesis.Common.OpenAI.IOpenAIEndpoint"/> DIRECTLY.
            The implementation must be of type
            <see cref="T:Microsoft.ProgramSynthesis.Common.OpenAI.ICompletionEndpoint"/>, <see cref="T:Microsoft.ProgramSynthesis.Common.OpenAI.IChatCompletionEndpoint"/>,
            or <see cref="T:Microsoft.ProgramSynthesis.Common.OpenAI.IOpenAIEndpoint`2"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.Buffer``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
                Generates a sequence of non-overlapping adjacent buffers over the source sequence.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <param name="source">Source sequence.</param>
            <param name="count">Number of elements for allocated buffers.</param>
            <returns>Sequence of buffers containing source sequence elements.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.Buffer``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary>
                Generates a sequence of buffers over the source sequence, with specified length and possible overlap.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <param name="source">Source sequence.</param>
            <param name="count">Number of elements for allocated buffers.</param>
            <param name="skip">Number of elements to skip between the start of consecutive buffers.</param>
            <returns>Sequence of buffers containing source sequence elements.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.Create``1(System.Func{System.Collections.Generic.IEnumerator{``0}})">
            <summary>
                Creates an enumerable sequence based on an enumerator factory function.
            </summary>
            <typeparam name="TResult">Result sequence element type.</typeparam>
            <param name="getEnumerator">Enumerator factory function.</param>
            <returns>Sequence that will invoke the enumerator factory upon a call to GetEnumerator.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.Create``1(System.Action{Microsoft.ProgramSynthesis.Utils.Interactive.IYielder{``0}})">
            <summary>
                Creates an enumerable sequence based on an asynchronous method that provides a yielder.
            </summary>
            <typeparam name="T">Result sequence element type.</typeparam>
            <param name="create">
                Delegate implementing an asynchronous method that can use the specified yielder to yield return
                values.
            </param>
            <returns>Sequence that will use the asynchronous method to obtain its elements.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.Distinct``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Returns elements with a distinct key value by using the default equality comparer to compare key values.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <typeparam name="TKey">Key type.</typeparam>
            <param name="source">Source sequence.</param>
            <param name="keySelector">Key selector.</param>
            <returns>Sequence that contains the elements from the source sequence with distinct key values.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.Distinct``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Returns elements with a distinct key value by using the specified equality comparer to compare key values.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <typeparam name="TKey">Key type.</typeparam>
            <param name="source">Source sequence.</param>
            <param name="keySelector">Key selector.</param>
            <param name="comparer">Comparer used to compare key values.</param>
            <returns>Sequence that contains the elements from the source sequence with distinct key values.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.DistinctUntilChanged``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns consecutive distinct elements by using the default equality comparer to compare values.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <param name="source">Source sequence.</param>
            <returns>Sequence without adjacent non-distinct elements.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.DistinctUntilChanged``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Returns consecutive distinct elements by using the specified equality comparer to compare values.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <param name="source">Source sequence.</param>
            <param name="comparer">Comparer used to compare values.</param>
            <returns>Sequence without adjacent non-distinct elements.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.DistinctUntilChanged``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Returns consecutive distinct elements based on a key value by using the specified equality comparer to compare key values.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <typeparam name="TKey">Key type.</typeparam>
            <param name="source">Source sequence.</param>
            <param name="keySelector">Key selector.</param>
            <returns>Sequence without adjacent non-distinct elements.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.DistinctUntilChanged``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Returns consecutive distinct elements based on a key value by using the specified equality comparer to compare key values.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <typeparam name="TKey">Key type.</typeparam>
            <param name="source">Source sequence.</param>
            <param name="keySelector">Key selector.</param>
            <param name="comparer">Comparer used to compare key values.</param>
            <returns>Sequence without adjacent non-distinct elements.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.IsEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Determines whether an enumerable sequence is empty.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <param name="source">Source sequence.</param>
            <returns>true if the sequence is empty; false otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
                Enumerates the sequence and invokes the given action for each value in the sequence.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <param name="source">Source sequence.</param>
            <param name="onNext">Action to invoke for each element.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.ForEach``1(``0[],System.Action{``0})">
            <summary>
                Enumerates the sequence and invokes the given action for each value in the sequence.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <param name="source">Source sequence when array.</param>
            <param name="onNext">Action to invoke for each element.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
                Enumerates the sequence and invokes the given action for each value in the sequence.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <param name="source">Source sequence.</param>
            <param name="onNext">Action to invoke for each element.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.Max``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
                Returns the maximum value in the enumerable sequence by using the specified comparer to compare values.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <param name="source">Source sequence.</param>
            <param name="comparer">Comparer used to determine the maximum value.</param>
            <returns>Maximum value in the sequence.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
                Returns the elements with the maximum key value by using the default comparer to compare key values.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <typeparam name="TKey">Key type.</typeparam>
            <param name="source">Source sequence.</param>
            <param name="keySelector">Key selector used to extract the key for each element in the sequence.</param>
            <returns>List with the elements that share the same maximum key value.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
                Returns the elements with the minimum key value by using the specified comparer to compare key values.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <typeparam name="TKey">Key type.</typeparam>
            <param name="source">Source sequence.</param>
            <param name="keySelector">Key selector used to extract the key for each element in the sequence.</param>
            <param name="comparer">Comparer used to determine the maximum key value.</param>
            <returns>List with the elements that share the same maximum key value.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.Memoize``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Creates a buffer with a view over the source sequence, causing each enumerator to obtain access to all of the
                sequence's elements without causing multiple enumerations over the source.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <param name="source">Source sequence.</param>
            <returns>
                Buffer enabling each enumerator to retrieve all elements from the shared source sequence, without duplicating
                source enumeration side-effects.
            </returns>
            <example>
                var rng = Enumerable.Range(0, 10).Do(x => Console.WriteLine(x)).Memoize();
                var e1 = rng.GetEnumerator();
                Assert.IsTrue(e1.MoveNext());    // Prints 0
                Assert.AreEqual(0, e1.Current);
                Assert.IsTrue(e1.MoveNext());    // Prints 1
                Assert.AreEqual(1, e1.Current);
                var e2 = rng.GetEnumerator();
                Assert.IsTrue(e2.MoveNext());    // Doesn't print anything; the side-effect of Do
                Assert.AreEqual(0, e2.Current);  // has already taken place during e1's iteration.
                Assert.IsTrue(e1.MoveNext());    // Prints 2
                Assert.AreEqual(2, e1.Current);
            </example>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.Memoize``2(System.Collections.Generic.IEnumerable{``0},System.Func{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1}})">
            <summary>
                Memoizes the source sequence within a selector function where each enumerator can get access to all of the
                sequence's elements without causing multiple enumerations over the source.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <typeparam name="TResult">Result sequence element type.</typeparam>
            <param name="source">Source sequence.</param>
            <param name="selector">Selector function with memoized access to the source sequence for each enumerator.</param>
            <returns>Sequence resulting from applying the selector function to the memoized view over the source sequence.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.Memoize``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
                Creates a buffer with a view over the source sequence, causing a specified number of enumerators to obtain access
                to all of the sequence's elements without causing multiple enumerations over the source.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <param name="source">Source sequence.</param>
            <param name="readerCount">
                Number of enumerators that can access the underlying buffer. Once every enumerator has
                obtained an element from the buffer, the element is removed from the buffer.
            </param>
            <returns>
                Buffer enabling a specified number of enumerators to retrieve all elements from the shared source sequence,
                without duplicating source enumeration side-effects.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.Memoize``2(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Func{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1}})">
            <summary>
                Memoizes the source sequence within a selector function where a specified number of enumerators can get access to
                all of the sequence's elements without causing multiple enumerations over the source.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <typeparam name="TResult">Result sequence element type.</typeparam>
            <param name="source">Source sequence.</param>
            <param name="readerCount">
                Number of enumerators that can access the underlying buffer. Once every enumerator has
                obtained an element from the buffer, the element is removed from the buffer.
            </param>
            <param name="selector">
                Selector function with memoized access to the source sequence for a specified number of
                enumerators.
            </param>
            <returns>Sequence resulting from applying the selector function to the memoized view over the source sequence.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.Min``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
                Returns the minimum value in the enumerable sequence by using the specified comparer to compare values.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <param name="source">Source sequence.</param>
            <param name="comparer">Comparer used to determine the minimum value.</param>
            <returns>Minimum value in the sequence.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.MinBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
                Returns the elements with the minimum key value by using the default comparer to compare key values.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <typeparam name="TKey">Key type.</typeparam>
            <param name="source">Source sequence.</param>
            <param name="keySelector">Key selector used to extract the key for each element in the sequence.</param>
            <returns>List with the elements that share the same minimum key value.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.MinBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
                Returns the elements with the minimum key value by using the specified comparer to compare key values.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <typeparam name="TKey">Key type.</typeparam>
            <param name="source">Source sequence.</param>
            <param name="keySelector">Key selector used to extract the key for each element in the sequence.</param>
            <param name="comparer">Comparer used to determine the minimum key value.</param>
            <returns>List with the elements that share the same minimum key value.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.Repeat``1(``0)">
            <summary>
                Generates a sequence by repeating the given value infinitely.
            </summary>
            <typeparam name="TResult">Result sequence element type.</typeparam>
            <param name="value">Value to repreat in the resulting sequence.</param>
            <returns>Sequence repeating the given value infinitely.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.Repeat``1(``0,System.Int32)">
            <summary>
                Generates a sequence that contains one repeated value.
            </summary>
            <typeparam name="TResult">Result sequence element type.</typeparam>
            <param name="element">The value to be repeated.</param>
            <param name="count">The number of times to repeat the value in the generated sequence.</param>
            <returns>Sequence that contains a repeated value.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.Repeat``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Repeats and concatenates the source sequence infinitely.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <param name="source">Source sequence.</param>
            <returns>Sequence obtained by concatenating the source sequence to itself infinitely.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.Repeat``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
                Repeats and concatenates the source sequence the given number of times.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <param name="source">Source sequence.</param>
            <param name="count">Number of times to repeat the source sequence.</param>
            <returns>Sequence obtained by concatenating the source sequence to itself the specified number of times.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.SkipLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
                Bypasses a specified number of contiguous elements from the end of the sequence and returns the remaining elements.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <param name="source">Source sequence.</param>
            <param name="count">
                The number of elements to skip from the end of the sequence before returning the remaining
                elements.
            </param>
            <returns>Sequence bypassing the specified number of elements counting from the end of the source sequence.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.EnumerableEx.TakeLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
                Returns a specified number of contiguous elements from the end of the sequence.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <param name="source">Source sequence.</param>
            <param name="count">The number of elements to take from the end of the sequence.</param>
            <returns>Sequence with the specified number of elements counting from the end of the source sequence.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Interactive.IBuffer`1">
            <summary>
                Represents a buffer exposing a shared view over an underlying enumerable sequence.
            </summary>
            <typeparam name="T">Element type.</typeparam>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Interactive.IYielder`1">
            <summary>
                Interface for yielding elements to enumerator.
            </summary>
            <typeparam name="T">Type of the elements yielded to an enumerator.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.IYielder`1.Break">
            <summary>
                Stops the enumeration.
            </summary>
            <returns>Awaitable object for use in an asynchronous method.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interactive.IYielder`1.Return(`0)">
            <summary>
                Yields a value to the enumerator.
            </summary>
            <param name="value">Value to yield return.</param>
            <returns>Awaitable object for use in an asynchronous method.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IObservable.ObservableExtensions.Merge``1(System.Collections.Generic.IEnumerable{System.IObservable{``0}})">
             <summary>
             Merges a set of observables by producing values any time any input observable
             produces a value.
            
             Source1:                  |-A---B---C---D->
             Source2:                  |---E---F---G--->
             Merged(Source1, Source2): |-A-E-B-F-C-G-D->
            
             </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IObservable.ObservableOperators.Select``2(System.IObservable{``0},System.Func{``0,``1})">
             <summary>
             Creates an observable that produces values which are the result of calling a given function upon the
             items emitted by a given observable.
            
             Selector: letter => letter.ToUpperCase()
             Source:                  |-a----b----c----d->
             Source.Select(Selector): |-A----B----C----D->
             </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IObservable.ObservableOperators.Do``1(System.IObservable{``0},System.Action{``0})">
            <summary>
            Subscribes to the OnNext event on a given observable calling the passed in handler any time the observer
            produces values. This is for situations when side effects are unavoidable.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IObservable.ObservableOperators.SelectMany``2(System.IObservable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
             <summary>
             Creates an observable that produces values for every element in lists returned by calling a given function
             upon the items emitted by a given observable.
            
             Selector: letter => new [] { letter, letter }
             Source:                      |-A---B---C---D-->
             Source.SelectMany(Selector): |-AA--BB--CC--DD->
             </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IObservable.ObservableOperators.Where``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
             <summary>
             Creates an observable that produces values only when the given filter returns true for a value produced
             by a given observer.
            
             Filter: letter => letter.IsUpperCase()
             Source:               |-a---B---c---D->
             Source.Where(Filter): |-----B-------D->
             </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IObservable.ObservableOperators.SelectValues``1(System.IObservable{Microsoft.ProgramSynthesis.Utils.Optional{``0}})">
             <summary>
             Creates an observable that produces the internal value of Optionals produced by a given observable.
            
             Source:           |-A.Some()-Nothing-B.Some()-Nothing()->
             Source.Collect(): |-A----------------B------------------>
             </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IObservable.ObservableOperators.First``1(System.IObservable{``0})">
             <summary>
             Creates an observable which returns the first value of a given observable and completes.
            
             Source1:         |-A---B---C->
             Source1.First(): |-A|
            
             Source2:         |---|
             Source2.First(): |---|
             </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IObservable.ObservableOperators.FirstAsync``1(System.IObservable{``0})">
             <summary>
             Asynchronously returns the first value of a given observable. If the observable does
             not produce a value before completing, a result of Nothing is returned instead.
             
             Source1:              |-A---B---C->
             Source1.FirstAsync():   A
            
             Source2:         |------------|
             Source2.First():   *waiting*  Nothing
             </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IObservable.ObservableOperators.Last``1(System.IObservable{``0})">
             <summary>
             Creates an observable which returns the last value of a given observable and completes.
            
             Source1:        |-A---B---C--|
             Source1.Last(): |------------C|
            
             Source2:        |---|
             Source2.Last(): |---|
             </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IObservable.ObservableOperators.LastAsync``1(System.IObservable{``0})">
             <summary>
             Asynchronously returns the last value of a given observable. If the observable does
             not produce a value before completing, a result of Nothing is returned instead.
             
             Source1:             |-A---B---C--|
             Source1.LastAsync():  *waiting*   C
            
             Source2:        |------------|
             Source2.Last():   *waiting*  Nothing
             </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IObservable.ObservableOperators.Scan``1(System.IObservable{``0},System.Func{``0,``0,``0})">
             <summary>
             Creates an observable made up of the return values of a given scanner function aggregating through
             the values produced by a given observable starting with the first value as a seed.
            
             Scanner: (a, b) => a + b
             Source:               |-1---2---3---4-->
             Source.Scan(Scanner): |-1---3---6---10->
             </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IObservable.ObservableOperators.TakeUntil``2(System.IObservable{``0},System.IObservable{``1})">
             <summary>
             Creates an observable that forwards values from a given observable until a second given observable
             either produces a value or completes at which point the new observer will complete.
            
             Source:                   |-1---2---3---4-->
             
             Other1:                   |-----------5-->
             Source.TakeUntil(Other1): |-1---2---3-|
             
             Other2:                   |-------|
             Source.TakeUntil(Other2): |-1---2-|
             </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IObservable.ObservableOperators.TakeWhile``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
             <summary>
             Creates an observable that forwards values from a given observable until a given predicate
             fails upon a produced value at which time the produced observable is completed and the source
             is unsubscribed.
            
             Source:                      |-1---2---3---4-->
             Predicate: n => n &lt; 4
             
             Source.TakeWhile(Predicate): |-1---2---3---|
             </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IObservable.ObservableOperators.Scan``2(System.IObservable{``0},``1,System.Func{``1,``0,``1})">
             <summary>
             Creates an observable made up of the return values of a given scanner function aggregating through
             the values produced by a given observable starting with the given seed.
            
             Scanner: (a, b) => a + b
             Source:                  |-1---2---3---4-->
             Source.Scan(5, Scanner): |-6---8---11--15->
             </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IObservable.ObservableOperators.Nth``1(System.IObservable{``0},System.Int32)">
             <summary>
             Creates an observable which returns the nth value of a given observable and completes.
            
             Source1:        |-A---B---C->
             Source1.Nth(1): |-----B|
            
             Source2:        |---|
             Source2.Nth(1): |---|
             </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IObservable.ObservableOperators.NthAsync``1(System.IObservable{``0},System.Int32)">
             <summary>
             Asynchronously returns the nth value of a given observable. If the observable does
             not produce a value before completing, a result of Nothing is returned instead.
             
             Source1:             |-A----------B---C-->
             Source1.NthAsync(1):   *waiting*  B
            
             Source2:             |------------|
             Source2.NthAsync(1):   *waiting*  Nothing
             </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IObservable.ObservableOperators.Aggregate``1(System.IObservable{``0},System.Func{``0,``0,``0})">
             <summary>
             Creates an observable which returns the last value of a scan observable created from a given
             scanner function and a given observable. The initial observable must complete for the
             resulting observable to produce and value and complete.
            
             Aggregator: (a, b) => a + b
             Source:                       |-1---2---3---4--|
             Source.Scan(Aggregator):      |-1---3---6---10-|
             Source.Aggregate(Aggregator): |----------------10|
             </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IObservable.ObservableOperators.AggregateAsync``1(System.IObservable{``0},System.Func{``0,``0,``0})">
             <summary>
             Asynchronously returns the last value of a scan observable created from a given scanner function
             and a given observable. If the initial observable does not produce a value before completing, a
             result of Nothing is returned instead.
            
             Aggregator: (a, b) => a + b
             Source:                            |-1---2---3---4--|
             Source.Scan(Aggregator):           |-1---3---6---10-|
             Source.AggregateAsync(Aggregator):     *waiting*    10
             </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IObservable.ObservableOperators.Aggregate``2(System.IObservable{``0},``1,System.Func{``1,``0,``1})">
             <summary>
             Creates an observable which returns the last value of a scan observable created from a given
             scanner function, a given seed, and a given observable. The initial observable must complete
             for the resulting observable to produce and value and complete.
            
             Aggregator: (a, b) => a + b
             Source:                          |-1---2---3---4--|
             Source.Scan(5, Aggregator):      | 6---8---11--15-|
             Source.Aggregate(5, Aggregator): |----------------15|
             </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IObservable.ObservableOperators.AggregateAsync``2(System.IObservable{``0},``1,System.Func{``1,``0,``1})">
             <summary>
             Asynchronously returns the last value of a scan observable created from a given scanner function,
             a given seed, and a given observable. If the initial observable does not produce a value before
             completing, a result of Nothing is returned instead.
            
             Aggregator: (a, b) => a + b
             Source:                               |-1---2---3---4--|
             Source.Scan(5, Aggregator):           | 6---8---11--15-|
             Source.AggregateAsync(5, Aggregator): |----------------15|
             </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IObservable.ObservableOperators.Select``2(System.IObservable{``0},System.Func{``0,System.Int32,``1})">
             <summary>
             Creates an observable that produces values which are the result of calling a given function upon the
             items emitted by a given observable and the index of said items.
            
             Selector: (x, index) => x * index
             Source:                  |-1---2---4---8-->
             Source.Select(Selector): |-0---2---8---24->
             </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IObservable.ObservableOperators.ToList``1(System.IObservable{``0})">
             <summary>
             Asynchronously returns a list of all of the values produced by a given observable.
            
             Source1:          |-A---B---C---D--|
             Source1.ToList():      *waiting*   [A, B, C, D]
            
             Source2:          |-------------|
             Source2.ToList():    *waiting*  []
             </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IObservable.ObservableOperators.Publish``1(System.IObservable{``0})">
            <summary>
            Converts a given observable into one that can be connected at a later time. This is
            useful for setting up chains of observables while delaying the initial subscribe to
            ensure that all of the values get threaded through properly.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IObservable.ObservableOperators.Materialize``1(System.IObservable{``0})">
            <summary>
            Converts a given observable into an observable that produces notification values which are
            wrappers around the results of a given observable. This is used primarily for testing purposes.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CSharpUtils.GetUninitializedObject(System.Type)">
            <summary>
            Creates a new instance of the specified type, bypassing the constructor.
            </summary>
            <param name="type">The type to create</param>
            <returns>The new instance</returns>
            <exception cref="T:System.NotSupportedException">If the platform does not support constructor-skipping</exception>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.CSharpUtils.UnicodeCharacterUtilities">
            <summary>
                Defines a set of helper methods to classify Unicode characters.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CSharpUtils.UnicodeCharacterUtilities.IsIdentifierPartCharacter(System.Char)">
            <summary>
                Returns true if the Unicode character can be a part of an identifier.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CSharpUtils.UnicodeCharacterUtilities.IsValidIdentifier(System.String)">
            <summary>
                Check that the name is a valid Unicode identifier.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CSharpUtils.UnicodeCharacterUtilities.IsFormattingChar(System.Char)">
            <summary>
            Returns true if the Unicode character is a formatting character (Unicode class Cf).
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CSharpUtils.UnicodeCharacterUtilities.IsFormattingChar(System.Globalization.UnicodeCategory)">
            <summary>
            Returns true if the Unicode character is a formatting character (Unicode class Cf).
            </summary>
            <param name="cat">The Unicode character.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CSharpUtils.ObjectDisplay.TryReplaceChar(System.Char,System.String@)">
            <summary>
            Returns true if the character should be replaced and sets
            <paramref name="replaceWith"/> to the replacement text.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CSharpUtils.ObjectDisplay.FormatLiteral(System.String)">
            <summary>
            Returns a C# string literal with the given value.
            </summary>
            <param name="value">The value that the resulting string literal should have.</param>
            <returns>A string literal with the given value.</returns>
            <remarks>
            Optionally escapes non-printable characters.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CSharpUtils.GetPropertyValue(System.Object,System.String)">
            <summary>
                Uses reflection to get the value of a public property by name.
            </summary>
            <param name="obj">Object to get property of.</param>
            <param name="propertyName">Name of public property to access.</param>
            <returns>The value of the property named <paramref name="propertyName" /> of <paramref name="obj" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CSharpUtils.GetDictionaryType(System.Type)">
            <summary>
                Checks if <paramref name="type" /> is a dictionary type and if so returns the
                <see cref="T:System.Collections.Generic.IDictionary`2" /> or <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2" /> type it implements.
            </summary>
            <param name="type">Type to check.</param>
            <returns>
                <c>null</c> if <paramref name="type" /> is not a dictionary type or the generic dictionary interface it
                implements.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.IRecordInternal">
            <summary>
            Helper so we can call some record methods recursively without knowing the underlying types.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Record">
            <summary>
            They are most easily created via the Record.Create factory methods.
            The System.Record types differ from the System.Tuple types in that:
            - they are structs rather than classes,
            - they are mutable rather than readonly, and
            - their members (such as Item1, Item2, etc) are fields rather than properties.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if <paramref name="obj"/> is a <see cref="T:Microsoft.ProgramSynthesis.Utils.Record"/>.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record.Equals(Microsoft.ProgramSynthesis.Utils.Record)">
            <summary>Returns a value indicating whether this instance is equal to a specified value.</summary>
            <param name="other">An instance to compare to this instance.</param>
            <returns>true if <paramref name="other"/> has the same value as this instance; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record.CompareTo(Microsoft.ProgramSynthesis.Utils.Record)">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:Microsoft.ProgramSynthesis.Utils.Record"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:Microsoft.ProgramSynthesis.Utils.Record"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>()</c>.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record.Create">
            <summary>Creates a new struct 0-record.</summary>
            <returns>A 0-record.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record.Create``1(``0)">
            <summary>Creates a new struct 1-record, or singleton.</summary>
            <typeparam name="T1">The type of the first component of the record.</typeparam>
            <param name="item1">The value of the first component of the record.</param>
            <returns>A 1-record (singleton) whose value is (item1).</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record.Create``2(``0,``1)">
            <summary>Creates a new struct 2-record, or pair.</summary>
            <typeparam name="T1">The type of the first component of the record.</typeparam>
            <typeparam name="T2">The type of the second component of the record.</typeparam>
            <param name="item1">The value of the first component of the record.</param>
            <param name="item2">The value of the second component of the record.</param>
            <returns>A 2-record (pair) whose value is (item1, item2).</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record.Create``3(``0,``1,``2)">
            <summary>Creates a new struct 3-record, or triple.</summary>
            <typeparam name="T1">The type of the first component of the record.</typeparam>
            <typeparam name="T2">The type of the second component of the record.</typeparam>
            <typeparam name="T3">The type of the third component of the record.</typeparam>
            <param name="item1">The value of the first component of the record.</param>
            <param name="item2">The value of the second component of the record.</param>
            <param name="item3">The value of the third component of the record.</param>
            <returns>A 3-record (triple) whose value is (item1, item2, item3).</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record.Create``4(``0,``1,``2,``3)">
            <summary>Creates a new struct 4-record, or quadruple.</summary>
            <typeparam name="T1">The type of the first component of the record.</typeparam>
            <typeparam name="T2">The type of the second component of the record.</typeparam>
            <typeparam name="T3">The type of the third component of the record.</typeparam>
            <typeparam name="T4">The type of the fourth component of the record.</typeparam>
            <param name="item1">The value of the first component of the record.</param>
            <param name="item2">The value of the second component of the record.</param>
            <param name="item3">The value of the third component of the record.</param>
            <param name="item4">The value of the fourth component of the record.</param>
            <returns>A 4-record (quadruple) whose value is (item1, item2, item3, item4).</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record.Create``5(``0,``1,``2,``3,``4)">
            <summary>Creates a new struct 5-record, or quinrecord.</summary>
            <typeparam name="T1">The type of the first component of the record.</typeparam>
            <typeparam name="T2">The type of the second component of the record.</typeparam>
            <typeparam name="T3">The type of the third component of the record.</typeparam>
            <typeparam name="T4">The type of the fourth component of the record.</typeparam>
            <typeparam name="T5">The type of the fifth component of the record.</typeparam>
            <param name="item1">The value of the first component of the record.</param>
            <param name="item2">The value of the second component of the record.</param>
            <param name="item3">The value of the third component of the record.</param>
            <param name="item4">The value of the fourth component of the record.</param>
            <param name="item5">The value of the fifth component of the record.</param>
            <returns>A 5-record (quinrecord) whose value is (item1, item2, item3, item4, item5).</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record.Create``6(``0,``1,``2,``3,``4,``5)">
            <summary>Creates a new struct 6-record, or sexrecord.</summary>
            <typeparam name="T1">The type of the first component of the record.</typeparam>
            <typeparam name="T2">The type of the second component of the record.</typeparam>
            <typeparam name="T3">The type of the third component of the record.</typeparam>
            <typeparam name="T4">The type of the fourth component of the record.</typeparam>
            <typeparam name="T5">The type of the fifth component of the record.</typeparam>
            <typeparam name="T6">The type of the sixth component of the record.</typeparam>
            <param name="item1">The value of the first component of the record.</param>
            <param name="item2">The value of the second component of the record.</param>
            <param name="item3">The value of the third component of the record.</param>
            <param name="item4">The value of the fourth component of the record.</param>
            <param name="item5">The value of the fifth component of the record.</param>
            <param name="item6">The value of the sixth component of the record.</param>
            <returns>A 6-record (sexrecord) whose value is (item1, item2, item3, item4, item5, item6).</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record.Create``7(``0,``1,``2,``3,``4,``5,``6)">
            <summary>Creates a new struct 7-record, or seprecord.</summary>
            <typeparam name="T1">The type of the first component of the record.</typeparam>
            <typeparam name="T2">The type of the second component of the record.</typeparam>
            <typeparam name="T3">The type of the third component of the record.</typeparam>
            <typeparam name="T4">The type of the fourth component of the record.</typeparam>
            <typeparam name="T5">The type of the fifth component of the record.</typeparam>
            <typeparam name="T6">The type of the sixth component of the record.</typeparam>
            <typeparam name="T7">The type of the seventh component of the record.</typeparam>
            <param name="item1">The value of the first component of the record.</param>
            <param name="item2">The value of the second component of the record.</param>
            <param name="item3">The value of the third component of the record.</param>
            <param name="item4">The value of the fourth component of the record.</param>
            <param name="item5">The value of the fifth component of the record.</param>
            <param name="item6">The value of the sixth component of the record.</param>
            <param name="item7">The value of the seventh component of the record.</param>
            <returns>A 7-record (seprecord) whose value is (item1, item2, item3, item4, item5, item6, item7).</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record.Create``8(``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>Creates a new struct 8-record, or ocrecord.</summary>
            <typeparam name="T1">The type of the first component of the record.</typeparam>
            <typeparam name="T2">The type of the second component of the record.</typeparam>
            <typeparam name="T3">The type of the third component of the record.</typeparam>
            <typeparam name="T4">The type of the fourth component of the record.</typeparam>
            <typeparam name="T5">The type of the fifth component of the record.</typeparam>
            <typeparam name="T6">The type of the sixth component of the record.</typeparam>
            <typeparam name="T7">The type of the seventh component of the record.</typeparam>
            <typeparam name="T8">The type of the eighth component of the record.</typeparam>
            <param name="item1">The value of the first component of the record.</param>
            <param name="item2">The value of the second component of the record.</param>
            <param name="item3">The value of the third component of the record.</param>
            <param name="item4">The value of the fourth component of the record.</param>
            <param name="item5">The value of the fifth component of the record.</param>
            <param name="item6">The value of the sixth component of the record.</param>
            <param name="item7">The value of the seventh component of the record.</param>
            <param name="item8">The value of the eighth component of the record.</param>
            <returns>An 8-record (octuple) whose value is (item1, item2, item3, item4, item5, item6, item7, item8).</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Record`1">
            <summary>Represents a 1-record, or singleton, as a value type.</summary>
            <typeparam name="T1">The type of the record's only component.</typeparam>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`1.Item1">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`1"/> instance's first component.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`1"/> value type.
            </summary>
            <param name="item1">The value of the record's first component.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`1.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`1"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`1"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`1.Equals(Microsoft.ProgramSynthesis.Utils.Record{`0})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`1"/>
            instance is equal to a specified <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`1"/>.
            </summary>
            <param name="other">The record to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified record; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its field
            is equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`1.CompareTo(Microsoft.ProgramSynthesis.Utils.Record{`0})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`1.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`1"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`1.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`1"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`1"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1)</c>,
            where <c>Item1</c> represents the value of <see cref="F:Microsoft.ProgramSynthesis.Utils.Record`1.Item1"/>. If the field is <see langword="null"/>,
            it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Record`2">
            <summary>
            Represents a 2-record, or pair, as a value type.
            </summary>
            <typeparam name="T1">The type of the record's first component.</typeparam>
            <typeparam name="T2">The type of the record's second component.</typeparam>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`2.Item1">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`2"/> instance's first component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`2.Item2">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`2"/> instance's second component.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`2.#ctor(`0,`1)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`2"/> value type.
            </summary>
            <param name="item1">The value of the record's first component.</param>
            <param name="item2">The value of the record's second component.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`2.Equals(System.Object)">
             <summary>
             Returns a value that indicates whether the current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`2"/> instance is equal to a specified object.
             </summary>
             <param name="obj">The object to compare with this instance.</param>
             <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            
             <remarks>
             The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
             <list type="bullet">
                 <item><description>It is a <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`2"/> value type.</description></item>
                 <item><description>Its components are of the same types as those of the current instance.</description></item>
                 <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
             </list>
             </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`2.Equals(Microsoft.ProgramSynthesis.Utils.Record{`0,`1})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`2"/> instance is equal to a specified <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`2"/>.
            </summary>
            <param name="other">The record to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified record; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`2.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
             <summary>
             Returns a value that indicates whether the current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`2"/> instance is equal to a specified object based on a specified comparison method.
             </summary>
             <param name="other">The object to compare with this instance.</param>
             <param name="comparer">An object that defines the method to use to evaluate whether the two objects are equal.</param>
             <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            
             <remarks>
             This member is an explicit interface member implementation. It can be used only when the
              <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`2"/> instance is cast to an <see cref="T:System.Collections.IStructuralEquatable"/> interface.
            
             The <see cref="M:System.Collections.IEqualityComparer.Equals(System.Object,System.Object)"/> implementation is called only if <c>other</c> is not <see langword="null"/>,
              and if it can be successfully cast (in C#) or converted (in Visual Basic) to a <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`2"/>
              whose components are of the same types as those of the current instance. The IStructuralEquatable.Equals(Object, IEqualityComparer) method
              first passes the <see cref="F:Microsoft.ProgramSynthesis.Utils.Record`2.Item1"/> values of the <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`2"/> objects to be compared to the
              <see cref="M:System.Collections.IEqualityComparer.Equals(System.Object,System.Object)"/> implementation. If this method call returns <see langword="true"/>, the method is
              called again and passed the <see cref="F:Microsoft.ProgramSynthesis.Utils.Record`2.Item2"/> values of the two <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`2"/> instances.
             </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`2.CompareTo(Microsoft.ProgramSynthesis.Utils.Record{`0,`1})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`2.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`2"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`2.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`2"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`2"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2)</c>,
            where <c>Item1</c> and <c>Item2</c> represent the values of the <see cref="F:Microsoft.ProgramSynthesis.Utils.Record`2.Item1"/>
            and <see cref="F:Microsoft.ProgramSynthesis.Utils.Record`2.Item2"/> fields. If either field value is <see langword="null"/>,
            it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Record`3">
            <summary>
            Represents a 3-record, or triple, as a value type.
            </summary>
            <typeparam name="T1">The type of the record's first component.</typeparam>
            <typeparam name="T2">The type of the record's second component.</typeparam>
            <typeparam name="T3">The type of the record's third component.</typeparam>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`3.Item1">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`3"/> instance's first component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`3.Item2">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`3"/> instance's second component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`3.Item3">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`3"/> instance's third component.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`3.#ctor(`0,`1,`2)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`3"/> value type.
            </summary>
            <param name="item1">The value of the record's first component.</param>
            <param name="item2">The value of the record's second component.</param>
            <param name="item3">The value of the record's third component.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`3.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`3"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`3"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`3.Equals(Microsoft.ProgramSynthesis.Utils.Record{`0,`1,`2})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`3"/>
            instance is equal to a specified <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`3"/>.
            </summary>
            <param name="other">The record to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified record; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`3.CompareTo(Microsoft.ProgramSynthesis.Utils.Record{`0,`1,`2})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`3.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`3"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`3.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`3"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`3"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Record`4">
            <summary>
            Represents a 4-record, or quadruple, as a value type.
            </summary>
            <typeparam name="T1">The type of the record's first component.</typeparam>
            <typeparam name="T2">The type of the record's second component.</typeparam>
            <typeparam name="T3">The type of the record's third component.</typeparam>
            <typeparam name="T4">The type of the record's fourth component.</typeparam>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`4.Item1">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`4"/> instance's first component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`4.Item2">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`4"/> instance's second component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`4.Item3">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`4"/> instance's third component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`4.Item4">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`4"/> instance's fourth component.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`4.#ctor(`0,`1,`2,`3)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`4"/> value type.
            </summary>
            <param name="item1">The value of the record's first component.</param>
            <param name="item2">The value of the record's second component.</param>
            <param name="item3">The value of the record's third component.</param>
            <param name="item4">The value of the record's fourth component.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`4.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`4"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`4"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`4.Equals(Microsoft.ProgramSynthesis.Utils.Record{`0,`1,`2,`3})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`4"/>
            instance is equal to a specified <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`4"/>.
            </summary>
            <param name="other">The record to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified record; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`4.CompareTo(Microsoft.ProgramSynthesis.Utils.Record{`0,`1,`2,`3})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`4.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`4"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`4.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`4"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`4"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Record`5">
            <summary>
            Represents a 5-record, or quinrecord, as a value type.
            </summary>
            <typeparam name="T1">The type of the record's first component.</typeparam>
            <typeparam name="T2">The type of the record's second component.</typeparam>
            <typeparam name="T3">The type of the record's third component.</typeparam>
            <typeparam name="T4">The type of the record's fourth component.</typeparam>
            <typeparam name="T5">The type of the record's fifth component.</typeparam>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`5.Item1">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`5"/> instance's first component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`5.Item2">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`5"/> instance's second component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`5.Item3">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`5"/> instance's third component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`5.Item4">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`5"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`5.Item5">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`5"/> instance's fifth component.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`5.#ctor(`0,`1,`2,`3,`4)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`5"/> value type.
            </summary>
            <param name="item1">The value of the record's first component.</param>
            <param name="item2">The value of the record's second component.</param>
            <param name="item3">The value of the record's third component.</param>
            <param name="item4">The value of the record's fourth component.</param>
            <param name="item5">The value of the record's fifth component.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`5.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`5"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`5"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`5.Equals(Microsoft.ProgramSynthesis.Utils.Record{`0,`1,`2,`3,`4})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`5"/>
            instance is equal to a specified <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`5"/>.
            </summary>
            <param name="other">The record to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified record; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`5.CompareTo(Microsoft.ProgramSynthesis.Utils.Record{`0,`1,`2,`3,`4})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`5.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`5"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`5.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`5"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`5"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Record`6">
            <summary>
            Represents a 6-record, or sixrecord, as a value type.
            </summary>
            <typeparam name="T1">The type of the record's first component.</typeparam>
            <typeparam name="T2">The type of the record's second component.</typeparam>
            <typeparam name="T3">The type of the record's third component.</typeparam>
            <typeparam name="T4">The type of the record's fourth component.</typeparam>
            <typeparam name="T5">The type of the record's fifth component.</typeparam>
            <typeparam name="T6">The type of the record's sixth component.</typeparam>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`6.Item1">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`6"/> instance's first component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`6.Item2">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`6"/> instance's second component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`6.Item3">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`6"/> instance's third component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`6.Item4">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`6"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`6.Item5">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`6"/> instance's fifth component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`6.Item6">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`6"/> instance's sixth component.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`6.#ctor(`0,`1,`2,`3,`4,`5)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`6"/> value type.
            </summary>
            <param name="item1">The value of the record's first component.</param>
            <param name="item2">The value of the record's second component.</param>
            <param name="item3">The value of the record's third component.</param>
            <param name="item4">The value of the record's fourth component.</param>
            <param name="item5">The value of the record's fifth component.</param>
            <param name="item6">The value of the record's sixth component.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`6.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`6"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`6"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`6.Equals(Microsoft.ProgramSynthesis.Utils.Record{`0,`1,`2,`3,`4,`5})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`6"/>
            instance is equal to a specified <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`6"/>.
            </summary>
            <param name="other">The record to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified record; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`6.CompareTo(Microsoft.ProgramSynthesis.Utils.Record{`0,`1,`2,`3,`4,`5})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`6.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`6"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`6.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`6"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`6"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5, Item6)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Record`7">
            <summary>
            Represents a 7-record, or senrecord, as a value type.
            </summary>
            <typeparam name="T1">The type of the record's first component.</typeparam>
            <typeparam name="T2">The type of the record's second component.</typeparam>
            <typeparam name="T3">The type of the record's third component.</typeparam>
            <typeparam name="T4">The type of the record's fourth component.</typeparam>
            <typeparam name="T5">The type of the record's fifth component.</typeparam>
            <typeparam name="T6">The type of the record's sixth component.</typeparam>
            <typeparam name="T7">The type of the record's seventh component.</typeparam>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`7.Item1">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`7"/> instance's first component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`7.Item2">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`7"/> instance's second component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`7.Item3">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`7"/> instance's third component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`7.Item4">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`7"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`7.Item5">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`7"/> instance's fifth component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`7.Item6">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`7"/> instance's sixth component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`7.Item7">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`7"/> instance's seventh component.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`7.#ctor(`0,`1,`2,`3,`4,`5,`6)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`7"/> value type.
            </summary>
            <param name="item1">The value of the record's first component.</param>
            <param name="item2">The value of the record's second component.</param>
            <param name="item3">The value of the record's third component.</param>
            <param name="item4">The value of the record's fourth component.</param>
            <param name="item5">The value of the record's fifth component.</param>
            <param name="item6">The value of the record's sixth component.</param>
            <param name="item7">The value of the record's seventh component.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`7.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`7"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`7"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`7.Equals(Microsoft.ProgramSynthesis.Utils.Record{`0,`1,`2,`3,`4,`5,`6})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`7"/>
            instance is equal to a specified <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`7"/>.
            </summary>
            <param name="other">The record to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified record; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`7.CompareTo(Microsoft.ProgramSynthesis.Utils.Record{`0,`1,`2,`3,`4,`5,`6})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`7.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`7"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`7.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`7"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`7"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5, Item6, Item7)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Record`8">
            <summary>
            Represents an 8-record, or octuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the record's first component.</typeparam>
            <typeparam name="T2">The type of the record's second component.</typeparam>
            <typeparam name="T3">The type of the record's third component.</typeparam>
            <typeparam name="T4">The type of the record's fourth component.</typeparam>
            <typeparam name="T5">The type of the record's fifth component.</typeparam>
            <typeparam name="T6">The type of the record's sixth component.</typeparam>
            <typeparam name="T7">The type of the record's seventh component.</typeparam>
            <typeparam name="TRest">The type of the record's eighth component.</typeparam>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`8.Item1">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`8"/> instance's first component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`8.Item2">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`8"/> instance's second component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`8.Item3">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`8"/> instance's third component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`8.Item4">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`8"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`8.Item5">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`8"/> instance's fifth component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`8.Item6">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`8"/> instance's sixth component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`8.Item7">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`8"/> instance's seventh component.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Record`8.Rest">
            <summary>
            The current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`8"/> instance's eighth component.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`8.#ctor(`0,`1,`2,`3,`4,`5,`6,`7)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`8"/> value type.
            </summary>
            <param name="item1">The value of the record's first component.</param>
            <param name="item2">The value of the record's second component.</param>
            <param name="item3">The value of the record's third component.</param>
            <param name="item4">The value of the record's fourth component.</param>
            <param name="item5">The value of the record's fifth component.</param>
            <param name="item6">The value of the record's sixth component.</param>
            <param name="item7">The value of the record's seventh component.</param>
            <param name="rest">The value of the record's eight component.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`8.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`8"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`8"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`8.Equals(Microsoft.ProgramSynthesis.Utils.Record{`0,`1,`2,`3,`4,`5,`6,`7})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`8"/>
            instance is equal to a specified <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`8"/>.
            </summary>
            <param name="other">The record to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified record; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`8.CompareTo(Microsoft.ProgramSynthesis.Utils.Record{`0,`1,`2,`3,`4,`5,`6,`7})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`8.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`8"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Record`8.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`8"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`8"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5, Item6, Item7, Rest)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.RecordExtensions">
            <summary>
            Provides extension methods for <see cref="T:Microsoft.ProgramSynthesis.Utils.Record"/> instances to interop with C# tuples features (deconstruction syntax, converting from and to <see cref="T:Microsoft.ProgramSynthesis.Utils.Record"/>).
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RecordExtensions.Deconstruct``1(Microsoft.ProgramSynthesis.Utils.Record{``0},``0@)">
            <summary>
            Deconstruct a properly nested <see cref="T:Microsoft.ProgramSynthesis.Utils.Record"/> with 1 elements.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RecordExtensions.Deconstruct``2(Microsoft.ProgramSynthesis.Utils.Record{``0,``1},``0@,``1@)">
            <summary>
            Deconstruct a properly nested <see cref="T:Microsoft.ProgramSynthesis.Utils.Record"/> with 2 elements.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RecordExtensions.Deconstruct``3(Microsoft.ProgramSynthesis.Utils.Record{``0,``1,``2},``0@,``1@,``2@)">
            <summary>
            Deconstruct a properly nested <see cref="T:Microsoft.ProgramSynthesis.Utils.Record"/> with 3 elements.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RecordExtensions.Deconstruct``4(Microsoft.ProgramSynthesis.Utils.Record{``0,``1,``2,``3},``0@,``1@,``2@,``3@)">
            <summary>
            Deconstruct a properly nested <see cref="T:Microsoft.ProgramSynthesis.Utils.Record"/> with 4 elements.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RecordExtensions.Deconstruct``5(Microsoft.ProgramSynthesis.Utils.Record{``0,``1,``2,``3,``4},``0@,``1@,``2@,``3@,``4@)">
            <summary>
            Deconstruct a properly nested <see cref="T:Microsoft.ProgramSynthesis.Utils.Record"/> with 5 elements.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RecordExtensions.Deconstruct``6(Microsoft.ProgramSynthesis.Utils.Record{``0,``1,``2,``3,``4,``5},``0@,``1@,``2@,``3@,``4@,``5@)">
            <summary>
            Deconstruct a properly nested <see cref="T:Microsoft.ProgramSynthesis.Utils.Record"/> with 6 elements.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RecordExtensions.Deconstruct``7(Microsoft.ProgramSynthesis.Utils.Record{``0,``1,``2,``3,``4,``5,``6},``0@,``1@,``2@,``3@,``4@,``5@,``6@)">
            <summary>
            Deconstruct a properly nested <see cref="T:Microsoft.ProgramSynthesis.Utils.Record"/> with 7 elements.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RecordExtensions.Deconstruct``8(Microsoft.ProgramSynthesis.Utils.Record{``0,``1,``2,``3,``4,``5,``6,Microsoft.ProgramSynthesis.Utils.Record{``7}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@)">
            <summary>
            Deconstruct a properly nested <see cref="T:Microsoft.ProgramSynthesis.Utils.Record"/> with 8 elements.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RecordExtensions.Deconstruct``9(Microsoft.ProgramSynthesis.Utils.Record{``0,``1,``2,``3,``4,``5,``6,Microsoft.ProgramSynthesis.Utils.Record{``7,``8}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@,``8@)">
            <summary>
            Deconstruct a properly nested <see cref="T:Microsoft.ProgramSynthesis.Utils.Record"/> with 9 elements.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RecordExtensions.Deconstruct``10(Microsoft.ProgramSynthesis.Utils.Record{``0,``1,``2,``3,``4,``5,``6,Microsoft.ProgramSynthesis.Utils.Record{``7,``8,``9}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@,``8@,``9@)">
            <summary>
            Deconstruct a properly nested <see cref="T:Microsoft.ProgramSynthesis.Utils.Record"/> with 10 elements.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RecordExtensions.Deconstruct``11(Microsoft.ProgramSynthesis.Utils.Record{``0,``1,``2,``3,``4,``5,``6,Microsoft.ProgramSynthesis.Utils.Record{``7,``8,``9,``10}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@,``8@,``9@,``10@)">
            <summary>
            Deconstruct a properly nested <see cref="T:Microsoft.ProgramSynthesis.Utils.Record"/> with 11 elements.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RecordExtensions.Deconstruct``12(Microsoft.ProgramSynthesis.Utils.Record{``0,``1,``2,``3,``4,``5,``6,Microsoft.ProgramSynthesis.Utils.Record{``7,``8,``9,``10,``11}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@,``8@,``9@,``10@,``11@)">
            <summary>
            Deconstruct a properly nested <see cref="T:Microsoft.ProgramSynthesis.Utils.Record"/> with 12 elements.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RecordExtensions.Deconstruct``13(Microsoft.ProgramSynthesis.Utils.Record{``0,``1,``2,``3,``4,``5,``6,Microsoft.ProgramSynthesis.Utils.Record{``7,``8,``9,``10,``11,``12}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@,``8@,``9@,``10@,``11@,``12@)">
            <summary>
            Deconstruct a properly nested <see cref="T:Microsoft.ProgramSynthesis.Utils.Record"/> with 13 elements.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RecordExtensions.Deconstruct``14(Microsoft.ProgramSynthesis.Utils.Record{``0,``1,``2,``3,``4,``5,``6,Microsoft.ProgramSynthesis.Utils.Record{``7,``8,``9,``10,``11,``12,``13}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@,``8@,``9@,``10@,``11@,``12@,``13@)">
            <summary>
            Deconstruct a properly nested <see cref="T:Microsoft.ProgramSynthesis.Utils.Record"/> with 14 elements.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RecordExtensions.Deconstruct``15(Microsoft.ProgramSynthesis.Utils.Record{``0,``1,``2,``3,``4,``5,``6,Microsoft.ProgramSynthesis.Utils.Record{``7,``8,``9,``10,``11,``12,``13,Microsoft.ProgramSynthesis.Utils.Record{``14}}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@,``8@,``9@,``10@,``11@,``12@,``13@,``14@)">
            <summary>
            Deconstruct a properly nested <see cref="T:Microsoft.ProgramSynthesis.Utils.Record"/> with 15 elements.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RecordExtensions.Deconstruct``16(Microsoft.ProgramSynthesis.Utils.Record{``0,``1,``2,``3,``4,``5,``6,Microsoft.ProgramSynthesis.Utils.Record{``7,``8,``9,``10,``11,``12,``13,Microsoft.ProgramSynthesis.Utils.Record{``14,``15}}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@,``8@,``9@,``10@,``11@,``12@,``13@,``14@,``15@)">
            <summary>
            Deconstruct a properly nested <see cref="T:Microsoft.ProgramSynthesis.Utils.Record"/> with 16 elements.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RecordExtensions.Deconstruct``17(Microsoft.ProgramSynthesis.Utils.Record{``0,``1,``2,``3,``4,``5,``6,Microsoft.ProgramSynthesis.Utils.Record{``7,``8,``9,``10,``11,``12,``13,Microsoft.ProgramSynthesis.Utils.Record{``14,``15,``16}}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@,``8@,``9@,``10@,``11@,``12@,``13@,``14@,``15@,``16@)">
            <summary>
            Deconstruct a properly nested <see cref="T:Microsoft.ProgramSynthesis.Utils.Record"/> with 17 elements.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RecordExtensions.Deconstruct``18(Microsoft.ProgramSynthesis.Utils.Record{``0,``1,``2,``3,``4,``5,``6,Microsoft.ProgramSynthesis.Utils.Record{``7,``8,``9,``10,``11,``12,``13,Microsoft.ProgramSynthesis.Utils.Record{``14,``15,``16,``17}}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@,``8@,``9@,``10@,``11@,``12@,``13@,``14@,``15@,``16@,``17@)">
            <summary>
            Deconstruct a properly nested <see cref="T:Microsoft.ProgramSynthesis.Utils.Record"/> with 18 elements.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RecordExtensions.Deconstruct``19(Microsoft.ProgramSynthesis.Utils.Record{``0,``1,``2,``3,``4,``5,``6,Microsoft.ProgramSynthesis.Utils.Record{``7,``8,``9,``10,``11,``12,``13,Microsoft.ProgramSynthesis.Utils.Record{``14,``15,``16,``17,``18}}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@,``8@,``9@,``10@,``11@,``12@,``13@,``14@,``15@,``16@,``17@,``18@)">
            <summary>
            Deconstruct a properly nested <see cref="T:Microsoft.ProgramSynthesis.Utils.Record"/> with 19 elements.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RecordExtensions.Deconstruct``20(Microsoft.ProgramSynthesis.Utils.Record{``0,``1,``2,``3,``4,``5,``6,Microsoft.ProgramSynthesis.Utils.Record{``7,``8,``9,``10,``11,``12,``13,Microsoft.ProgramSynthesis.Utils.Record{``14,``15,``16,``17,``18,``19}}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@,``8@,``9@,``10@,``11@,``12@,``13@,``14@,``15@,``16@,``17@,``18@,``19@)">
            <summary>
            Deconstruct a properly nested <see cref="T:Microsoft.ProgramSynthesis.Utils.Record"/> with 20 elements.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RecordExtensions.Deconstruct``21(Microsoft.ProgramSynthesis.Utils.Record{``0,``1,``2,``3,``4,``5,``6,Microsoft.ProgramSynthesis.Utils.Record{``7,``8,``9,``10,``11,``12,``13,Microsoft.ProgramSynthesis.Utils.Record{``14,``15,``16,``17,``18,``19,``20}}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@,``8@,``9@,``10@,``11@,``12@,``13@,``14@,``15@,``16@,``17@,``18@,``19@,``20@)">
            <summary>
            Deconstruct a properly nested <see cref="T:Microsoft.ProgramSynthesis.Utils.Record"/> with 21 elements.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.AssemblyResourceUtils.LoadResourceFromAssembly(System.Reflection.Assembly,System.String)">
            <summary>
                Helper function to load resources from assemblies.
            </summary>
            <param name="assembly">The assembly to load from.</param>
            <param name="resourceName">The fully qualified name of the resource to load.</param>
            <returns>Text from the resource.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.AssemblyResourceUtils.LoadResourceBytesFromAssembly(System.Reflection.Assembly,System.String)">
            <summary>
                Helper function to load resources from assemblies.
            </summary>
            <param name="assembly">The assembly to load from.</param>
            <param name="resourceName">The fully qualified name of the resource to load.</param>
            <returns>Text from the resource.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.AssemblyResourceUtils.LoadResourceStreamFromAssembly(System.Reflection.Assembly,System.String)">
            <summary>
                Helper function to fetch a resource stream from an assembly or throw an exception if it doesn't exist.
            </summary>
            <param name="assembly">The assembly to load from.</param>
            <param name="resourceName">The fully qualified name of the resource to load.</param>
            <exception cref="T:System.Resources.MissingManifestResourceException">Thrown when resource with given name does not exist.</exception>
            <returns>Stream for the resource</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.AssemblyResourceUtils.TryLoadResourceFromAssembly(System.Reflection.Assembly,System.String,System.String@)">
            <summary>
                Helper function to try to load resources from assemblies.
            </summary>
            <param name="assembly">The assembly to load from.</param>
            <param name="resourceName">The fully qualified name of the resource to load.</param>
            <param name="resourceContent">The content of the resource, if successful.</param>
            <returns>Whether the load was successful.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.AssemblyResourceUtils.LoadJsonResourceFromAssembly``1(System.Reflection.Assembly,System.String)">
            <summary>
                Helper function to fetch a json serialized resource from an assembly or throw an exception if it doesn't exist.
            </summary>
            <typeparam name="T">Resource type.</typeparam>
            <param name="assembly">The assembly to load from.</param>
            <param name="resourceName">The fully qualified name of the resource to load.</param>
            <exception cref="T:System.Resources.MissingManifestResourceException">Thrown when resource with given name does not exist.</exception>
            <returns>Deserialized object.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.AssemblyResourceUtils.EnumerateResources(System.Reflection.Assembly,System.String,System.String)">
            <summary>
                Helper function to enumerate resources that start with <paramref name="prefix" /> and end with
                <paramref name="suffix" />.
            </summary>
            <param name="assembly">The assembly to load from.</param>
            <param name="prefix">The resource prefix.</param>
            <param name="suffix">The resource suffix.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.AssemblyResourceUtils.ResourceExists(System.Reflection.Assembly,System.String)">
            <summary>
                Returns true if <paramref name="assembly"/> contains a resource named <paramref name="resourceName"/>.
            </summary>
            <param name="assembly">Assembly to look in.</param>
            <param name="resourceName">Resource to look for.</param>
            <returns>True if <paramref name="resourceName"/> is available in <paramref name="assembly"/>.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.AssemblyTypeUtils">
            <summary>
                A helper class to retrieve <see cref="T:System.Type" />s defined in an <see cref="T:System.Reflection.Assembly" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.AssemblyTypeUtils.AllTypesInAssembly(System.Type)">
            <summary>
                Retrieves all the types in the <see cref="T:System.Reflection.Assembly" /> where <paramref name="type" /> is defined.
            </summary>
            <param name="type">
                A <see cref="T:System.Type" /> defined in the <see cref="T:System.Reflection.Assembly" />from which all types are to be
                retrieved.
            </param>
            <returns>
                A sequence of <see cref="T:System.Reflection.TypeInfo" />s for <see cref="T:System.Type" />s that are defined in the
                <see cref="T:System.Reflection.Assembly" /> where <paramref name="type" /> is defined.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.AssemblyTypeUtils.AllNonAbstractTypesInAssembly(System.Type)">
            <summary>
                Retrieves all non abstract types in the <see cref="T:System.Reflection.Assembly" /> where <paramref name="type" /> is defined.
            </summary>
            <param name="type">
                A <see cref="T:System.Type" /> defined in the <see cref="T:System.Reflection.Assembly" />from which all non-abstract types are to
                be retrieved.
            </param>
            <returns>
                A sequence of <see cref="T:System.Reflection.TypeInfo" />s for non-abstract <see cref="T:System.Type" />s that are defined in the
                <see cref="T:System.Reflection.Assembly" /> where <paramref name="type" /> is defined.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.AssemblyTypeUtils.AllSubTypesInAssembly(System.Type)">
            <summary>
                Retrieves all types deriving from <paramref name="type" /> in the <see cref="T:System.Reflection.Assembly" /> where
                <paramref name="type" /> is defined.
            </summary>
            <param name="type">
                A <see cref="T:System.Type" /> defined in the <see cref="T:System.Reflection.Assembly" />from which all derived types of
                <paramref name="type" /> are to be retrieved.
            </param>
            <returns>
                A sequence of <see cref="T:System.Reflection.TypeInfo" />s for <see cref="T:System.Type" />s deriving from <paramref name="type" /> that
                are defined in the <see cref="T:System.Reflection.Assembly" /> where <paramref name="type" /> is defined.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.AssemblyTypeUtils.AllNonAbstractSubTypesInAssembly(System.Type)">
            <summary>
                Retrieves all types deriving from <paramref name="type" />, which are not abstract, in the <see cref="T:System.Reflection.Assembly" />
                where <paramref name="type" /> is defined.
            </summary>
            <param name="type">
                A <see cref="T:System.Type" /> defined in the <see cref="T:System.Reflection.Assembly" />from which all non-abstract derived
                types of <paramref name="type" /> are to be retrieved.
            </param>
            <returns>
                A sequence of <see cref="T:System.Reflection.TypeInfo" />s for non-abstract <see cref="T:System.Type" />s deriving from
                <paramref name="type" /> that are defined in the <see cref="T:System.Reflection.Assembly" /> where <paramref name="type" /> is defined.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.AssemblyTypeUtils.AsType(System.Collections.Generic.IEnumerable{System.Reflection.TypeInfo})">
            <summary>
                Calls <see cref="M:System.Reflection.TypeInfo.AsType"/> on a sequence of <see cref="T:System.Reflection.TypeInfo"/>s, yielding a sequence of <see cref="T:System.Type"/>s.
            </summary>
            <param name="typeInfos">The sequence of <see cref="T:System.Reflection.TypeInfo"/>s.</param>
            <returns>A sequence of <see cref="T:System.Type"/>s.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.AsyncFileWriter">
            <summary>
            Class to append lines in a file using separate thread for performance. Typically used for logging.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.AsyncFileWriter.#ctor(System.String,System.IO.FileMode,System.IO.FileShare)">
            <summary>
                Initializes an instance of AsyncFileWriter with specified file path, creation mode and share options
                across processes.
            </summary>
            <param name="fileName">Relative or absolute path for a writable file.</param>
            <param name="fileMode">Specifies how to open or create the file.</param>
            <param name="fileShare">A constant that determines how the file will be shared by processes.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.AsyncFileWriter.WriteLine(System.String)">
            <summary>
                Writes a line in the specified file in another thread.
            </summary>
            <param name="text">Line string to be written.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.AsyncFileWriter.Write(System.String)">
            <summary>
                Writes text in the specified file in another thread.
            </summary>
            <param name="text">String to be written to the file.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.AsyncFileWriter.Dispose">
            <summary>
                Waits for current task to complete. Then releases all resourses used.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.BitArrayUtils.HasIntersectionWith(System.Collections.BitArray,System.Collections.BitArray)">
            <summary>
               Returns true if and only if <paramref name="a" /> and
               <paramref name="b"/> have at least one index commonly set
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Bucket">
            <summary>
                A class implementing a <see cref="T:Microsoft.ProgramSynthesis.Utils.Bucket" />. A <see cref="T:Microsoft.ProgramSynthesis.Utils.Bucket" /> is used to partition a universe into
                equivalence classes according to a lazily constructed equivalence relation.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Bucket.Id">
            <summary>
                The identity of this bucket.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Bucket.HashCode">
            <summary>
                The hashcode corresponding to objects associated with this bucket.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Bucket.#ctor(System.Int64,System.Int32)">
            <summary>
                Constructs a <see cref="T:Microsoft.ProgramSynthesis.Utils.Bucket" /> object.
            </summary>
            <param name="id">The identity of this bucket.</param>
            <param name="hashCode">The hash code corresponding to objects associated with this bucket.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Bucket.Equals(Microsoft.ProgramSynthesis.Utils.Bucket)">
            <summary>Indicates whether the current object is equal to another object of the same type.</summary>
            <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Bucket.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
            <returns>true if the specified object  is equal to the current object; otherwise, false.</returns>
            <param name="other">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Bucket.Merge(Microsoft.ProgramSynthesis.Utils.Bucket)">
            <summary>
                Merge <paramref name="other" /> and <code>this</code>, so that <code>this.Equals(other) is true.</code>.
            </summary>
            <param name="other">The <see cref="T:Microsoft.ProgramSynthesis.Utils.Bucket" /> to merge with this.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Bucket.GetHashCode">
            <summary>Serves as the default hash function. </summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.ICachedEquatable`1">
            <summary>
                An interface that declares that a type supports cached equality comparisons.
            </summary>
            <typeparam name="T">An <see cref="T:System.IEquatable`1" /> for which cached equality comparisons are desired.</typeparam>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.CachedObjectEquality`1">
            <summary>
                A cached object equality comparer.
            </summary>
            <typeparam name="T">The type of the objects that are required to be checked for equality.</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.CachedObjectEquality`1.Instance">
            <summary>
                The singleton instance of <see cref="T:Microsoft.ProgramSynthesis.Utils.CachedObjectEquality`1" />
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CachedObjectEquality`1.#ctor">
            <summary>
                Constructs an instance of <see cref="T:Microsoft.ProgramSynthesis.Utils.CachedObjectEquality`1" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CachedObjectEquality`1.Clear">
            <summary>
                Clears cached object equality comparer.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CachedObjectEquality`1.IsEqual(`0,`0)">
            <summary>
                Checks if two objects <paramref name="obj0" /> and <paramref name="obj1" /> are equal.
            </summary>
            <param name="obj0">The first object.</param>
            <param name="obj1">The second object.</param>
            <returns><code>true</code> iff <paramref name="obj0" /> is equal to <paramref name="obj1" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CachedObjectEquality`1.Equals(`0,`0)">
            <summary>Determines whether the specified objects are equal.</summary>
            <returns>true if the specified objects are equal; otherwise, false.</returns>
            <param name="x">
                The first object to compare.
            </param>
            <param name="y">
                The second object to compare.
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CachedObjectEquality`1.GetHashCode(`0)">
            <summary>Returns a hash code for the specified object.</summary>
            <returns>A hash code for the specified object.</returns>
            <param name="obj">The <see cref="T:System.Object" /> for which a hash code is to be returned.</param>
            <exception cref="T:System.ArgumentNullException">
                The type of <paramref name="obj" /> is a reference type and
                <paramref name="obj" /> is null.
            </exception>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Caching.CacheUtils">
            <summary>
                Helper functions for caches.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.CacheUtils.LookupOrCompute``3(Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache{``0,``1,``2},``0,System.Func{``0,``1})">
            <summary>
                Looks up a value in a cache or computes it if not present.
            </summary>
            <typeparam name="TKey">The key type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
            <typeparam name="TCache">The type of the cache.</typeparam>
            <param name="cache">The cache.</param>
            <param name="key">The key.</param>
            <param name="compute">The computation to produce the value if one was not present.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.CacheUtils.LookupOrCreateValue``3(Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache{``0,``1,``2},``0)">
            <summary>
                Looks up a key in the cache, returns the existing value if <paramref name="key"/> is mapped in the cache. Otherwise, creates a
                value, using the default constructor, maps the value to <paramref name="key"/> and returns it.
            </summary>
            <typeparam name="TKey">The key type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
            <typeparam name="TCache">The cache type.</typeparam>
            <param name="cache">The cache.</param>
            <param name="key">The key to lookup.</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Caching.CloneableCache`3">
            <summary>
                A helper abstract class that provides sane default implementations of some methods in
                <see cref="T:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache" />.
            </summary>
            <typeparam name="TKey">The type of the keys in the cache.</typeparam>
            <typeparam name="TValue">The type of the values in the cache.</typeparam>
            <typeparam name="TCache">The type implementing this abstract base class.</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.CloneableCache`3.Item(`0)">
            <summary>
                Retrieves the value associate with <paramref name="key" /> if one exists,
                raises <see cref="T:System.Collections.Generic.KeyNotFoundException" /> otherwise.
            </summary>
            <param name="key">The key to lookup.</param>
            <returns>The value mapped to the key, if one exists.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.CloneableCache`3.Keys">
            <summary>
                The set of keys in the cache.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.CloneableCache`3.Values">
            <summary>
                The values in the cache.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.CloneableCache`3.Mappings">
            <summary>
                All the mappings in the cache.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.CloneableCache`3.GetOrAdd(`0,System.Func{`0,`1})">
            <summary>
                Adds a key/value pair to the cache by using the specified function, if the key does not already exist.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="insertValueFunc">Function mapping key to inserted value.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.CloneableCache`3.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})">
            <summary>
                Uses the specified functions to add a key/value pair to the cache if the key does not already exist, or
                to update a key/value pair in the cache if the key already exists.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="insertValueFunc">Function mapping key to inserted value.</param>
            <param name="updateValueFunc">Function mapping key and existing value to new value.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.CloneableCache`3.Add(`0,`1)">
            <summary>
                Adds a new mapping to the cache. Raises <see cref="T:System.InvalidOperationException" /> if <paramref name="key" /> has
                already been mapped to a value in the cache.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="value">The value for the mapping.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.CloneableCache`3.Replace(`0,`1,`1@)">
            <summary>
                Adds a new mapping to the cache, or replaces the existing value that <paramref name="key" /> is mapped to.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="value">The value for the mapping.</param>
            <param name="oldValue">
                An output parameter that is set to the old value that <paramref name="key" /> was mapped to, if
                any.
            </param>
            <returns>
                <c>true</c> is <paramref name="key" /> was mapped to a value in the cache before this call, <c>false</c>
                otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.CloneableCache`3.Remove(`0,`1@)">
            <summary>
                Removes a mapping from the cache.
            </summary>
            <param name="key">The key whose mapping is to be removed.</param>
            <param name="removedValue">The value that <paramref name="key" /> was mapped to in the cache, if any.</param>
            <returns><c>true</c> if <paramref name="key" /> was mapped in the cache, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.CloneableCache`3.Lookup(`0,`1@)">
            <summary>
                Looks up a mapping in the cache.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="value">An output parameter that contains the value that <paramref name="key" /> was mapped to, if any.</param>
            <returns><c>true</c> if <paramref name="key" /> has been mapped to a value in the cache, <c>false</c> otherwise.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.CloneableCache`3.KeyCloner">
            <summary>
                Clones keys.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.CloneableCache`3.ValueCloner">
            <summary>
                Clones values.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.CloneableCache`3.EqualityComparer">
            <summary>
                The equality comparer to use.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.CloneableCache`3.ShallowClone">
            <summary>
                Clones the cache. All references to keys and values are copied over to the cloned cache.
            </summary>
            <returns>A shallow clone of this cache.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.CloneableCache`3.Microsoft#ProgramSynthesis#Utils#Caching#ICloneableCache#ShallowClone">
            <summary>
                Clones the cache. All references to keys and values are copied over to the cloned cache.
            </summary>
            <returns>A shallow clone of this cache.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.CloneableCache`3.DeepClone">
            <summary>
                Performs a deep clone of the cache. The keys and values in the cloned cache are cloned by applying
                <see cref="P:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache`3.KeyCloner" /> and
                <see cref="P:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache`3.ValueCloner" /> on the keys and values respectively.
            </summary>
            <returns>A deep clone of this cache.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.CloneableCache`3.Microsoft#ProgramSynthesis#Utils#Caching#ICloneableCache#DeepClone">
            <summary>
                Performs a deep clone of the cache.
            </summary>
            <returns>A deep clone of this cache.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.CloneableCache`3.Count">
            <summary>
                The number of mappings in the cache.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.CloneableCache`3.Clear">
            <summary>
                Clears the contents of this cache.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.CloneableCache`3.CloneWithCurrentCacheState">
            <summary>
                Returns a clone of the object with a snapshot/copy of the cache state before the call.
            </summary>
            <returns>A clone of <c>this</c> object.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.CloneableCache`3.ClearCaches">
            <summary>
                Clears all the cached state in <c>this</c> object.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.CloneableCache`3.Microsoft#ProgramSynthesis#Utils#Caching#ICachefulObject#CloneWithCurrentCacheState">
            <summary>
                Returns a clone of the object with a snapshot/copy of the cache state before the call.
                The object returned will be of the same type as <c>this</c> object, and can be safely
                cast.
            </summary>
            <returns>A clone of <c>this</c> object.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentIntegerKeyedCache`1">
            <summary>
                A concurrent, bounded size cloneable cache specialized for integer keys.
                The bound on the size can be specified during construction.
                The cache is backed by an array, and is thus unsuitable for
                sparsely populated caches.
                Use an <see cref="T:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedCache`2" /> for sparsely
                populated integer keyed caches.
            </summary>
            <typeparam name="TValue">The type of the values mapped by this cache.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentIntegerKeyedCache`1.#ctor(System.UInt32,System.Func{`0,`0})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentIntegerKeyedCache`1.Lookup(System.Int32,`0@)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentIntegerKeyedCache`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentIntegerKeyedCache`1.ShallowClone">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentIntegerKeyedCache`1.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentIntegerKeyedCache`1.GetOrAdd(System.Int32,System.Func{System.Int32,`0})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentIntegerKeyedCache`1.AddOrUpdate(System.Int32,System.Func{System.Int32,`0},System.Func{System.Int32,`0,`0})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentIntegerKeyedCache`1.Add(System.Int32,`0)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentIntegerKeyedCache`1.Replace(System.Int32,`0,`0@)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentIntegerKeyedCache`1.Remove(System.Int32,`0@)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentLruCache`2">
            <summary>
                A concurrent LRU cache that maps values of type <typeparamref name="TKey" /> to values of type
                <typeparamref name="TValue" />.
            </summary>
            <typeparam name="TKey">The type of the key used to lookup values in the cache.</typeparam>
            <typeparam name="TValue">The type of the values stored in the cache.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentLruCache`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0},System.Func{`0,`0},System.Func{`1,`1})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentLruCache`2.Remove(`0,`1@)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentLruCache`2.Lookup(`0,`1@)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentLruCache`2.ShallowClone">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentLruCache`2.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentLruCache`2.GetOrAdd(`0,System.Func{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentLruCache`2.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentLruCache`2.Add(`0,`1)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentLruCache`2.Replace(`0,`1,`1@)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentLruCache`2.Clear">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentUnboundedCache`2">
            <summary>
                A concurrent unbounded cache from <typeparamref name="TKey"/> to <typeparamref name="TValue"/>.
            </summary>
            <typeparam name="TKey">The key type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentUnboundedCache`2.#ctor">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentUnboundedCache`2.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Func{`0,`0},System.Func{`1,`1})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentUnboundedCache`2.GetOrAdd(`0,System.Func{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentUnboundedCache`2.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentUnboundedCache`2.Lookup(`0,`1@)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentUnboundedCache`2.ShallowClone">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentUnboundedCache`2.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentUnboundedCache`2.Add(`0,`1)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentUnboundedCache`2.Replace(`0,`1,`1@)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ConcurrentUnboundedCache`2.Remove(`0,`1@)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Caching.ICachefulObject">
            <summary>
                An interface for cloneable objects that have internal caches.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ICachefulObject.CloneWithCurrentCacheState">
            <summary>
                Returns a clone of the object with a snapshot/copy of the cache state before the call.
                The object returned will be of the same type as <c>this</c> object, and can be safely
                cast.
            </summary>
            <returns>A clone of <c>this</c> object.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ICachefulObject.ClearCaches">
            <summary>
                Clears all the cached state in <c>this</c> object.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Caching.ICachefulObject`1">
            <summary>
                A generic version of <see cref="T:Microsoft.ProgramSynthesis.Utils.Caching.ICachefulObject"/>.
            </summary>
            <typeparam name="TDerived"></typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ICachefulObject`1.CloneWithCurrentCacheState">
            <summary>
                Returns a clone of the object with a snapshot/copy of the cache state before the call.
            </summary>
            <returns>A clone of <c>this</c> object.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache">
            <summary>
                An interface for cloneable caches
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache.ShallowClone">
            <summary>
                Clones the cache. All references to keys and values are copied over to the cloned cache.
            </summary>
            <returns>A shallow clone of this cache.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache.DeepClone">
            <summary>
                Performs a deep clone of the cache.
            </summary>
            <returns>A deep clone of this cache.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache.Count">
            <summary>
                The number of mappings in the cache.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache.Clear">
            <summary>
                Clears the contents of this cache.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache`3">
            <summary>
                A generic version of <see cref="T:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache"/>.
            </summary>
            <typeparam name="TKey">The type of the keys.</typeparam>
            <typeparam name="TValue">The type of the values.</typeparam>
            <typeparam name="TCache">The type of the class implementing this interface.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache`3.Add(`0,`1)">
            <summary>
                Adds a new mapping to the cache. Raises <see cref="T:System.InvalidOperationException"/> if <paramref name="key"/> has already been mapped to a value in the cache.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="value">The value for the mapping.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache`3.Replace(`0,`1,`1@)">
            <summary>
                Adds a new mapping to the cache, or replaces the existing value that <paramref name="key"/> is mapped to.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="value">The value for the mapping.</param>
            <param name="oldValue">An output parameter that is set to the old value that <paramref name="key"/> was mapped to, if any.</param>
            <returns><c>true</c> is <paramref name="key"/> was mapped to a value in the cache before this call, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache`3.Remove(`0,`1@)">
            <summary>
                Removes a mapping from the cache.
            </summary>
            <param name="key">The key whose mapping is to be removed.</param>
            <param name="removedValue">The value that <paramref name="key"/> was mapped to in the cache, if any.</param>
            <returns><c>true</c> if <paramref name="key"/> was mapped in the cache, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache`3.Lookup(`0,`1@)">
            <summary>
                Looks up a mapping in the cache.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="value">An output parameter that contains the value that <paramref name="key"/> was mapped to, if any.</param>
            <returns><c>true</c> if <paramref name="key"/> has been mapped to a value in the cache, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache`3.GetOrAdd(`0,System.Func{`0,`1})">
            <summary>
                Adds a key/value pair to the cache by using the specified function, if the key does not already exist.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="insertValueFunc">Function mapping key to inserted value.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache`3.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})">
            <summary>
                Uses the specified functions to add a key/value pair to the cache if the key does not already exist, or
                to update a key/value pair in the cache if the key already exists.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="insertValueFunc">Function mapping key to inserted value.</param>
            <param name="updateValueFunc">Function mapping key and existing value to new value.</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache`3.Keys">
            <summary>
                The set of keys in the cache.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache`3.Values">
            <summary>
                The values in the cache.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache`3.Mappings">
            <summary>
                All the mappings in the cache.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache`3.ShallowClone">
            <summary>
                Clones the cache. All references to keys and values are copied over to the cloned cache.
            </summary>
            <returns>A shallow clone of this cache.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache`3.DeepClone">
            <summary>
                Performs a deep clone of the cache. The keys and values in the cloned cache are cloned by applying
                <see cref="P:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache`3.KeyCloner"/> and <see cref="P:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache`3.ValueCloner"/> on the keys and values respectively.
            </summary>
            <returns>A deep clone of this cache.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache`3.KeyCloner">
            <summary>
                Clones keys.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache`3.ValueCloner">
            <summary>
                Clones values.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache`3.EqualityComparer">
            <summary>
                The equality comparer to use.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Caching.IntegerKeyedCache`1">
            <summary>
                A bounded size cloneable cache specialized for integer keys.
                The bound on the size can be specified during construction.
                The cache is backed by an array, and is thus unsuitable for
                sparsely populated caches.
                Use an <see cref="T:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedCache`2" /> for sparsely
                populated integer keyed caches.
            </summary>
            <typeparam name="TValue">The type of the values mapped by this cache.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.IntegerKeyedCache`1.#ctor(System.UInt32,System.Func{`0,`0})">
            <summary>
                Constructor.
            </summary>
            <param name="cacheSize">The size of the cache. Keys cannot exceed this size.</param>
            <param name="valueCloner">A function for cloning values, if <c>null</c>, then the identity function will be used.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.IntegerKeyedCache`1.#ctor(Microsoft.ProgramSynthesis.Utils.Caching.IntegerKeyedCache{`0},System.Func{`0,`0})">
            <summary>
                Constructor for cloning.
            </summary>
            <param name="other">The other cache to clone from.</param>
            <param name="valueCloner">
                The value cloner used to clone the cache. Note that the
                <see cref="!:IntegerKeyedCache&lt;TValue&gt;.ValueCloner" /> for the cloned cache will be set from
                <c>other.ValueCloner</c>.
                This parameter only dictates how the cache will be cloned from <paramref name="other" />.
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.IntegerKeyedCache`1.Lookup(System.Int32,`0@)">
            <summary>
                Looks up a mapping in the cache.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="value">An output parameter that contains the value that <paramref name="key" /> was mapped to, if any.</param>
            <returns><c>true</c> if <paramref name="key" /> has been mapped to a value in the cache, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.IntegerKeyedCache`1.ShallowClone">
            <summary>
                Clones the cache. All references to keys and values are copied over to the cloned cache.
            </summary>
            <returns>A shallow clone of this cache.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.IntegerKeyedCache`1.DeepClone">
            <summary>
                Performs a deep clone of the cache. The keys and values in the cloned cache are cloned by applying
                <see cref="P:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache`3.KeyCloner" /> and
                <see cref="P:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache`3.ValueCloner" /> on the keys and values respectively.
            </summary>
            <returns>A deep clone of this cache.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.IntegerKeyedCache`1.Count">
            <summary>
                The number of mappings in the cache.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.IntegerKeyedCache`1.Clear">
            <summary>
                Clears the contents of this cache.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.IntegerKeyedCache`1.Keys">
            <summary>
                The set of keys in the cache.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.IntegerKeyedCache`1.Values">
            <summary>
                The values in the cache.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.IntegerKeyedCache`1.Mappings">
            <summary>
                All the mappings in the cache.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.IntegerKeyedCache`1.GetOrAdd(System.Int32,System.Func{System.Int32,`0})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.IntegerKeyedCache`1.AddOrUpdate(System.Int32,System.Func{System.Int32,`0},System.Func{System.Int32,`0,`0})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.IntegerKeyedCache`1.Add(System.Int32,`0)">
            <summary>
                Adds a new mapping to the cache.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="value">The value for the mapping.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.IntegerKeyedCache`1.Replace(System.Int32,`0,`0@)">
            <summary>
                Adds a new mapping to the cache, or replaces the existing value that <paramref name="key" /> is mapped to.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="value">The value for the mapping.</param>
            <param name="oldValue">
                An output parameter that is set to the old value that <paramref name="key" /> was mapped to, if
                any.
            </param>
            <returns>
                <c>true</c> is <paramref name="key" /> was mapped to a value in the cache before this call, <c>false</c>
                otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.IntegerKeyedCache`1.Remove(System.Int32,`0@)">
            <summary>
                Removes a mapping from the cache.
            </summary>
            <param name="key">The key whose mapping is to be removed.</param>
            <param name="removedValue">The value that <paramref name="key" /> was mapped to in the cache, if any.</param>
            <returns><c>true</c> if <paramref name="key" /> was mapped in the cache, <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Caching.LruCache`2">
            <summary>
                An LRU cache that maps values of type <typeparamref name="TKey" /> to values of type
                <typeparamref name="TValue" />.
            </summary>
            <typeparam name="TKey">The type of the key used to lookup values in the cache.</typeparam>
            <typeparam name="TValue">The type of the values stored in the cache.</typeparam>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Caching.LruCache`2.DefaultCacheSize">
            <summary>
                The default LRU cache size.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.LruCache`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0},System.Func{`0,`0},System.Func{`1,`1})">
            <summary>
                Constructs an <see cref="T:Microsoft.ProgramSynthesis.Utils.Caching.LruCache`2" /> object.
            </summary>
            <param name="cacheSize">
                The maximum number of <typeparamref name="TKey" /> to <typeparamref name="TValue" /> mappings
                that can be cached. This defaults to <see cref="F:Microsoft.ProgramSynthesis.Utils.Caching.LruCache`2.DefaultCacheSize" />, which is set to
                <value>4096</value>
                .
            </param>
            <param name="comparer">
                An optional <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> that compares objects of type
                <typeparamref name="TKey" />. If null, then the elements will be compared according to
                <see cref="T:Microsoft.ProgramSynthesis.Utils.IdentityEquality" />.
            </param>
            <param name="keyCloner">The key cloner.</param>
            <param name="valueCloner">The value cloner.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.LruCache`2.#ctor(Microsoft.ProgramSynthesis.Utils.Caching.LruCache{`0,`1},System.Func{`0,`0},System.Func{`1,`1})">
            <summary>
                Private constructor for cloning.
            </summary>
            <param name="other">The cache to be cloned.</param>
            <param name="keyCloner">
                The key cloner to use within this constructor to clone the cache. The key cloner for the cloned
                cache will be copied from <c>other.KeyCloner</c>.
            </param>
            <param name="valueCloner">
                The value cloner to use within this constructor to clone the cache. The value cloner for the
                cloned cache will be copied from <c>other.ValueCloner</c>.
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.LruCache`2.Remove(`0,`1@)">
            <summary>
                Removes a mapping from the cache.
            </summary>
            <param name="key">The key whose mapping is to be removed.</param>
            <param name="removedValue">The value that <paramref name="key" /> was mapped to in the cache, if any.</param>
            <returns><c>true</c> if <paramref name="key" /> was mapped in the cache, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.LruCache`2.Lookup(`0,`1@)">
            <summary>
                Retrives the value associated with the specified <paramref name="key" /> object.
            </summary>
            <param name="key">The object to be used as a key.</param>
            <param name="value">
                An <code>out</code> parameter that is set to the value of the <see cref="!:key" /> if
                <paramref name="key" /> contains a mapping in the cache.
            </param>
            <returns>
                <code>true</code> if the cache contains a mapping for <paramref name="key" />, <code>false</code> otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.LruCache`2.ShallowClone">
            <summary>
                Clones the cache. All references to keys and values are copied over to the cloned cache.
            </summary>
            <returns>A shallow clone of this cache.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.LruCache`2.DeepClone">
            <summary>
                Performs a deep clone of the cache. The keys and values in the cloned cache are cloned by applying
                <see cref="P:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache`3.KeyCloner" /> and
                <see cref="P:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache`3.ValueCloner" /> on the keys and values respectively.
            </summary>
            <returns>A deep clone of this cache.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.LruCache`2.Keys">
            <summary>
                The set of keys in the cache.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.LruCache`2.Values">
            <summary>
                The values in the cache.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.LruCache`2.Mappings">
            <summary>
                All the mappings in the cache.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.LruCache`2.Add(`0,`1)">
            <summary>
                Adds or replaces a mapping in the cache.
            </summary>
            <param name="key">The key whose mapped <paramref name="value" /> is to be created or replaced.</param>
            <param name="value">The new value to be mapped to the <paramref name="key" />.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.LruCache`2.Replace(`0,`1,`1@)">
            <summary>
                Adds a new mapping to the cache, or replaces the existing value that <paramref name="key" /> is mapped to.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="value">The value for the mapping.</param>
            <param name="oldValue">
                An output parameter that is set to the old value that <paramref name="key" /> was mapped to, if
                any.
            </param>
            <returns>
                <c>true</c> is <paramref name="key" /> was mapped to a value in the cache before this call, <c>false</c>
                otherwise.
            </returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.LruCache`2.Count">
            <summary>
                The number of entries currently present in the cache.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.LruCache`2.Clear">
            <summary>
                Clears the contents of this cache.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Caching.LruDisposableCache`2">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Utils.Caching.LruCache`2" /> that disposes its values when they are evicted.
            </summary>
            <typeparam name="TKey">The type of the key used to lookup values in the cache.</typeparam>
            <typeparam name="TValue">The type of the values stored in the cache.</typeparam>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedCache`2">
            <summary>
                An unbounded cache from <typeparamref name="TKey"/> to <typeparamref name="TValue"/>.
            </summary>
            <typeparam name="TKey">The key type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedCache`2.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Func{`0,`0},System.Func{`1,`1})">
            <summary>
                Constructor.
            </summary>
            <param name="equalityComparer">The equality comparer to use. If <c>null</c>, then <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/> will be used.</param>
            <param name="keyCloner">A key cloner. If <c>null</c>, then the identity function will be used.</param>
            <param name="valueCloner">A value cloner. If <c>null</c>, then the identity function will be used.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedCache`2.#ctor(Microsoft.ProgramSynthesis.Utils.Caching.UnboundedCache{`0,`1},System.Func{`0,`0},System.Func{`1,`1})">
            <summary>
                Constructor for cloning.
            </summary>
            <param name="other">The othe cache to clone from.</param>
            <param name="keyCloner">
                The key cloner to use within this constructor to clone the cache. The key cloner for the cloned
                cache will be copied from <c>other.KeyCloner</c>.
            </param>
            <param name="valueCloner">
                The value cloner to use within this constructor to clone the cache. The value cloner for the
                cloned cache will be copied from <c>other.ValueCloner</c>.
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedCache`2.Lookup(`0,`1@)">
            <summary>
                Looks up a mapping in the cache.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="value">An output parameter that contains the value that <paramref name="key" /> was mapped to, if any.</param>
            <returns><c>true</c> if <paramref name="key" /> has been mapped to a value in the cache, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedCache`2.ShallowClone">
            <summary>
                Clones the cache. All references to keys and values are copied over to the cloned cache.
            </summary>
            <returns>A shallow clone of this cache.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedCache`2.DeepClone">
            <summary>
                Performs a deep clone of the cache. The keys and values in the cloned cache are cloned by applying
                <see cref="P:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache`3.KeyCloner" /> and
                <see cref="P:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache`3.ValueCloner" /> on the keys and values respectively.
            </summary>
            <returns>A deep clone of this cache.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedCache`2.Count">
            <summary>
                The number of mappings in the cache.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedCache`2.Clear">
            <summary>
                Clears the contents of this cache.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedCache`2.Keys">
            <summary>
                The set of keys in the cache.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedCache`2.Values">
            <summary>
                The values in the cache.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedCache`2.Mappings">
            <summary>
                All the mappings in the cache.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedCache`2.GetOrAdd(`0,System.Func{`0,`1})">
            <summary>
                Adds a key/value pair to the cache by using the specified function, if the key does not already exist.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="insertValueFunc">Function mapping key to inserted value.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedCache`2.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})">
            <summary>
                Uses the specified functions to add a key/value pair to the cache if the key does not already exist, or
                to update a key/value pair in the cache if the key already exists.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="insertValueFunc">Function mapping key to inserted value.</param>
            <param name="updateValueFunc">Function mapping key and existing value to new value.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedCache`2.Add(`0,`1)">
            <summary>
                Adds a new mapping to the cache. Raises <see cref="T:System.InvalidOperationException" /> if <paramref name="key" /> has
                already been mapped to a value in the cache.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="value">The value for the mapping.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedCache`2.Replace(`0,`1,`1@)">
            <summary>
                Adds a new mapping to the cache, or replaces the existing value that <paramref name="key" /> is mapped to.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="value">The value for the mapping.</param>
            <param name="oldValue">
                An output parameter that is set to the old value that <paramref name="key" /> was mapped to, if
                any.
            </param>
            <returns>
                <c>true</c> is <paramref name="key" /> was mapped to a value in the cache before this call, <c>false</c>
                otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedCache`2.Remove(`0,`1@)">
            <summary>
                Removes a mapping from the cache.
            </summary>
            <param name="key">The key whose mapping is to be removed.</param>
            <param name="removedValue">The value that <paramref name="key" /> was mapped to in the cache, if any.</param>
            <returns><c>true</c> if <paramref name="key" /> was mapped in the cache, <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedMultiValueCache`2">
            <summary>
                An unbounded cache that maps values of type <typeparamref name="TKey" /> to a collection of values of type
                <typeparamref name="TValue" />.
            </summary>
            <typeparam name="TKey">The key type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedMultiValueCache`2.AsReadOnlyDictionary">
            <summary>
                Returns the contents of this cache as a read-only dictionary.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedMultiValueCache`2.Create(System.Collections.Generic.IEqualityComparer{`0},System.Func{`0,`0},System.Func{`1,`1})">
            <summary>
                Creates a new <see cref="T:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedMultiValueCache`2" />
            </summary>
            <param name="equalityComparer">
                The equality comparer to use. <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> will be used
                if <c>null</c>.
            </param>
            <param name="keyCloner">The key cloner. The identity function will be used if <c>null</c>.</param>
            <param name="valueCloner">The value cloner. The identity function will be used if <c>null</c>.</param>
            <returns>A new, empty <see cref="T:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedMultiValueCache`2" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedMultiValueCache`2.Create``1(System.Collections.Generic.IEqualityComparer{`0},System.Func{`0,`0},System.Func{`1,`1})">
            <summary>
                Creates a new <see cref="T:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedMultiValueCache`2" />.
            </summary>
            <typeparam name="TValueCollection">
                The type of the collection class used to store a collection of
                <typeparamref name="TValue" /> objects.
            </typeparam>
            <param name="equalityComparer">
                The equality comparer to use. <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> will be used
                if <c>null</c>.
            </param>
            <param name="keyCloner">The key cloner. The identity function will be used if <c>null</c>.</param>
            <param name="valueCloner">The value cloner. The identity function will be used if <c>null</c>.</param>
            <returns>
                A new, empty <see cref="T:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedMultiValueCache`2" />, which internally uses
                <typeparamref name="TValueCollection" /> as the collection class.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedMultiValueCache`2.UnboundedMultiValueCacheImpl`1.#ctor(Microsoft.ProgramSynthesis.Utils.Caching.UnboundedMultiValueCache{`0,`1}.UnboundedMultiValueCacheImpl{`2},System.Func{`0,`0},System.Func{System.Collections.Generic.IReadOnlyCollection{`1},System.Collections.Generic.IReadOnlyCollection{`1}})">
            <summary>
                Constructor for cloning.
            </summary>
            <param name="other">The othe cache to clone from.</param>
            <param name="keyCloner">
                The key cloner to use within this constructor to clone the cache. The key cloner for the cloned
                cache will be copied from <c>other.KeyCloner</c>.
            </param>
            <param name="valueCloner">
                The value cloner to use within this constructor to clone the cache. The value cloner for the
                cloned cache will be copied from <c>other.ValueCloner</c>.
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedMultiValueCache`2.UnboundedMultiValueCacheImpl`1.Lookup(`0,System.Collections.Generic.IReadOnlyCollection{`1}@)">
            <summary>
                Looks up a mapping in the cache.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="value">An output parameter that contains the value that <paramref name="key" /> was mapped to, if any.</param>
            <returns><c>true</c> if <paramref name="key" /> has been mapped to a value in the cache, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedMultiValueCache`2.UnboundedMultiValueCacheImpl`1.ShallowClone">
            <summary>
                Clones the cache. All references to keys and values are copied over to the cloned cache.
            </summary>
            <returns>A shallow clone of this cache.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedMultiValueCache`2.UnboundedMultiValueCacheImpl`1.DeepClone">
            <summary>
                Performs a deep clone of the cache. The keys and values in the cloned cache are cloned by applying
                <see cref="P:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache`3.KeyCloner" /> and
                <see cref="P:Microsoft.ProgramSynthesis.Utils.Caching.ICloneableCache`3.ValueCloner" /> on the keys and values respectively.
            </summary>
            <returns>A deep clone of this cache.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedMultiValueCache`2.UnboundedMultiValueCacheImpl`1.Count">
            <summary>
                The number of mappings in the cache.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedMultiValueCache`2.UnboundedMultiValueCacheImpl`1.Clear">
            <summary>
                Clears the contents of this cache.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedMultiValueCache`2.UnboundedMultiValueCacheImpl`1.Keys">
            <summary>
                The set of keys in the cache.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedMultiValueCache`2.UnboundedMultiValueCacheImpl`1.Values">
            <summary>
                The values in the cache.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedMultiValueCache`2.UnboundedMultiValueCacheImpl`1.Mappings">
            <summary>
                All the mappings in the cache.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedMultiValueCache`2.UnboundedMultiValueCacheImpl`1.GetOrAdd(`0,System.Func{`0,System.Collections.Generic.IReadOnlyCollection{`1}})">
            <summary>
                Adds a key/value pair to the cache by using the specified function, if the key does not already exist.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="insertValueFunc">Function mapping key to inserted value.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedMultiValueCache`2.UnboundedMultiValueCacheImpl`1.AddOrUpdate(`0,System.Func{`0,System.Collections.Generic.IReadOnlyCollection{`1}},System.Func{`0,System.Collections.Generic.IReadOnlyCollection{`1},System.Collections.Generic.IReadOnlyCollection{`1}})">
            <summary>
                Uses the specified functions to add a key/value pair to the cache if the key does not already exist, or
                to update a key/value pair in the cache if the key already exists.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="insertValueFunc">Function mapping key to inserted value.</param>
            <param name="updateValueFunc">Function mapping key and existing value to new value.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedMultiValueCache`2.UnboundedMultiValueCacheImpl`1.Add(`0,System.Collections.Generic.IReadOnlyCollection{`1})">
            <summary>
                Adds a new mapping to the cache, with a range of values.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="value">The value for the mapping.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedMultiValueCache`2.UnboundedMultiValueCacheImpl`1.Add(`0,`1)">
            <summary>
                Adds a new mapping to the cache, with a single value.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="value">The value for the mapping.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedMultiValueCache`2.UnboundedMultiValueCacheImpl`1.Replace(`0,System.Collections.Generic.IReadOnlyCollection{`1},System.Collections.Generic.IReadOnlyCollection{`1}@)">
            <summary>
                Adds a new mapping to the cache, or replaces the existing value that <paramref name="key" /> is mapped to.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="value">The value for the mapping.</param>
            <param name="oldValue">
                An output parameter that is set to the old value that <paramref name="key" /> was mapped to, if
                any.
            </param>
            <returns>
                <c>true</c> is <paramref name="key" /> was mapped to a value in the cache before this call, <c>false</c>
                otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedMultiValueCache`2.UnboundedMultiValueCacheImpl`1.Remove(`0,System.Collections.Generic.IReadOnlyCollection{`1}@)">
            <summary>
                Removes a mapping from the cache.
            </summary>
            <param name="key">The key whose mapping is to be removed.</param>
            <param name="removedValue">The value that <paramref name="key" /> was mapped to in the cache, if any.</param>
            <returns><c>true</c> if <paramref name="key" /> was mapped in the cache, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Caching.UnboundedMultiValueCache`2.UnboundedMultiValueCacheImpl`1.AsReadOnlyDictionary">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Clustering.AgglomerativeHierarchicalClustering`1">
            <summary>
                An agglomerative hierarchical clustering task.
                [https://en.wikipedia.org/wiki/Hierarchical_clustering]
            </summary>
            <typeparam name="TData">The type of data points to be clustered.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.AgglomerativeHierarchicalClustering`1.#ctor(Microsoft.ProgramSynthesis.Utils.Clustering.ProblemSpace{`0},Microsoft.ProgramSynthesis.Utils.Clustering.LinkageCriterion{`0}.Type,System.Nullable{System.UInt32},System.Nullable{System.Double})">
            <summary>
                Instantiates a new AHC task.
            </summary>
            <param name="problemSpace">The description of space for the clustering task.</param>
            <param name="linkageCriterion">The linkage criterion to be used for constructing the hierarchy.</param>
            <param name="estimatedMaxClusterCount">
                The estimated number of clusters, defaults to the number of unique points.
            </param>
            <param name="thetaFactor">
                Higher theta means more distances are computed exactly. Defaults to <c>1.25</c>.
                See <see cref="P:Microsoft.ProgramSynthesis.Utils.Clustering.AgglomerativeHierarchicalClustering`1.ThetaFactor" />.
            </param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.AgglomerativeHierarchicalClustering`1.ThetaFactor">
            <summary>
                Multiplied by <see cref="P:Microsoft.ProgramSynthesis.Utils.Clustering.AgglomerativeHierarchicalClustering`1.EstimatedMaxClusterCount" /> to determine how many of the distances should be computed
                exactly. (Larger theta means more computed exactly.)
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.AgglomerativeHierarchicalClustering`1.EstimatedMaxClusterCount">
            <summary>
                The estimated number of clusters in the problem space.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.AgglomerativeHierarchicalClustering`1.LinkageCriterion">
            <summary>
                The linkage criterion to be used for constructing the hierarchy.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.AgglomerativeHierarchicalClustering`1.ProblemSpace">
            <summary>
                The problem space for the current clustering task.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.AgglomerativeHierarchicalClustering`1.Hierarchy">
            <summary>
                Returns a dendrogram for the given data points,
                using the specified distance function and linkage criterion.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.AgglomerativeHierarchicalClustering`1.MostLikelyClusters(System.UInt32,System.UInt32)">
            <summary>
                Splits a dendrogram into a likely set of smaller clusters (dendrograms).
                This function assumes that the number of data points is much larger than the expected
                number of clusters. It overrides the maxClusters if required and sets an appropriate
                threshold on the quality of clusters.
            </summary>
            <param name="maxClusters">Maximum number of expected clusters.</param>
            <param name="minClusters">Minimum number of expected clusters.</param>
            <returns>
                A collection of clusters, sorted by (decreasing order of) their Id,
                indicating the order in which they were created (latest to earliest).
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.AgglomerativeHierarchicalClustering`1.CostOf(Microsoft.ProgramSynthesis.Utils.Clustering.Dendrogram{`0},Microsoft.ProgramSynthesis.Utils.Clustering.Dendrogram{`0})">
            <summary>
                Computes the cost of linking two clusters together.
                Requires _linkageCosts to be populated with linkage-costs of singleton clusters.
            </summary>
            <param name="clusterA">The first cluster.</param>
            <param name="clusterB">The second cluster.</param>
            <returns>
                A real value representing the linkage cost.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.AgglomerativeHierarchicalClustering`1.SplitIntoKClusters(System.UInt32)">
            <summary>
                Splits a dendrogram into the 'best' K smaller clusters (dendrograms).
            </summary>
            <param name="k">The desired number of clusters.</param>
            <returns>
                An enumerable collection of clusters.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.AgglomerativeHierarchicalClustering`1.SplitByCostThreshold(System.Double)">
            <summary>
                Splits a dendrogram into smaller clusters by using a distance threshold
            </summary>
            <param name="threshold">Maximum permissible cost of a dendrogram </param>
            <returns>
                A collection of clusters, sorted by (decreasing order of) their Id,
                indicating the order in which they were created (latest to earliest).
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Clustering.Cluster`1">
            <summary>
                A cluster, storing the learned ProgramSet, the best ProgramNode and the source inputs.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.Cluster`1.#ctor(Microsoft.ProgramSynthesis.VersionSpace.ProgramSetBuilder{`0},`0,System.Double,System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.State},System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.State},System.UInt32,System.String)">
            <summary>Initializes a new instance of the <see cref="T:System.Object" /> class.</summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.Cluster`1.Equals(Microsoft.ProgramSynthesis.Utils.Clustering.Cluster{`0})">
            <summary>Indicates whether the current object is equal to another object of the same type.</summary>
            <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.Cluster`1.Equals(System.Object)">
            <summary>Indicates whether this instance and a specified object are equal.</summary>
            <returns>
                true if <paramref name="obj" /> is a cluster and has the same BestProgramNode.
            </returns>
            <param name="obj">The object to compare with the current instance. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.Cluster`1.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
            <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.Cluster`1.op_Equality(Microsoft.ProgramSynthesis.Utils.Clustering.Cluster{`0},Microsoft.ProgramSynthesis.Utils.Clustering.Cluster{`0})">
            <summary>Indicates whether this instance and a specified object are equal.</summary>
            <returns>
                true if <paramref name="left" /> and <paramref name="right" /> have the same BestProgramNode.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.Cluster`1.op_Inequality(Microsoft.ProgramSynthesis.Utils.Clustering.Cluster{`0},Microsoft.ProgramSynthesis.Utils.Clustering.Cluster{`0})">
            <summary>Indicates whether this instance and a specified object are not equal.</summary>
            <returns>
                true if <paramref name="left" /> and <paramref name="right" /> have different BestProgramNode.
            </returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.Cluster`1.BestProgramScore">
            <summary>
                The feature score of the <see cref="P:Microsoft.ProgramSynthesis.Utils.Clustering.Cluster`1.BestProgramNode" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.Cluster`1.BestProgramNode">
            <summary>
                The best program for the cluster.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.Cluster`1.ProgramSet">
            <summary>
                The ProgramSet of all learned programs for the cluster.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.Cluster`1.Data">
            <summary>
                The input States used to learn this cluster.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.Cluster`1.AllMatchingData">
            <summary>
                The list of input states in this cluster.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.Cluster`1.DataCount">
            <summary>
                Count (including multiplicities) of the <see cref="P:Microsoft.ProgramSynthesis.Utils.Clustering.Cluster`1.AllMatchingData"/> datapoints
                Guaranteed to be greater or equal AllMatchingData.Count.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.Cluster`1.Description">
            <summary>
                A description of the cluster.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.Cluster`1.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Clustering.ClusteringResult`1">
            <summary>
                A class to represent clustering results with Clusters being top-level
                patterns and Outliers being recursive clustering results on the results.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ClusteringResult`1.#ctor(System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.Utils.Clustering.Cluster{`0}},Microsoft.ProgramSynthesis.Utils.Clustering.ClusteringResult{`0})">
            <summary>
              Build a clustering result with provided list of <paramref name="clusters" />
              and <paramref name="outliers" />.
            </summary>
            <param name="clusters">Top level clusters</param>
            <param name="outliers">Clustering result on outliers</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.ClusteringResult`1.Clusters">
            <summary>
               The list of primary clusters in this clustering results.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.ClusteringResult`1.Outliers">
            <summary>
               The list of outliers in this clustering results, recursively clustered.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ClusteringResult`1.InOrder">
            <summary>
               Return the list of all clusters in this result, with primary clusters preceding the
               outlier clusters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ClusteringResult`1.SamplesInOrder">
            <summary>
               Return the list of all sample data points used to build the clusters in this results.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ClusteringResult`1.ToString">
            <summary>
                Tab-indented hierarchical string representation.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterConstraints">
            <summary>
                Structure representing desired properties from the clusters.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterConstraints.InSameCluster">
            <summary>
                Each element in this cluster contains a set of inputs
                that need to belong to the same cluster.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterConstraints.InDifferentCluster">
            <summary>
                Each element in this cluster contains a set of inputs
                that all need to belong to different clusters.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool`1">
            <summary>
                A data structure representing the set of all clusters known to the disjunction learning algorithm.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool`1._clusterSubsets">
            <summary>
                Map from clusters to the ExampleSubset datastructure representing the subsets of examples covered
                by the clusters in <see cref="F:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool`1._knownClusters" />.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool`1._exampleCounts">
            <summary>
                The multiplicities of the examples in <see cref="F:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool`1._examples" />.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool`1._examples">
            <summary>
                The list of examples for this disjunction learning problem.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool`1._intersectsCache">
            <summary>
                Cached results storing computation of whether two clusters intersect or not.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool`1._knownClusters">
            <summary>
                The list of all clusters in this pool.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool`1._clusterConstraints">
            <summary>
                The constraints on all clusters in this pool.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool`1._clusterDescriptions">
            <summary>
                The descriptions of all clusters in this pool.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool`1.#ctor(System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.State},System.Collections.Generic.IReadOnlyList{System.UInt32},Microsoft.ProgramSynthesis.Utils.Clustering.ClusterConstraints)">
            <summary>
                The default constructor building an empty pool of clusters.
            </summary>
            <param name="examples">The space of examples for this cluster pool.</param>
            <param name="exampleCounts">The counts of the examples for examples in the space.</param>
            <param name="clusterConstraints">The constraints on the clusters in the pool.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool`1.Count">
            <summary>
                The number of clusters in the pool.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool`1.AddClusterFromPredicate(Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPredicate{`0},System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.State})">
            <summary>
                Add a cluster to the cluster pool based on the given cluster predicate and generators.
                Returns null if the cluster is already present or invalid.
            </summary>
            <returns>Null if equivalent cluster was already present or is invalid, and the added cluster otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool`1.Valid(System.Predicate{System.Object})">
            <summary>
                Return true iff a predicate will form a valid cluster.
            </summary>
            <param name="pred">The predicate to check.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool`1.FindCluster(`0)">
            <summary>
                Find a cluster defined by <paramref name="program" /> in the cluster pool and return it.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool`1.Intersects(Microsoft.ProgramSynthesis.Utils.Clustering.Cluster{`0},Microsoft.ProgramSynthesis.Utils.Clustering.Cluster{`0})">
            <summary>
                Returns true if <paramref name="cluster1" /> and <paramref name="cluster2" /> have an example in common.
            </summary>
            <param name="cluster1"></param>
            <param name="cluster2"></param>
            <returns>
                True if and only if <paramref name="cluster1" /> and <paramref name="cluster2" /> have a non-empty
                intersection.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool`1.ArePairwiseDisjoint(System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.Utils.Clustering.Cluster{`0}})">
            <summary>
                Returns true if no two clusters in <paramref name="clusters" /> have a non-empty intesection.
            </summary>
            <param name="clusters"></param>
            <returns>
                True if and only if no two clusters in <paramref name="clusters" /> have a non-empty intersection
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool`1.UnionComplement(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Utils.Clustering.Cluster{`0}})">
            <summary>
                Returns the subset of examples that are not in any of the clusters in <paramref name="clusters" />.
            </summary>
            <param name="clusters"></param>
            <returns>
                ExampleSubset with examples not in any of <paramref name="clusters" />
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool`1.Sample(System.Random)">
            <summary>
                Return a random element from known clusters.
            </summary>
            <param name="rng"></param>
            <returns>A cluster from the pool</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Clustering.Cover`1">
            <summary>
                The concept of a cover for the disjunction learning algorithm. Intuitively, it is a collection of clusters which
                are pairwise disjoint, and their union is intended to cover the whole space of examples (possibly barring a
                fraction of outlier).
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.Cover`1._coveringClusters">
            <summary>
                A list of all the clusters in this cover.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.Cover`1.#ctor(Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool{`0},System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.Utils.Clustering.Cluster{`0}})">
            <summary>
                Constructor taking the clusterPool for this cover, and the list of clusters in the cover.
            </summary>
            <param name="clusterPool">Cluster pool from which all clusters in this cover are taken.</param>
            <param name="coveringClusters">List of clusters in the cover.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.Cover`1.UncoveredExamples">
            <summary>
                The subset of examples in the space that do not belong in any of the clusters in this cover.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.Cover`1.NumberUncoveredExamples">
            <summary>
                The number of examples (including multiplicities) in the space that do not belong in any of the clusters in this
                cover.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.Cover`1.HasUncoveredExamples">
            <summary>
                True if, and only if, there are examples in the space that do not belong in any of the clusters.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.Cover`1.Count">
            <summary>
                The number of clusters in the cover.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.Cover`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.Cover`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.Cover`1.TryAppend(Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool{`0},Microsoft.ProgramSynthesis.Utils.Clustering.Cluster{`0})">
            <summary>
                If <paramref name="cluster" /> does not intersect with any of the existing clusters in this cover, returns a new
                cover with <paramref name="cluster" /> added. Otherwise, returns null.
            </summary>
            <param name="clusterPool"></param>
            <param name="cluster"></param>
            <returns>
                Returns a new cover with <paramref name="cluster" /> added, or null if <paramref name="cluster" /> has a
                non-empty intersection with an existing cluster in the cover
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.Cover`1.Sample(System.Random)">
            <summary>
                Return a random element from clusters in this cover.
            </summary>
            <param name="rng"></param>
            <returns>A cluster from the cover</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Clustering.Dendrogram`1">
            <summary>
                A cluster tree / dendrogram.
            </summary>
            <typeparam name="TData">The type of data points to be clustered.</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.Dendrogram`1.Id">
            <summary>
                An id for the cluster (must be unique within a hierarchy).
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.Dendrogram`1.Cost">
            <summary>
                The cost of the cluster.
                This is usually manipulated by the hierarchical clustering algorithm.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.Dendrogram`1.PointsCount">
            <summary>
                The total number of data points in the cluster.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.Dendrogram`1.LeftChild">
            <summary>
                The left child cluster of the current cluster.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.Dendrogram`1.RightChild">
            <summary>
                The right child cluster of the current cluster.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.Dendrogram`1.Data">
            <summary>
                Returns a list of distinct data points in the cluster.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.Dendrogram`1.CompareTo(System.Object)">
            <summary>
                Compares the current instance with another object of the same type and returns an integer that indicates
                whether the current instance precedes, follows, or occurs in the same position in the sort order as the other
                object.
            </summary>
            <returns>
                A value that indicates the relative order of the objects being compared. The return value has these meanings:
                Value Meaning Less than zero This instance precedes <paramref name="obj" /> in the sort order. Zero This instance
                occurs in the same position in the sort order as <paramref name="obj" />. Greater than zero This instance follows
                <paramref name="obj" /> in the sort order.
            </returns>
            <param name="obj">An object to compare with this instance. </param>
            <exception cref="T:System.ArgumentException">
                <paramref name="obj" /> is not the same type as this instance.
            </exception>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.Dendrogram`1.CompareTo(Microsoft.ProgramSynthesis.Utils.Clustering.Dendrogram{`0})">
            <summary>
                Compares the current instance with another object of the same type and returns an integer that indicates
                whether the current instance precedes, follows, or occurs in the same position in the sort order as the other
                object.
                Note that this compares the Cost of creation of the Dendrogram and uses Id as a tie breaker
            </summary>
            <returns>
                -1 if <paramref name="other" /> is null or has smaller Id than current instance.
                0 if <paramref name="other" /> has the same Id as current instance.
                1 if <paramref name="other" /> has greater Id than current instance.
            </returns>
            <param name="other">An object to compare with this instance. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.Dendrogram`1.Equals(Microsoft.ProgramSynthesis.Utils.Clustering.Dendrogram{`0})">
            <summary>Indicates whether the current object is equal to another object of the same type.</summary>
            <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.Dendrogram`1.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
            <returns>true if the specified object  is equal to the current object; otherwise, false.</returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.Dendrogram`1.GetHashCode">
            <summary>Serves as the default hash function. </summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.Dendrogram`1.ToString">
            <summary>
                Returns a string that represents the cluster.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Clustering.DendrogramPairUtils">
            <summary>
                Utility functions for Pairs of Dendrograms.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.DendrogramPairUtils.CreateSorted``1(Microsoft.ProgramSynthesis.Utils.Clustering.Dendrogram{``0},Microsoft.ProgramSynthesis.Utils.Clustering.Dendrogram{``0})">
            <summary>
                Create a <see cref="T:Microsoft.ProgramSynthesis.Utils.EquatablePair" /> with two <see cref="T:Microsoft.ProgramSynthesis.Utils.Clustering.Dendrogram`1" />,
                ordered by their default comparison ordering.
            </summary>
            <param name="d1">The first dendrogram.</param>
            <param name="d2">The second dendrogram.</param>
            <returns>
                A new pair of dendrograms.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.DendrogramPairUtils.ContainsId``1(Microsoft.ProgramSynthesis.Utils.EquatablePair{Microsoft.ProgramSynthesis.Utils.Clustering.Dendrogram{``0},Microsoft.ProgramSynthesis.Utils.Clustering.Dendrogram{``0}},System.UInt64)">
            <summary>
                Checks if a dendrogram with the specified Id is present in the pair.
            </summary>
            <param name="pair">The pair of dendrograms.</param>
            <param name="id">The id to be matched.</param>
            <returns>
                <c>true</c> if the id matches the id of any dendrogram in the pair,
                <c>false</c> otherwise.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Clustering.SamplingStrategy">
            <summary>
                An enum representing the strategies using which the next set of examples
                for constructing a cluster is picked from.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.SamplingStrategy.Random">
            <summary> Pick two random examples from the universe of examples. </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.SamplingStrategy.ClusterFromUncovered">
            <summary> Pick two random examples from the set of examples we don't yet cover. </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.SamplingStrategy.GrowCluster">
            <summary> Pick one uncovered example and the examples used to build an existing cluster. </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.SamplingStrategy.GrowCoveringCluster">
            <summary> Pick one uncovered example and the examples used to build an existing covering cluster. </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.SamplingStrategy.MergeClusters">
            <summary> Pick the examples used to build two separate existing clusters. </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.SamplingStrategy.MergeCoveringClusters">
            <summary> Pick the examples used to build two separate existing covering clusters. </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.SamplingStrategy.SplitClusters">
            <summary> Pick two examples from a single cluster hoping that it will give us a subcluster. </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.SamplingStrategy.SplitCoveringClusters">
            <summary> Pick two examples from a single sub-cluster hoping that it will give us a subcluster. </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Clustering.SamplingMetaStrategy">
            <summary>
                An enum representing strategies to pick sampling strategies.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.SamplingMetaStrategy.MoreClusters">
            <summary> Biased towards split clusters. </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.SamplingMetaStrategy.FewerClusters">
            <summary> Biased towards merge clusters and grow clusters. </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.SamplingMetaStrategy.MoreCoverage">
            <summary> Biased towards grow clusters and cluster from uncovered. </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.SamplingMetaStrategy.Random">
            <summary> Pick SamplingStrategy.Random always. </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1">
            <summary>
                The sampling + set cover based algorithm for clustering.
                Terminology:
                a. Cluster pool: the set of all clusters that are under consideration for
                use as disjuncts
                b. Cover: a subset of clusters that will form the disjuncts in the final program.
                Algorithm:
                The algorithm has three major steps:
                a) LearnClusters: Generate new clusters and add to the pool. This generation is done
                using clever sampling of examples based on the current cluster pool and cover.
                b) PickCover: From the cluster pool, pick the best candidate for the Cover.
                c) Stop if the picked cover satisfies all requirements.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1._examples">
            <summary>
                The universe of examples (states) for this clustering problem (no duplicates).
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1._exampleCounts">
            <summary>
                The multiplicites of examples for this clustering problem.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1._predicateLearner">
            <summary>
                The predicate learner to generate the cluster definitions from.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1._totalExamples">
            <summary>
                Total number of examples (including multiplicities).
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1._scoreUtils">
            <summary>
                The score utils for the DSL the clustering task is over.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.#ctor(System.Collections.Generic.IReadOnlyDictionary{Microsoft.ProgramSynthesis.State,System.UInt32},Microsoft.ProgramSynthesis.Utils.Clustering.PredicateLearner{`0},Microsoft.ProgramSynthesis.Utils.Clustering.ScoreUtils{`0},System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="examplesWithCounts">Examples to cluster along with their associated counts.</param>
            <param name="predicateLearner">Predicate learner to generate cluster definitions from.</param>
            <param name="scoreUtils">Score utils for the specific dsl the clustering is for.</param>
            <param name="randomSeed">Random number generator seed</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.AddInitialClusters(Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool{`0},System.Threading.CancellationToken)">
            <summary>
                For large problems, we initially seed the cluster pool with singleton clusters that appear "too often". So, if more
                than <see cref="F:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.ModalConfiguration.SingletonLimit" /> fraction of the examples are "foo", we add a cluster with
                just the singleton foo.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.InitialSetup">
            <summary>
                Set up some inital stuff.
                Currently, we modify the preference function for "really" small problems
                and seed the initial cluster pool for large problems.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.MainLoopConfiguration">
            <summary>
                These limits control how the main loop behaves with respect to retries, progress, etc.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.MainLoopConfiguration.MaxAttemptAfterFailure">
            <summary>
                If the main loop hasn't made progress (i.e., the cover hasn't changed)
                in <see cref="F:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.MainLoopConfiguration.MaxAttemptAfterFailure" /> iterations, exit and try recovery.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.MainLoopConfiguration.GreedyBruteForceSwitchOver">
            <summary>
                If the main loop hasn't made progress (i.e., the cover hasn't changed)
                in <see cref="F:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.MainLoopConfiguration.GreedyBruteForceSwitchOver" /> iterations, switch over to
                brute-force covering algorithm.
                TODO: This behaviour should be removed after we remove MaxDisjuncts and MinDisjuncts constraints
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.MainLoopConfiguration.ContinueDespiteSuccess">
            <summary>
                If the cover computed by main loop hasn't made progress (i.e., the cover hasn't changed)
                in <see cref="F:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.MainLoopConfiguration.GreedyBruteForceSwitchOver" /> iterations, switch over to
                brute-force covering algorithm.
                TODO: This behaviour should be removed after we remove MaxDisjuncts and MinDisjuncts constraints.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.MainLoopConfiguration.MaxAttempts">
            <summary>
                Never go through the main loop more than these many times.
                Just fail and give up if necessary.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.ModalConfiguration.LargeProblemLimit">
            <summary>
                Above this limit of examples (with multiplicities), the clustering problem is considered large and different
                strategies are used for identifying singleton clusters.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.ModalConfiguration.SingletonLimit">
            <summary>
                In a large clustering problem (as defined by <see cref="F:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.ModalConfiguration.LargeProblemLimit" />, a single example occuring more often
                than this fraction is automatically added into the cluster pool as a signleton cluster.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.ModalConfiguration.SmallProblemLimit">
            <summary>
                Below this limit of examples (with multiplicities), the clustering problem is considered small and "pattern"
                clusters with more than one example are very preferred over a singleton cluster.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.ModalConfiguration.CategoryLimit">
            <summary>
                Any data set that contains at most this number of unique inputs is a candidate to be considered categorical.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.ModalConfiguration.CategoricalDataSetSizeLimit">
            <summary>
                Any data set that contains more than this number of inputs is a candidate to be considered categorical.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.CoverConstraints">
            <summary>
                Structure representing all the desired properties from a cover.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.CoverConstraints.MaxDisjuncts">
            <summary>
                Maximum number of disjuncts allowed.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.CoverConstraints.MinDisjuncts">
            <summary>
                Minimum number of disjuncts allowed.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.CoverConstraints.MaxOutliers">
            <summary>
                Number of examples that are allowed to be uncovered.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.CoverConstraints.DisjunctionSizes">
            <summary>
                 Return the list of allowed disjunction sizes.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.CoverConstraints.#ctor(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
                Construct a cover constraints object from the given disjunction limits and outlier limits.
            </summary>
            <param name="minDisjuncts"></param>
            <param name="maxDisjuncts"></param>
            <param name="maxOutliers"></param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.CoverConstraints.Check(Microsoft.ProgramSynthesis.Utils.Clustering.Cover{`0})">
            <summary>
                Check if <paramref name="cover" /> satisfies all constraints.
            </summary>
            <param name="cover"></param>
            <returns>True if <paramref name="cover" /> satisfies all constraints, and false otherwise</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.CoverConstraints.PickSamplingMetaStrategy(Microsoft.ProgramSynthesis.Utils.Clustering.Cover{`0})">
            <summary>
                Picks the sampling meta strategy based on how the constraints are violated.
            </summary>
            <param name="cover"></param>
            <returns>Returns a Some(SamplingMetaStrategy) if the unsatisfied constraints call for one, and Nothing otherwise</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.CoverConstraints.PickCoveringStrategy(Microsoft.ProgramSynthesis.Utils.Clustering.Cover{`0})">
            <summary>
                 Picks the covering strategy based on how the constraints are violated.
            </summary>
            <param name="cover"></param>
            <returns>Returns a Some(CoveringStrategy) if the unsatisfied constraints call for one, and Nothing otherwise</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.LearnFromSampling(Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner{`0}.CoverConstraints,Microsoft.ProgramSynthesis.Utils.Clustering.ClusterConstraints,System.Threading.CancellationToken,System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
                The main entry point to the class. High-level algorithm described in
                the class documentation.
            </summary>
            <param name="coverConstraints">Constraints the generated cover should satisfy.</param>
            <param name="clusterConstraints">Constraints (in same cluster/in different cluster) on the clustering.</param>
            <param name="cancel">Cancellation token for this task.</param>
            <param name="maxAttempts">Maximum number of main loop attempts.</param>
            <returns>Returns a clustering result covering the example space.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.RecoveryHighOutlierRate(Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool{`0},Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner{`0}.CoverConstraints,Microsoft.ProgramSynthesis.Utils.Clustering.ClusterConstraints,Microsoft.ProgramSynthesis.Utils.Clustering.Cover{`0},System.Threading.CancellationToken,System.Int32)">
            <summary>
                High outlier rate is fixed by attempting to cluster the outliers and
                add some of the outlier clusters into the main Cover.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.RecoveryTooManyDisjuncts(Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool{`0},Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner{`0}.CoverConstraints,Microsoft.ProgramSynthesis.Utils.Clustering.Cover{`0})">
            <summary>
                Too many disjuncts is fixed by attempting to drop some clusters and see
                if we still satisfy the outlier rate.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.Sample(Microsoft.ProgramSynthesis.Utils.Clustering.SamplingStrategy,Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool{`0},Microsoft.ProgramSynthesis.Utils.Clustering.Cover{`0})">
            <summary>
                Pick examples based on the sampling strategy. See SamplingStrategy doc.
            </summary>
            <param name="strategy"></param>
            <param name="clusterPool"></param>
            <param name="cover"></param>
            <returns>IEnumerable of examples picked according to sampling strategy <paramref name="strategy"/></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.Sample(Microsoft.ProgramSynthesis.Utils.Clustering.SamplingMetaStrategy,Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool{`0},Microsoft.ProgramSynthesis.Utils.Clustering.Cover{`0})">
            <summary>
                Pick sampling strategy based on the sampling meta strategy. See SamplingMetaStrategy doc.
            </summary>
            <param name="metaStrategy"></param>
            <param name="clusterPool"></param>
            <param name="cover"></param>
            <returns>IEnumerable of examples picked according to sampling meta strategy <paramref name="metaStrategy" /></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.LearnNewClusters(System.Int32,Microsoft.ProgramSynthesis.Utils.Clustering.SamplingMetaStrategy,Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool{`0},Microsoft.ProgramSynthesis.Utils.Clustering.Cover{`0},System.Threading.CancellationToken)">
            <summary>
                Repeated sample examples and attempt to learn clusters from them,
                upto a number of attempts.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.AddClusterFromSamples(Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool{`0},System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.State},System.Threading.CancellationToken)">
            <summary>
                Learn a program from <paramref name="samples" /> add the resulting cluster to the pool
                <paramref name="clusterPool" /> if an equivalent cluster is not already in the pool.
            </summary>
            <returns>The cluster added, if any.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.PickCover(Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool{`0},Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner{`0}.CoverConstraints,Microsoft.ProgramSynthesis.Utils.Clustering.CoveringStrategy,System.Threading.CancellationToken)">
            <summary>
                Pick the cover from the cluster pool based on covering strategy.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.CoverGreedy(Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool{`0},System.Threading.CancellationToken)">
            <summary>
                Uses a variation of the standard set cover approximation algorithm to pick the
                minimal cover from the cluster pool <paramref name="clusterPool"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.CoverBruteForce(Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPool{`0},Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner{`0}.CoverConstraints,System.Threading.CancellationToken)">
            <summary>
                Uses a shady brute-force algorithm to enumerate through "all possible" covers
                and picks the best one. If this is too expensive or fails, falls back on the
                greedy algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner`1.ClusterUncoveredExamples(Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearner{`0}.CoverConstraints,Microsoft.ProgramSynthesis.Utils.Clustering.ClusterConstraints,Microsoft.ProgramSynthesis.Utils.Clustering.Cover{`0},System.Threading.CancellationToken,System.Int32)">
            <summary>
                Finally, cluster all the uncovered examples (outliers) in the <paramref name="cover"/>.
            </summary>
            <returns>Clustering result for the uncovered examples in <paramref name="cover"/></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Clustering.Distribution">
            <summary>
                Class representing a distribution over sampling strategies.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.Distribution.#ctor(Microsoft.ProgramSynthesis.Utils.Record{Microsoft.ProgramSynthesis.Utils.Clustering.SamplingStrategy,System.Double}[])">
            <summary>
                Constructor taking a list of elements in the support of the distribution and their probabilities.
            </summary>
            <param name="elementProbabilities">A list of pairs of elements and their corresponding probabilities.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.Distribution.Sample(System.Random)">
            <summary>
                Return an element from the distribution according to the probability distribution.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearnerUtils">
            <summary>
                Static class with helper functions for the disjunction learning algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearnerUtils.PickSamplingStrategy(Microsoft.ProgramSynthesis.Utils.Clustering.SamplingMetaStrategy,System.Random)">
            <summary>
                Pick a sampling strategy according to the distribution (<see cref="T:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearnerUtils.MetaStrategyDistributions" />) corresponding to
                <paramref name="metaStrategy" />.
            </summary>
            <param name="metaStrategy"></param>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearnerUtils.PickBruteForceLimit(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Int32)">
            <summary>
                Returns the last number in <paramref name="subPoolSizes" /> for which the number of brute force checks required
                is less than <paramref name="casesBound" /> if it exists, and nothing otherwise.
            </summary>
            <param name="subPoolSizes"></param>
            <param name="disjunctionSizes"></param>
            <param name="casesBound"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearnerUtils.MetaStrategyDistributions">
            <summary>
                Defines the distributions of sampling strategies for each sampling meta-strategy
                score and the number of examples it covers. These were hand-picked to work well on the
                problems in the test-suite.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearnerUtils.MetaStrategyDistributions.RandomDistribution">
            <summary>
                Always pick <see cref="F:Microsoft.ProgramSynthesis.Utils.Clustering.SamplingStrategy.Random" />.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearnerUtils.MetaStrategyDistributions.MoreCoverageDistribution">
            <summary>
                More coverage is obtained by either:
                (a) growing a cluster <see cref="F:Microsoft.ProgramSynthesis.Utils.Clustering.SamplingStrategy.GrowCluster" />,
                (b) growing a covering cluster <see cref="F:Microsoft.ProgramSynthesis.Utils.Clustering.SamplingStrategy.GrowCoveringCluster" />,
                (c) making a cluster from uncovered examples <see cref="F:Microsoft.ProgramSynthesis.Utils.Clustering.SamplingStrategy.ClusterFromUncovered" />, or
                (d) making a cluster from two random examples <see cref="F:Microsoft.ProgramSynthesis.Utils.Clustering.SamplingStrategy.Random" />.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearnerUtils.MetaStrategyDistributions.MoreClustersDistribution">
            <summary>
                More clusters are obtained by either:
                (a) splitting a cluster <see cref="F:Microsoft.ProgramSynthesis.Utils.Clustering.SamplingStrategy.GrowCluster" />,
                (b) splitting a covering cluster <see cref="F:Microsoft.ProgramSynthesis.Utils.Clustering.SamplingStrategy.GrowCoveringCluster" />, or
                (c) making a cluster from two random examples <see cref="F:Microsoft.ProgramSynthesis.Utils.Clustering.SamplingStrategy.Random" />.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearnerUtils.MetaStrategyDistributions.FewerClustersDistribution">
            <summary>
                Fewer clusters are obtained by either:
                (a) merging a cluster <see cref="F:Microsoft.ProgramSynthesis.Utils.Clustering.SamplingStrategy.GrowCluster" />,
                (b) merging a covering cluster <see cref="F:Microsoft.ProgramSynthesis.Utils.Clustering.SamplingStrategy.GrowCoveringCluster" />, or
                (c) making a cluster from two random examples <see cref="F:Microsoft.ProgramSynthesis.Utils.Clustering.SamplingStrategy.Random" />.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearnerUtils.MetaStrategyDistributions.StategyDistributions">
            <summary>
                Dictionary mapping <see cref="T:Microsoft.ProgramSynthesis.Utils.Clustering.SamplingMetaStrategy">sampling meta strategies</see> to distributions over
                <see cref="T:Microsoft.ProgramSynthesis.Utils.Clustering.SamplingStrategy">sampling strategies</see>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.DisjunctionLearnerUtils.IsSingleton``1(Microsoft.ProgramSynthesis.Utils.Clustering.Cluster{``0})">
            <summary>
                Returns true if and only if there is exactly one data point (excluding multiplicities) in the cluster.
            </summary>
            <param name="cluster"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Clustering.ExampleSubset">
            <summary>
                This struct is a concise data-structure for representing subsets
                of a number of States. It keeps around:
                a. Bitset representing the elements which are present
                b. A List of states that are the actual states
                c. The cardinality of the set.
                Note that cardinality is not the number of bits set in the bitset; it
                takes into account the multiplicities of the states in the problem.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.ExampleSubset.States">
            <summary>
                List of unique states in the subset.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.ExampleSubset.Cardinality">
            <summary>
                Number of states in the subset (including multiplicities).
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ExampleSubset.#ctor(System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.State},System.Collections.Generic.IReadOnlyList{System.UInt32},System.Predicate{Microsoft.ProgramSynthesis.State})">
            <summary>
                Construct an example subset from a given univerise of states,
                an array representing their multiplicities, and a predicate
                saying if a state is to belong to the subset.
            </summary>
            <param name="allExamples"></param>
            <param name="allExampleCounts"></param>
            <param name="p"></param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ExampleSubset.#ctor(System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.State},System.Collections.Generic.IReadOnlyList{System.UInt32},System.Collections.BitArray)">
            <summary>
                Helper constructor if you already have the bitset around.
            </summary>
            <param name="allExamples">Space of examples.</param>
            <param name="allExampleCounts">Counts of the examples in the space.</param>
            <param name="bitset">Bitset representing which examples are in the subset.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ExampleSubset.SampleWithReplacement(System.Random,System.Int32)">
            <summary>
                Sample the subset uniformly at random, with replacement, and ignoring
                multiplicities.
            </summary>
            <param name="rng"></param>
            <param name="sampleSize"></param>
            <returns>Returns an IEnumerable with <paramref name="sampleSize" /> number of samples</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ExampleSubset.HasIntersectionWith(Microsoft.ProgramSynthesis.Utils.Clustering.ExampleSubset)">
            <summary>
                Returns true iff this subset and the other share a common element.
            </summary>
            <param name="other"></param>
            <returns>Returns true iff this subset has an intersection with <paramref name="other" /></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ExampleSubset.UnionComplement(System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.State},System.Collections.Generic.IReadOnlyList{System.UInt32},System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Utils.Clustering.ExampleSubset})">
            <summary>
                Return the complement of the union of the given subsets, w.r.t the universe
                of <paramref name="allExamples" />.
            </summary>
            <param name="allExamples">Universe of examples</param>
            <param name="allExampleCounts">Multiplicities of each example</param>
            <param name="subsets">Subsets of examples</param>
            <returns>
                ExampleSubset representing <paramref name="allExamples" /> \setminus \bigcup <paramref name="subsets" />
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ExampleSubset.Union(System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.State},System.Collections.Generic.IReadOnlyList{System.UInt32},System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Utils.Clustering.ExampleSubset})">
            <summary>
                Return the union of the given subsets.
            </summary>
            <param name="allExamples"></param>
            <param name="allExampleCounts"></param>
            <param name="subsets"></param>
            <returns>Returns an ExampleSubset with the union of all subsets in <paramref name="subsets" /></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ExampleSubset.Difference(System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.State},System.Collections.Generic.IReadOnlyList{System.UInt32},Microsoft.ProgramSynthesis.Utils.Clustering.ExampleSubset)">
            <summary>
                Return the difference between this example subset and the <paramref name="other" />.
            </summary>
            <param name="allExamples"></param>
            <param name="allExampleCounts"></param>
            <param name="other"></param>
            <returns>
                Returns an ExampleSubset with the states in the current subset that are not in <paramref name="other" />
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ExampleSubset.SuperSetOf(Microsoft.ProgramSynthesis.Utils.Clustering.ExampleSubset)">
            <summary>
                Returns true if this subset is a superset of the other.
            </summary>
            <param name="other"></param>
            <returns>Returns true if this subset is a superset of the <paramref name="other" /></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ExampleSubset.GetEnabledIndices">
            <summary>
                The set of enabled indices in this subset. Note that indices are
                w.r.t to the List allExamples this subset was constructed with.
            </summary>
            <returns>IEnumerable of the set of enabled indices</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ExampleSubset.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ExampleSubset.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Clustering.LinkageCriterion`1">
            <summary>
                Defines the delegate <see cref="T:Microsoft.ProgramSynthesis.Utils.Clustering.LinkageCriterion`1.Type" /> for a linkage-criterion function over data points of type
                <typeparamref name="TData" />, and provides some default implementations.
            </summary>
            <typeparam name="TData">The type of data points to be clustered.</typeparam>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Clustering.LinkageCriterion`1.Type">
            <summary>
                The delegate type for a function which computes the cost of linking <paramref name="bigCluster" /> and
                <paramref name="smallCluster" />.
            </summary>
            <param name="bigCluster">The cluster with greater id - must be a non-singleton cluster.</param>
            <param name="smallCluster">The cluster with smaller id - may or may not be a singleton cluster.</param>
            <param name="linkageCostLookupFunc">A function which can be queried for linkage-cost subcomputations.</param>
            <returns>
                The cost of linking <paramref name="bigCluster" /> and <paramref name="smallCluster" />.
            </returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.LinkageCriterion`1.Complete">
            <summary>
                The complete linkage criterion for hierarchical clustering.
                [https://en.wikipedia.org/wiki/Complete-linkage_clustering]
                The optimized algorithm computes maximum linkage cost for child clusters,
                not all points within the cluster.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.LinkageCriterion`1.GroupAverage">
            <summary>
                The unweighted pair-group linkage criterion for hierarchical clustering.
                [https://en.wikipedia.org/wiki/UPGMA]
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPredicate`1">
            <summary>
                A class representing a predicate used for clustering.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPredicate`1.Program">
            <summary>
                PROSE program node for the predicate.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPredicate`1.Score">
            <summary>
                Score of the PROSE program <see cref="F:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPredicate`1.Program"/>.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPredicate`1.Description">
            <summary>
                A text description of the program.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPredicate`1.CompiledProgram">
            <summary>
                A compiled version of the PROSE program <see cref="F:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPredicate`1.Program"/>.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPredicate`1.ExtractData">
            <summary>
                A program to extract date from <see cref="T:Microsoft.ProgramSynthesis.State"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ClusterPredicate`1.ToCluster(System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.State},System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.State},System.UInt32)">
            <summary>
               Build a cluster from the cluster predicate.
            </summary>
            <param name="generators">The examples used to generate this cluster.</param>
            <param name="allMatchedStates">All data in this cluster.</param>
            <param name="cardinality">The number of data points in this cluster.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Clustering.IPredicateLearner`1">
            <summary>
                An interface each predicate learner has to implement. The interface provides the <see cref="M:Microsoft.ProgramSynthesis.Utils.Clustering.IPredicateLearner`1.Learn(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.State},System.Threading.CancellationToken)"/>
                method to generate predicates from positive samples.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.IPredicateLearner`1.Learn(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.State},System.Threading.CancellationToken)">
            <summary>
                Construct a predicate from a number of positive samples.
            </summary>
            <param name="samples">Positive examples from which to generate the predicate.</param>
            <param name="cancel">Cancellation token for the learn method.</param>
            <returns>
                A tuple containing the learned predicate and the score of the program.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Clustering.PredicateLearner`1">
            <inheritdoc />
            <summary>
                A predicate learner that is based on learning from a single synthesis task.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.PredicateLearner`1.#ctor(Microsoft.ProgramSynthesis.Learning.LearningTask,Microsoft.ProgramSynthesis.Features.Feature{System.Double},Microsoft.ProgramSynthesis.Learning.SynthesisEngine,System.Func{Microsoft.ProgramSynthesis.AST.ProgramNode,`0},System.Func{Microsoft.ProgramSynthesis.State,System.Object},System.Func{`0,System.Predicate{System.Object}},System.Func{`0,System.String})">
            <summary>
                Construct a predicate learner from a learning task and a score function.
            </summary>
            <param name="task">The synthesis task to learn predicates from positive samples.</param>
            <param name="score">The ranking feature for the learned programs.</param>
            <param name="synthesisEngine">The synthesis engine to use for learning.</param>
            <param name="extract">A function that extracts the data from the state to use for the compiled program.</param>
            <param name="compile">A compilation function for the predicates learnt.</param>
            <param name="cast">A casting function to cast from program nodes to predicates.</param>
            <param name="describe">A function that describes a give program node.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.PredicateLearner`1.Learn(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.State},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Clustering.ProblemSpace`1">
            <summary>
                A description of the space for clustering - contains information about the points,
                and a distance function over them.
                This class also caches the computed exact distances and upper bounds on unknown distances.
            </summary>
            <typeparam name="TData">The type of data points in the space.</typeparam>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Clustering.ProblemSpace`1.DistanceBoundFunction">
            <summary>
                A function which returns an estimate of the max distance to a given point point from the end-points
                of the generator of this function.
            </summary>
            <param name="d">
                A data point for estimating distance to, from either end-points of the generator of this function.
            </param>
            <returns>
                Upper bounds on the distance to <paramref name="d" /> from both end-points of the generator.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ProblemSpace`1.#ctor(System.Collections.Generic.IReadOnlyDictionary{`0,System.UInt32},System.Func{`0,`0,System.Collections.Generic.KeyValuePair{System.Double,Microsoft.ProgramSynthesis.Utils.Clustering.ProblemSpace{`0}.DistanceBoundFunction}},System.Double)">
            <summary>
                Initializes a new instance of ProblemSpace from groups of equivalent points.
            </summary>
            <param name="pointsWithCounts">Groups of equivalent data points mapped to their counts.</param>
            <param name="distanceFunction">
                A function that computes the distance between two point clusters and returns it with
                a <see cref="T:Microsoft.ProgramSynthesis.Utils.Clustering.ProblemSpace`1.DistanceBoundFunction"/> to compute distance bounds on other points.
            </param>
            <param name="singletonCost">The cost of singleton clusters.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ProblemSpace`1.#ctor(System.Collections.Generic.IReadOnlyDictionary{`0,System.UInt32},System.Func{`0,`0,System.Double},System.Double)">
            <summary>
                Initializes a new instance of ProblemSpace from groups of equivalent points.
            </summary>
            <param name="pointsWithCounts">Groups of equivalent data points mapped to their counts.</param>
            <param name="distanceFunction">A function that computes the distance between two point clusters.</param>
            <param name="singletonCost">The cost of singleton clusters.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ProblemSpace`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0},System.Func{`0,`0,System.Collections.Generic.KeyValuePair{System.Double,Microsoft.ProgramSynthesis.Utils.Clustering.ProblemSpace{`0}.DistanceBoundFunction}},System.Double)">
            <summary>
                Initializes a new instance of ProblemSpace from data points and an EqualityComparer.
            </summary>
            <param name="points">The data points.</param>
            <param name="equalityComparer">An EqualityComparer over the data points.</param>
            <param name="distanceFunction">
                A function that computes the distance between two point clusters and returns it with
                a <see cref="T:Microsoft.ProgramSynthesis.Utils.Clustering.ProblemSpace`1.DistanceBoundFunction"/> to compute distance bounds on other points.
            </param>
            <param name="singletonCost">The cost of singleton clusters.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ProblemSpace`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0},System.Func{`0,`0,System.Double},System.Double)">
            <summary>
                Initializes a new instance of ProblemSpace from data points and an EqualityComparer.
            </summary>
            <param name="points">The data points.</param>
            <param name="equalityComparer">An EqualityComparer over the data points.</param>
            <param name="distanceFunction">A function that computes the distance between two point clusters.</param>
            <param name="singletonCost">The cost of singleton clusters.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.ProblemSpace`1.Count">
            <summary>
                Total number of points in the space.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.ProblemSpace`1.SingletonCost">
            <summary>
                The cost of singleton clusters.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.ProblemSpace`1.PointsWithCounts">
            <summary>
                The data points, with their repetition counts.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Clustering.ProblemSpace`1.PointClusters">
            <summary>
                The dendrograms containing equivalent data points.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ProblemSpace`1.ExactDistanceBetween(`0,`0,System.Boolean)">
            <summary>
                Computes the distance between two points.
            </summary>
            <param name="d1">The first point.</param>
            <param name="d2">The second point.</param>
            <param name="updateMaxDistances">Whether or not to update upper bound on unknown distances from the end-points.</param>
            <returns>
                The distance between the points.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ProblemSpace`1.MaxDistanceBetween(`0,`0)">
            <summary>
                Gets the known maximum distance (or exact distance if unknown) between two points.
            </summary>
            <param name="d1">The first point.</param>
            <param name="d2">The second point.</param>
            <returns>
                The known maximum distance (or exact distance if unknown) between the points.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Clustering.ScoreUtils`1">
            <summary>
                A class that defines how scores of programs used for defining clusters is to be transformed into a preference
                value.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.ScoreUtils`1.SignificantScoreRatio">
            <summary>
                This constant is a bound on the ratio of the scores of programs that are considered "comparable". In short, we
                ignore a cluster if it is incomparably worse than others we have picked.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.ScoreUtils`1.InsignificantlyCheapScore">
            <summary>
                This constant is a limit on the scores of programs that are "really" cheap in the current DSL. The idea is to use a
                cluster even if it is much worse (by score ratio) than the previous, as long as it has an "insignificantly cheap"
                score.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Clustering.ScoreUtils`1.BaseOffsetScore">
            <summary>
                This constant is added to scores to normalize them. The main intention is to avoid scores that are too close to
                zero, as our primary preference metric for clusters in (cardinality)/(score) which diverges in case score is close
                to zero. Adding this offset makes the preference function (cardinality)/(score + offset) which is much better
                behaved.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ScoreUtils`1.#ctor(System.Double,System.Double,System.Double)">
            <summary>
                Construct from the given score transformation constants.
            </summary>
            <param name="significantScoreRatio"><see cref="F:Microsoft.ProgramSynthesis.Utils.Clustering.ScoreUtils`1.SignificantScoreRatio"/></param>
            <param name="insignificantlyCheapScore"><see cref="F:Microsoft.ProgramSynthesis.Utils.Clustering.ScoreUtils`1.InsignificantlyCheapScore"/></param>
            <param name="baseOffsetScore"><see cref="F:Microsoft.ProgramSynthesis.Utils.Clustering.ScoreUtils`1.BaseOffsetScore"/></param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ScoreUtils`1.SignificantlyWorseThan(Microsoft.ProgramSynthesis.Utils.Clustering.Cluster{`0},Microsoft.ProgramSynthesis.Utils.Clustering.Cluster{`0})">
            <summary>
                Return true iff <paramref name="current" /> cluster has a ``much higher'' score (ratio)
                than the <paramref name="other" /> cluster. Also, ``really cheap'' clusters are
                considered good no matter what the ratio is.
                Underlying DSL dependent parameters:
                a) Cost under which clusters are considered ``really cheap''.
                b) Ratio over which a score is considered ``much higher'' than another.
            </summary>
            <param name="current"></param>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ScoreUtils`1.SetCardinalityExponent(System.Double)">
            <summary>
                Set the exponent for the cardinality in the Preference function.
            </summary>
            <param name="exponent"></param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ScoreUtils`1.NormalizeScore(System.Double)">
            <summary>
                Add the base offset score to the score to get a normalized version.
            </summary>
            <param name="score"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ScoreUtils`1.Preference(System.Double,System.UInt32)">
            <summary>
                Given a double <paramref name="score" /> and the number of examples <paramref name="size" />
                it covers, return a double scoring "preferred" it is.
            </summary>
            <param name="score"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Clustering.ScoreUtils`1.Preference(Microsoft.ProgramSynthesis.Utils.Clustering.Cluster{`0})">
            <summary>
                Calculates the preference values of a given cluster based on the best program
                score and the number of examples it covers.
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.CodeBuilder">
            <summary>
                A helper class for generating indented code.  Indentation is automatically added to lines.
                Trailing whitespace is removed from lines.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CodeBuilder.IndentationContext.#ctor(Microsoft.ProgramSynthesis.Utils.CodeBuilder,System.UInt32,System.String)">
            <summary>
                Constructor.
            </summary>
            <param name="builder">The <see cref="T:Microsoft.ProgramSynthesis.Utils.CodeBuilder"/> associated with this object.</param>
            <param name="additionalIndent">The number of indentation levels to add.</param>
            <param name="endLine">Line to add after disposing the indentation context</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CodeBuilder.IndentationContext.Dispose">
            <summary>
                Performs cleanup actions at the end of the lifetime.
                This involves decreasing the level of indentation on
                the <see cref="T:Microsoft.ProgramSynthesis.Utils.CodeBuilder"/> object that was used to
                construct this <see cref="T:Microsoft.ProgramSynthesis.Utils.CodeBuilder.IndentationContext"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CodeBuilder.#ctor(System.UInt32)">
            <summary>
                Constructor.
            </summary>
            <param name="indentSize">The number of spaces each level of indentation adds.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CodeBuilder.PushIndent(System.UInt32)">
            <summary>
                Push a new indent level.
            </summary>
            <param name="additionalIndent">The amount of indentation to add.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CodeBuilder.PopIndent">
            <summary>
                Pop an indent level (and restore the indent level to before the last call to <see cref="M:Microsoft.ProgramSynthesis.Utils.CodeBuilder.PushIndent(System.UInt32)" />).
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CodeBuilder.Append(System.String)">
            <summary>
                Append the given code.  The currently active indentation level is applied at newlines.
            </summary>
            <exception cref="T:System.ArgumentException">Thrown when a line already contains leading whitespace</exception>
            <param name="code">The code to append.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CodeBuilder.AppendIndented(System.String)">
            <summary>
                Append the given, already-indented code.  The currently active indentation level is also applied at newlines.
            </summary>
            <param name="code">The code to append.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CodeBuilder.Prepend(Microsoft.ProgramSynthesis.Utils.CodeBuilder)">
            <summary>
                Prepend the given, already-indented code. The indentation of this code is not changed. 
                If <paramref name="code"/> does not end with newline, a newline is appended to it.
            </summary>
            <param name="code">The code to prepend.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CodeBuilder.Append(Microsoft.ProgramSynthesis.Utils.CodeBuilder)">
            <summary>
                Append the given, already-indented code.  The currently active indentation level is also applied at newlines.
            </summary>
            <param name="code">The code to append.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CodeBuilder.AppendLine(System.String)">
            <summary>
                Append the given code followed by a line terminator.  The currently active indentation level is applied at newlines.
            </summary>
            <param name="codeLine">The line to append.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CodeBuilder.AppendLine">
            <summary>Append a blank line.</summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CodeBuilder.AppendBlock(System.String)">
            <summary>
                Appends a block of code using the current indentation.
            </summary>
            <param name="block">The code block.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CodeBuilder.AppendDelimitedList(System.String,System.Collections.Generic.IReadOnlyList{System.String},System.String,System.String,System.String,System.Collections.Generic.IReadOnlyList{System.String},System.Int32)">
            <summary>
                Appends a delimited list at the current indentation. The appended code has the following form:
                [PREFIX][OPEN]([ELEMENT][SEP])*[CLOSE]
                or
                [PREFIX][OPEN]
                ([INDENTATION][ELEMENT][SEP][ELEMENT COMMENT]?)*
                [CLOSE]
                
                The first form is generated if there are no element comments and the whole line
                (with previous indentation) is not longer than <paramref name="maxLineLength" />.
            </summary>
            <param name="prefix">The prefix to generate before the list.</param>
            <param name="elements">The list of elements to generate.</param>
            <param name="sep">The separator to generate between elements.</param>
            <param name="open">The string to generate before the list.</param>
            <param name="close">The string to generate after the list.</param>
            <param name="elementComments">THe list of comments for each element (can be null).</param>
            <param name="maxLineLength">The maximum lenght of the line (in single line mode).</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CodeBuilder.NewScope(System.String,System.UInt32)">
            <summary>
                Creates a new <see cref="T:Microsoft.ProgramSynthesis.Utils.CodeBuilder.IndentationContext"/>.
            </summary>
            <param name="introduction">
                String to add before the braces and indentation context.  If non-empty, then a new line will be
                appended after it.
            </param>
            <param name="additionalIndent">Number of indentation levels to add.</param>
            <returns>A new <see cref="T:Microsoft.ProgramSynthesis.Utils.CodeBuilder.IndentationContext"/>.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CodeBuilder.NewBracesScope(System.String,System.UInt32)">
            <summary>
                Creates a new <see cref="T:Microsoft.ProgramSynthesis.Utils.CodeBuilder.IndentationContext"/> with an introduction and
                surrounded by braces.
            </summary>
            <param name="introduction">String to add before the braces and indentation context.</param>
            <param name="additionalIndent">Number of indentation levels to add.</param>
            <returns>A new <see cref="T:Microsoft.ProgramSynthesis.Utils.CodeBuilder.IndentationContext"/>.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CodeBuilder.GetCode">
            <summary>Returns the built-up code.</summary>
            <returns>The built-up code.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.CodeTypeReference.ArrayElementType">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.CodeTypeReference.ArrayRank">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.CodeTypeReference.BaseType">
            <devdoc>
               <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.CodeTypeReferenceCollection.Item(System.Int32)">
            <devdoc>
            <para>Represents the entry at the specified index of the <see cref='T:System.CodeDom.CodeTypeReference'/>.</para>
            </devdoc>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CodeTypeReferenceCollection.Add(Microsoft.ProgramSynthesis.Utils.CodeTypeReference)">
            <devdoc>
               <para>Adds a <see cref='T:System.CodeDom.CodeTypeReference'/> with the specified value to the
               <see cref='T:System.CodeDom.CodeTypeReferenceCollection'/> .</para>
            </devdoc>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.Transpose``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
                Transposes a collection of collections.
            </summary>
            <typeparam name="T">The type of elements.</typeparam>
            <param name="source">The source collection (of collections).</param>
            <returns>
                The transposed collection of <paramref name="source"/>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.SplitFixedLength``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
                Splits a collection to a collection of collections of length <paramref name="length"/>.
            </summary>
            <typeparam name="T">The type of elements.</typeparam>
            <param name="source">The source collection (of collections).</param>
            <returns>
                The collection of collections of length <paramref name="length"/>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.ArgMax``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},``1@)">
            <summary>
                Find the input that maximizes a given function.
            </summary>
            <typeparam name="TElement">The type of the inputs.</typeparam>
            <typeparam name="TComparable">The type of the function outputs.</typeparam>
            <param name="xs">The inputs to consider.</param>
            <param name="func">The function we are trying to maximize.</param>
            <param name="maxValue">The value the function attained at its maximum.</param>
            <returns>The input that maximizes the function.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.MaybeArgMax``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
                Find the input that maximizes a given function.
            </summary>
            <typeparam name="TElement">The type of the inputs.</typeparam>
            <typeparam name="TComparable">The type of the function outputs.</typeparam>
            <param name="seq">The inputs to consider.</param>
            <param name="keySelector">The function we are trying to maximize.</param>
            <returns>
                The input that maximizes the function, if <paramref name="seq" /> is non-empty,
                <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.ArgMaxBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,``2},``1@)">
            <summary>
                Find y in xs such that forall x in xs, by(func(y)) >= by(func(x)), set maxResult
                to func(y) and return y.
            </summary>
            <typeparam name="TElement">The type of the inputs.</typeparam>
            <typeparam name="TResult">The type of the function outputs.</typeparam>
            <typeparam name="TComparable">The type of the comparable output by the by function</typeparam>
            <param name="xs">The inputs to consider.</param>
            <param name="func">The function to apply over the inputs.</param>
            <param name="by">The funciton we are trying to maximize.</param>
            <param name="maxResult">The value from func which maximizes by</param>
            <returns>The input that maximizes the by function</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.ArgMin``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},``1@)">
            <summary>
                Find the input that minimizes a given function.
            </summary>
            <typeparam name="TElement">The type of the inputs.</typeparam>
            <typeparam name="TComparable">The type of the function outputs.</typeparam>
            <param name="xs">The inputs to consider.</param>
            <param name="func">The function we are trying to minimize.</param>
            <param name="minValue">The value the function attained at its minimum.</param>
            <returns>The input that minimizes the function.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.MaybeArgMin``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
                Find the input that minimizes a given function.
            </summary>
            <typeparam name="TElement">The type of the inputs.</typeparam>
            <typeparam name="TComparable">The type of the function outputs.</typeparam>
            <param name="seq">The inputs to consider.</param>
            <param name="keySelector">The function we are trying to minimize.</param>
            <returns>
                The input that minimizes the function, if <paramref name="seq" /> is non-empty,
                <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.ArgMinMultiple``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
                Find the inputs that minimize a given function.
            </summary>
            <typeparam name="TElement">The type of the inputs.</typeparam>
            <typeparam name="TComparable">The type of the function outputs.</typeparam>
            <param name="xs">The inputs to consider.</param>
            <param name="func">The function we are trying to minimize.</param>
            <returns>
                All the inputs from <paramref name="seq" /> that minimize the function.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.ArgMaxMultiple``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
                Find the inputs that maximize a given function.
            </summary>
            <typeparam name="TElement">The type of the inputs.</typeparam>
            <typeparam name="TComparable">The type of the function outputs.</typeparam>
            <param name="xs">The inputs to consider.</param>
            <param name="func">The function we are trying to maximize.</param>
            <returns>
                All the inputs from <paramref name="seq" /> that maximize the function.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.MaxIndex``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
                Return the index of the maximum element in the collection <paramref name="xs"/> ordered by
                the keys as computed by <paramref name="keyFunc"/>. If more than one element is the maximum,
                return the first index of all the maximum elements.
            </summary>
            <typeparam name="TElement">The type of the inputs.</typeparam>
            <typeparam name="TComparable">The type of the function outputs.</typeparam>
            <param name="xs">The inputs to consider.</param>
            <param name="keyFunc">The key function we are trying to minimize.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.MaybeExtrema``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
                Compute the minimum and maximum values (i.e. both extrema) of a collection. <c>xs.MaybeExtrema()</c> is equivalent
                to
                <c>xs.Any().Then(Record.Create(xs.Min(), xs.Max()))</c> except the former iterates over the collection only once.
            </summary>
            <typeparam name="T">Type of elements of the collection.</typeparam>
            <param name="xs">Collection to search through.</param>
            <param name="comparer">Comparer to use to define extrema. If <c>null</c>, <see cref="P:System.Collections.Generic.Comparer`1.Default" /> is used.</param>
            <returns>
                A <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`2" /> where <see cref="F:Microsoft.ProgramSynthesis.Utils.Record`2.Item1" /> is the minimum element of
                <paramref name="xs" /> and <see cref="F:Microsoft.ProgramSynthesis.Utils.Record`2.Item2" /> is the maximum element of <paramref name="xs" />
                or <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if <paramref name="xs" /> is empty.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.Extrema``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
                Compute the minimum and maximum values (i.e. both extrema) of a collection. <c>xs.Extrema()</c> is equivalent to
                <c>Record.Create(xs.Min(), xs.Max())</c> except the former iterates over the collection only once.
            </summary>
            <typeparam name="T">Type of elements of the collection.</typeparam>
            <param name="xs">Non-empty collection to search through.</param>
            <param name="comparer">Comparer to use to define extrema. If <c>null</c>, <see cref="P:System.Collections.Generic.Comparer`1.Default" /> is used.</param>
            <returns>
                A <see cref="T:Microsoft.ProgramSynthesis.Utils.Record`2" /> where <see cref="F:Microsoft.ProgramSynthesis.Utils.Record`2.Item1" /> is the minimum element of
                <paramref name="xs" /> and <see cref="F:Microsoft.ProgramSynthesis.Utils.Record`2.Item2" /> is the maximum element of <paramref name="xs" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.GetOrAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>
                Tries to get the value with the specified key; alternatively, if none exists, adds a value for that key. As this
                performs two separate dictionary method calls, this is not thread-safe. Consider using locks or
                <see cref="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})" /> if thread-safety is desired.
            </summary>
            <typeparam name="TKey">Type of keys.</typeparam>
            <typeparam name="TValue">Type of values.</typeparam>
            <param name="dict">Dictionary to get value from or modify.</param>
            <param name="key">Key to get/set value for.</param>
            <param name="valueFunc">
                Function to use to produce new value if there is not a value already in
                <paramref name="dict" /> for <paramref name="key" />. <paramref name="key" /> will be provided as an argument.
            </param>
            <returns>
                The value for <paramref name="key" /> in <paramref name="dict" />; either the one that was already present or
                the new one generated by <paramref name="valueFunc" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.GetOrAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
                Tries to get the value with the specified key; alternatively, if none exists, adds a value for that key. As this
                performs two separate dictionary method calls, this is not thread-safe. Consider using locks or
                <see cref="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,`1)" /> if thread-safety is desired.
            </summary>
            <typeparam name="TKey">Type of keys.</typeparam>
            <typeparam name="TValue">Type of values.</typeparam>
            <param name="dict">Dictionary to get value from or modify.</param>
            <param name="key">Key to get/set value for.</param>
            <param name="newValue">
                Value to use if there is not a value already in <paramref name="dict" /> for <paramref name="key" />.
            </param>
            <returns>
                The value for <paramref name="key" /> in <paramref name="dict" />; either the one that was already present or
                <paramref name="newValue" />
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.GetOrCreateValue``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>
                Tries to get the value with the specified key; alternatively, if none exists, adds a value for that key by calling
                the default constructor for the value type. As this performs two separate dictionary method calls, this is not
                thread-safe. Consider using locks or
                <see cref="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})" /> if thread-safety is desired.
            </summary>
            <typeparam name="TKey">Type of keys.</typeparam>
            <typeparam name="TValue">Type of values. This type's default constructor will be used to construct new values.</typeparam>
            <param name="dict">Dictionary to get value from or modify.</param>
            <param name="key">Key to get/set value for.</param>
            <returns>
                The value for <paramref name="key" /> in <paramref name="dict" />; either the one that was already present or
                the newly constructed one.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.GetOrEmpty``2(System.Collections.Generic.IReadOnlyDictionary{``0,System.Collections.Generic.IReadOnlyCollection{``1}},``0)">
            <summary>
                Returns the collection at the given <paramref name="key" /> in <paramref name="dict" /> or an empty collection if
                <paramref name="key" /> is not in <paramref name="dict" />.
            </summary>
            <typeparam name="TKey">Type of keys of the dictionary.</typeparam>
            <typeparam name="TElement">Type of elements of the collections which are the values of the dictionary.</typeparam>
            <param name="dict">The dictionary.</param>
            <param name="key">The key to look up.</param>
            <returns>Either <c>dict[key]</c> if it exists or an empty collection otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.GetOrDefault``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
                Returns the value at the given <paramref name="key" /> in <paramref name="dict" /> or 
                <paramref name="def"/>.
            </summary>
            <typeparam name="TKey">Type of keys in the dictionary.</typeparam>
            <typeparam name="TValue">Type of elements in the dictionary.</typeparam>
            <param name="dict">The dictionary.</param>
            <param name="key">The key to look up.</param>
            <param name="def">The default value.</param>
            <returns>Either <c>dict[key]</c> if it exists of <c>def</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.OrderedPairs``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
                Cartesian product of two sequences <paramref name="seq1"/> and <paramref name="seq2"/>
                with the product elements returned as pairs.
            </summary>
            <typeparam name="T1">Type of elements in the first sequence.</typeparam>
            <typeparam name="T2">Type of elements in the second sequence.</typeparam>
            <param name="seq1">First sequence.</param>
            <param name="seq2">Second sequence.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.UnorderedPairs``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary>
                Returns an enumerable of unordered pairs of elements from <paramref name="sequence"/>,
                i.e., if (a, b) is returned, then (b, a) will not be returned. The flag <paramref name="reflexive"/>
                controls if pairs of the form (a, a) are to be returned.
            </summary>
            <typeparam name="T">Type of elements in the sequence.</typeparam>
            <param name="sequence">Enumerable from which pairs are to be drawn.</param>
            <param name="reflexive">Include unordered pairs with equal elements, or not.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.Enumerate``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Return an enumerable of pairs with the first component of the pair being an index
                and the second component being from <paramref name="seq"/>.
            </summary>
            <typeparam name="T">Type of elements in <paramref name="seq"/></typeparam>
            <param name="seq">The enumerable to enumerate.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.Indices``1(System.Collections.Generic.IReadOnlyCollection{``0})">
            <summary>
                Return an enumerable of indices for a given collection.
            </summary>
            <typeparam name="T">Type of elements in <paramref name="seq"/></typeparam>
            <param name="seq">The collection to return indices for.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.Collect``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Returns just the non-<c>null</c> elements of <paramref name="seq" />.
            </summary>
            <typeparam name="T">The type of elements of <paramref name="seq"/>.</typeparam>
            <param name="seq">Sequence to return non-<c>null</c> elements of.</param>
            <returns>A sequence without <c>null</c> elements.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.Collect``1(System.Collections.Generic.IEnumerable{System.Nullable{``0}})">
            <summary>
                Returns just the non-<c>null</c> elements of <paramref name="seq" />, removing the <see cref="T:System.Nullable`1" /> part
                of the type.
            </summary>
            <typeparam name="T">The type of non-<c>null</c> elements of <paramref name="seq" />.</typeparam>
            <param name="seq">Sequence to return non-<c>null</c> elements of.</param>
            <returns>A sequence without <c>null</c> elements, with the type of the base struct.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.HasAtLeast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
               Determine if an enumerable has at least N elements
            </summary>
            <typeparam name="T">The type of elements.</typeparam>
            <param name="source">The enumerable.</param>
            <param name="n">The size to compare against the enumerable</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.HasAtMost``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
               Determine if an enumerable has at most N elements
            </summary>
            <typeparam name="T">The type of elements.</typeparam>
            <param name="source">The enumerable.</param>
            <param name="n">The size to compare against the enumerable</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.TakeExceptEvery``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
                Splices a subsequence where the zero-based indices of the elements from <paramref name="source" />
                are not perfectly divisible by <paramref name="step" />
            </summary>
            <typeparam name="T">The type of the elements in <paramref name="source" /></typeparam>
            <param name="source">The original sequence of elements to be filtered.</param>
            <param name="step">The step size.</param>
            <returns>
                A subsequence of <paramref name="source" /> such that the zero-based index (relative to
                <paramref name="source" />) of every element in the returned sequence is not divisible by <paramref name="step" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.DropLast``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Drop the last element from an enumerable.
            </summary>
            <typeparam name="T">The type of elements.</typeparam>
            <param name="source">The enumerable.</param>
            <returns>
                A new enumerable without the last element.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.DropLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
                Drop the last <paramref name="count" /> elements from an enumerable.
            </summary>
            <typeparam name="T">The type of elements.</typeparam>
            <param name="source">The enumerable.</param>
            <param name="count">Number of elements to drop.</param>
            <returns>
                A new enumerable without the last <paramref name="count" /> elements (or empty if fewer than that many elements).
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.TakeKDistinctOn``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Int32,System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
                Takes the first <paramref name="k" /> groups of elements from <paramref name="seq" /> where groups are defined by
                adjacent elements that return equal values from <paramref name="keySelector" />. The groups are flattened.
            </summary>
            <typeparam name="T">The type of elements.</typeparam>
            <typeparam name="TKey">The type of keys generated by <paramref name="keySelector" />.</typeparam>
            <param name="seq">The enumerable.</param>
            <param name="keySelector"></param>
            <param name="k">
                Maximum number of distinct values <paramref name="keySelector" /> should return on the resulting
                sequence.
            </param>
            <param name="comparer">Optional comparer for values returned by <paramref name="keySelector" />.</param>
            <returns>
                A prefix of <paramref name="seq" /> that returns no more than <paramref name="k" /> distinct values when
                mapped with <paramref name="keySelector" />; may only return fewer than <paramref name="k" /> distinct values if
                all of <paramref name="seq" /> is returned.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.DistinctOn``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
                Like .Distinct(), but computes distinctness on a computed value for each element instead of the elements themselves.
            </summary>
            <typeparam name="T">The type of elements.</typeparam>
            <typeparam name="TKey">The type of keys generated by <paramref name="keySelector" />.</typeparam>
            <param name="seq">The enumerable.</param>
            <param name="keySelector"></param>
            <param name="comparer">Optional comparer for values returned by <paramref name="keySelector" />.</param>
            <returns>
                A subsequence of <paramref name="seq" /> where all values distinct when
                mapped with <paramref name="keySelector" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.SequencePrefixEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Int32,System.Collections.Generic.EqualityComparer{``0})">
            <summary>
                Checks if two sequences have a common prefix of length <paramref name="count" />.
            </summary>
            <typeparam name="T">Type of elements.</typeparam>
            <param name="xs">First sequence.</param>
            <param name="ys">Second sequence.</param>
            <param name="count">Number of elements to read from both sequences.</param>
            <param name="equality">Comparer to use to compare the sequences or <c>null</c> for default equality.</param>
            <returns>
                <c>true</c> if <paramref name="xs" /> and <paramref name="ys" /> both have at least <paramref name="count" />
                elements and the corresponding elements are equal according to <paramref name="equality" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.AggregateSeedFunc``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,``0,``1})">
            <summary>
              Applies an accumulator function over a sequence. The specified seed function is applied to the first
              element to calculate the initial accumulator value.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TAccumulate">The type of the accumulator value.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to aggregate over.</param>
            <param name="seedFunc">
                A function to apply to the first element in order to calculate the initial accumulator value.
            </param>
            <param name="func">An accumulator function to be invoked on each element after the first.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.ToSortedDictionary``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
                Constructs a <see cref="T:System.Collections.Generic.SortedDictionary`2" /> containing the given
                <see cref="T:System.Collections.Generic.KeyValuePair`2" />s.
            </summary>
            <typeparam name="T1">Type of keys.</typeparam>
            <typeparam name="T2">Type of values.</typeparam>
            <param name="seq">Collection of <see cref="T:System.Collections.Generic.KeyValuePair`2" />s to put in new dictionary.</param>
            <returns><paramref name="seq" /> as a <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</returns>
            <seealso cref="!:ToDictionary&lt;T1,T2&gt;()" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.ToDictionaryChecked``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <summary>
                Wrapper for <see cref="M:System.Linq.Enumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})" />
                that gives a more useful exception message for repeated keys.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.Yield``1(``0)">
            <summary>
                Wraps this object instance into an IEnumerable&lt;T&gt;
                consisting of a single item.
            </summary>
            <typeparam name="T"> Type of the wrapped object.</typeparam>
            <param name="item"> The object to wrap.</param>
            <returns>
                An IEnumerable&lt;T&gt; consisting of a single item.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.SplitOn``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
                Splits a sequence into a sequence of sequences based on a delimiter function.
            </summary>
            <typeparam name="T">Type of the sequence.</typeparam>
            <param name="xs">Input sequence.</param>
            <param name="isDelimiter">Function that determines if an element is a delimiter.</param>
            <returns>
                A sequence of sequences with elements in the same order as <paramref name="xs" /> with
                delimiters omitted.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.SplitOn``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
                Splits a sequence into a sequence of sequences based on a delimiter value.
            </summary>
            <typeparam name="T">Type of the sequence.</typeparam>
            <param name="xs">Input sequence.</param>
            <param name="delimiter">Delimiter separating subsequences. Not included in the output.</param>
            <returns>
                A sequence of sequences with elements in the same order as <paramref name="xs" /> with
                <paramref name="delimiter" /> omitted but used to decide when to switch to a new sequence.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.AnyOrElse``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Func{System.Boolean})">
            <summary>
                Checks if a predicate is true for any element of a collection or if the collection is empty, evaluates
                <paramref name="emptyPredicate" />. This is equivalent to <c>xs.Any() ? xs.Any(predicate) : emptyPredicate()</c>
                except for only enumerating <paramref name="xs" /> once.
            </summary>
            <typeparam name="T">Type of elements of the collection.</typeparam>
            <param name="xs">Collection to inspect.</param>
            <param name="predicate">Predicate to evaluate on the elements of <paramref name="xs" />.</param>
            <param name="emptyPredicate">Function whose result should be returned if <paramref name="xs" /> is empty.</param>
            <returns>
                <c>true</c> if any element of <paramref name="xs" /> satisfies <paramref name="predicate" /> or, if
                <paramref name="xs" /> is empty, then the result of <paramref name="emptyPredicate" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.AllOrElseCompute``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Func{System.Boolean})">
            <summary>
                Checks if a predicate is true for all elements of a collection or if the collection is empty, evaluates
                <paramref name="emptyPredicate" />. This is equivalent to <c>xs.Any() ? xs.All(predicate) : emptyPredicate()</c>
                except for only enumerating <paramref name="xs" /> once.
            </summary>
            <typeparam name="T">Type of elements of the collection.</typeparam>
            <param name="xs">Collection to inspect.</param>
            <param name="predicate">Predicate to evaluate on the elements of <paramref name="xs" />.</param>
            <param name="emptyPredicate">Function whose result should be returned if <paramref name="xs" /> is empty.</param>
            <returns>
                <c>true</c> if all elements of <paramref name="xs" /> satisfies <paramref name="predicate" /> or, if
                <paramref name="xs" /> is empty, then the result of <paramref name="emptyPredicate" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.IsSubsequenceOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Check if <paramref name="xs"/> is a subsequence of <paramref name="ys"/>. That is, whether every element
            of <paramref name="xs"/> appears in <paramref name="ys"/> in the same order (although <paramref name="ys"/>
            may also contain other elements).
            </summary>
            <typeparam name="T">type of the elements</typeparam>
            <param name="xs"></param>
            <param name="ys"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.RandomElement``1(System.Collections.Generic.IReadOnlyList{``0},System.Random)">
            <summary>
                Randomly sample an element from the collection
            </summary>
            <param name="xs">Collection to Sample from</param>
            <param name="random">RNG</param>
            <returns>
                A single element from the collection or default value of
                <typeparam name="T">type T</typeparam> if collection is empty
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.RandomlySampleWithReplacement``1(System.Collections.Generic.IReadOnlyList{``0},System.Random,System.Int32)">
            <summary>
                Randomly sample a collection with replacement,
                 i.e., same element may be sampled multiple times
            </summary>
            <param name="xs">Collection to Sample from</param>
            <param name="random">RNG</param>
            <param name="sampleSize">Sample Size</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.FirstOrNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                 Returns the first element of the collection <paramref name="items"/> if any,
                 and null otherwise. This method is defined on collections of struct types and
                 returns a value of the optional type <typeparamref name="T"/>?.
            </summary>
            <typeparam name="T">Type of the elements in the collection.</typeparam>
            <param name="items">Collection to get the first element from.</param>
            <returns>First element in the collection or null.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.FirstOrNull``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
                 Returns the first element of the collection <paramref name="items"/> that satisfies
                 the predicate <paramref name="predicate"/> if any, and null otherwise.
                 This method is defined on collections of struct types and returns a value of 
                 the optional type <typeparamref name="T"/>?.
            </summary>
            <typeparam name="T">Type of the elements in the collection.</typeparam>
            <param name="items">Collection to get the first element from.</param>
            <param name="predicate">Predicate the returned element must satisfy.</param>
            <returns>First element in the collection or null.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.OnlyOrDefault``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Returns the only item in <paramref name="xs" /> or <c>default(T)</c> if <paramref name="xs" /> is empty or contains
                multiple items. This differs from
                <see cref="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0})" /> by not throwing
                an exception if there are multiple items in the collection.
            </summary>
            <typeparam name="T">Type of elements of <paramref name="xs" />.</typeparam>
            <param name="xs">Collection which is expected to contain exactly one item.</param>
            <returns>The only item in <paramref name="xs" /> or <c>default(T)</c>.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.OnlyOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
                Returns the only item in <paramref name="xs" /> that satisfies <paramref name="predicate" /> or <c>default(T)</c>
                if <paramref name="xs" /> is empty or contains multiple items. This differs from
                <see cref="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
                by not throwing an exception if there are multiple items in the collection.
            </summary>
            <typeparam name="T">Type of elements of <paramref name="xs" />.</typeparam>
            <param name="xs">Collection which is expected to contain exactly one item.</param>
            <param name="predicate">Predicate that items must satisfy to be considered.</param>
            <returns>The only item in <paramref name="xs" /> satisfying <paramref name="predicate" /> or <c>default(T)</c>.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.Interleave``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Enumerates two <see cref="T:System.Collections.Generic.IEnumerable`1" />s together, alternating between them. Unlike
                <see cref="M:System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})" />, if one enumerable is longer than the other, its elements
                will show up at the end instead of being truncated. The first element of <paramref name="xs" /> comes first, then
                the first element of <paramref name="ys" />, followed by the second element of <paramref name="xs" />, etc.
            </summary>
            <typeparam name="T">The type of elements.</typeparam>
            <param name="xs">The first collection; its elements come before the corresponding elements of <paramref name="ys" />.</param>
            <param name="ys">The second collection.</param>
            <returns>
                An enumerable containing all of the elements of both <paramref name="xs" /> and <paramref name="ys" />,
                alternating which enumerable the elements come from.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.UnzipToLists``2(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Utils.Record{``0,``1}})">
            <summary>
                Project the given collection <paramref name="xs" /> of record of pairs 
                onto its first and second component.
            </summary>
            <typeparam name="T1">The type of the first component in each element of the collection.</typeparam>
            <typeparam name="T2">The type of the second component in each element of the collection.</typeparam>
            <param name="xs">The collection to extract elements from..</param>
            <returns>
                A record whose first component is projection of <paramref name="xs"/> onto the first component 
                and whose second component is the projection onto the second component.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.MutateLast``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0})">
            <summary>
                Mutates only the last element of an enumerable, selecting the rest unmodified.
            </summary>
            <typeparam name="T">Type of elements.</typeparam>
            <param name="xs">Enumerable to modify the last element of.</param>
            <param name="mutate">Function to apply to last element.</param>
            <returns>
                An enumerable with same elements as <paramref name="xs" /> except the last element has
                <paramref name="mutate" /> applied to it.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.MutateFirst``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0})">
            <summary>
                Mutates only the first element of an enumerable, selecting the rest unmodified.
            </summary>
            <typeparam name="T">Type of elements.</typeparam>
            <param name="xs">Enumerable to modify the first element of.</param>
            <param name="mutate">Function to apply to first element.</param>
            <returns>
                An enumerable with same elements as <paramref name="xs" /> except the first element has
                <paramref name="mutate" /> applied to it.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.MutateAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Func{``0,``0})">
            <summary>
                Mutates a single element of an enumerable, selecting the rest unmodified.
            </summary>
            <typeparam name="T">Type of elements.</typeparam>
            <param name="xs">Enumerable to modify an element of.</param>
            <param name="idx">Index of element to modify.</param>
            <param name="mutate">Function to apply to the element at index <paramref name="idx" />.</param>
            <returns>
                An enumerable with same elements as <paramref name="xs" /> except the element at <paramref name="idx" /> has
                <paramref name="mutate" /> applied to it.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.Nodes``1(System.Collections.Generic.LinkedList{``0})">
            <summary>
                Retrieves the collection of <see cref="T:System.Collections.Generic.LinkedListNode`1"/> from a <see cref="T:System.Collections.Generic.LinkedList`1"/> as an
                <see cref="T:System.Collections.IEnumerable"/>.
            </summary>
            <typeparam name="T">The type of the values in the <see cref="T:System.Collections.Generic.LinkedList`1"/></typeparam>
            <param name="ll">The <see cref="T:System.Collections.Generic.LinkedList`1"/> object.</param>
            <returns>A sequence of <see cref="T:System.Collections.Generic.LinkedListNode`1"/> from <paramref name="ll"/>.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.ToMultidimensionalArray``1(``0[][])">
            <summary>
                Flatten a jagged array <paramref name="arr" /> which is rectangular into a multidimensional array.
            </summary>
            <typeparam name="T">Type of elements of the array.</typeparam>
            <param name="arr">A non-empty array whose elements are all arrays of the exact same size.</param>
            <returns>A multidimensional array <c>res</c> such that <c>res[i, j] == arr[i][j]</c>.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.Deconstruct``2(System.Collections.Generic.KeyValuePair{``0,``1},``0@,``1@)">
            <summary>
                Deconstructs a <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="kvp">The <see cref="T:System.Collections.Generic.KeyValuePair`2"/></param>
            <param name="key">An out parameter that will contain the deconstructed key from <paramref name="kvp"/>.</param>
            <param name="value">An out parameter that will contain the deconstructed value from <paramref name="kvp"/>.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.DictionaryEquals``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
                Compares two <see cref="T:System.Collections.Generic.IDictionary`2" />s for equality.
            </summary>
            <typeparam name="TKey">The type of the keys in the dictionaries.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionaries.</typeparam>
            <param name="dict">The first <see cref="T:System.Collections.Generic.IDictionary`2" /> to compare.</param>
            <param name="other">The second <see cref="T:System.Collections.Generic.IDictionary`2" /> to compare.</param>
            <param name="valueEqualityComparer">
                An optional <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare instances of
                <see cref="!:TValue" />. If <c>null</c>, then <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> will be used.
            </param>
            <returns><c>true</c> if <paramref name="dict" /> is equal to <paramref name="other" />, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.ReadOnlyDictionaryEquals``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},System.Collections.Generic.IReadOnlyDictionary{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
                Compares two <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/>s for equality.
            </summary>
            <typeparam name="TKey">The type of the keys in the dictionaries.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionaries.</typeparam>
            <param name="dict">The first <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/> to compare.</param>
            <param name="other">The second <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/> to compare.</param>
            <param name="valueEqualityComparer">
                An optional <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare instances of
                <see cref="!:TValue" />. If <c>null</c>, then <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> will be used.
            </param>
            <returns><c>true</c> if <paramref name="dict"/> is equal to <paramref name="other"/>, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.PartitionByPredicate``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Collections.Generic.IList{``0}@,System.Collections.Generic.IList{``0}@)">
            <summary>
                Partitions <paramref name="enumerable"/> into two lists: one with elements satisfying <paramref name="predicate"/> and the other with elements not satisfying <paramref name="predicate"/>.
            </summary>
            <typeparam name="T">The type of the elements in <paramref name="enumerable"/>.</typeparam>
            <param name="enumerable">The enumerable to partition.</param>
            <param name="predicate">The predicate to partition by.</param>
            <param name="positives">An out parameter that returns the set of elements satisfying <paramref name="predicate"/>.</param>
            <param name="negatives">An out parameter that returns the set of elements not satisfying <paramref name="predicate"/>.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.SelectIndices``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},System.Boolean)">
            <summary>
                Select a subset of <paramref name="collection"/> defined by the indices in <paramref name="indices"/>.
            </summary>
            <param name="containing">
                If true, selects the elements with the indices in <paramref name="indices"/>.
                If false, selects the elements with the indices NOT in <paramref name="indices"/>.
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.FindAllIndexes``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean},System.Int32)">
            <summary>
                Enumerates all indexes of <paramref name="xs" /> that satisfy <paramref name="predicate" />.
            </summary>
            <typeparam name="T">Type of elements of <paramref name="xs" />.</typeparam>
            <param name="xs">Collection to enumerate.</param>
            <param name="predicate">
                Function that when true for an element of <paramref name="xs" /> and its index, that index is included in the
                output.
            </param>
            <param name="startIndex"> The start index of <paramref name="xs"/> from which the predicate will be matched, 
            all indexes prior to it will not be added to the output </param>
            <returns>Every index of <paramref name="xs" /> starting from <paramref name="startIndex"/> for which <paramref name="predicate" /> is true.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.FindAllIndexes``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Int32)">
            <summary>
                Enumerates all indexes of <paramref name="xs" /> that satisfy <paramref name="predicate" />.
            </summary>
            <typeparam name="T">Type of elements of <paramref name="xs" />.</typeparam>
            <param name="xs">Collection to enumerate.</param>
            <param name="predicate">
                Function that when true for an element of <paramref name="xs" />, that index is included in the
                output.
            </param>
            <param name="startIndex"> The start index of <paramref name="xs"/> from which the predicate will be matched, 
            all indexes prior to it will not be added to the output </param>
            <returns>Every index of <paramref name="xs" /> starting from <paramref name="startIndex"/> for which <paramref name="predicate" /> is true.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.IndexOfByReference``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
                Index of the element in the sequence using ReferenceEquals to compare equality.
            </summary>
            <typeparam name="T">Type of elements.</typeparam>
            <param name="xs">Collection to enumerate.</param>
            <param name="element">Element to searched for.</param>
            <returns>Index of the searched element or null if the element does not exist.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.Windowed``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``1})">
            <summary>
                Compute a function on all adjecent pairs of elements. For example, for [1, 2, 3], this returns [<c>func(1, 2)</c>,
                <c>func(2, 3)</c>].
            </summary>
            <typeparam name="T">The type of the elements in <paramref name="seq" />.</typeparam>
            <typeparam name="TResult">The return type of <paramref name="func" />.</typeparam>
            <param name="seq">The sequence.</param>
            <param name="func">Function to run on the adjecent pairs of elements of <paramref name="seq" />.</param>
            <returns>
                <c>seq.Count()-1</c> runs of <paramref name="func" /> on pairs of adjecent elements from
                <paramref name="seq" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.Windowed3``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0,``1})">
            <summary>
                Compute a function on all adjecent triplets of elements. For example, for [1, 2, 3, 4], this returns [<c>func(1, 2, 3)</c>,
                <c>func(2, 3, 4)</c>].
            </summary>
            <typeparam name="T">The type of the elements in <paramref name="seq" />.</typeparam>
            <typeparam name="TResult">The return type of <paramref name="func" />.</typeparam>
            <param name="seq">The sequence.</param>
            <param name="func">Function to run on the adjecent triplets of elements of <paramref name="seq" />.</param>
            <returns>
                <c>seq.Count()-2</c> runs of <paramref name="func" /> on triplets of adjecent elements from
                <paramref name="seq" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.Windowed``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Enumerate all adjecent pairs of elements. For example, for [1, 2, 3], this returns [(1, 2), (2, 3)].
            </summary>
            <typeparam name="T">The type of the elements in <paramref name="seq" />.</typeparam>
            <param name="seq">The sequence.</param>
            <returns><c>seq.Count()-1</c> pairs of adjecent elements from <paramref name="seq" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.Windowed3``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Enumerate all adjecent triplets of elements. For example, for [1, 2, 3, 4], this returns [(1, 2, 3), (2, 3, 4)].
            </summary>
            <typeparam name="T">The type of the elements in <paramref name="seq" />.</typeparam>
            <param name="seq">The sequence.</param>
            <returns><c>seq.Count()-2</c> triplets of adjecent elements from <paramref name="seq" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.Choose``1(System.Collections.Generic.IReadOnlyList{``0},System.Int32)">
            <summary>
                Return an enumerable of all combinations (ignoring order) of <paramref name="k"/>
                elements of the collection <paramref name="xs"/>.
                For example, Choose({1,2,3,4}, 2) returns { {1,2}, {1,3}, {1,4}, {2,3}, {2,4}, {3,4} }
            </summary>
            <typeparam name="T"></typeparam>
            <param name="xs">Collection from which elements are chosen</param>
            <param name="k">Number of elements per choice</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.SortAndRemoveSubordinates``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0},System.Func{``0,``0,System.Boolean})">
            <summary>
            Returns a sorted list with subordinates removed where subordinate is
            defined as any element for which supersedes returns true when passed
            a larger (as defined by comparer) element and the element in question
            </summary>
            <param name="elements">The elements to filter and sort</param>
            <param name="comparer">The comparer for any two elements</param>
            <param name="supersedes">The filter function which defines subordinates</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.AddOrInsert``3(System.Collections.Generic.IDictionary{``0,``1},``0,``2)">
            <summary>
            Either adds <see cref="!:value"/> to collection indexed by <see cref="!:key"/> or creates a new collection containing <see cref="!:value"/>.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TCollection"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="dict"></param>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.HasExactly``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Returns true if <paramref name="xs"/> has exactly <paramref name="k"/> elements.
            </summary>
            <typeparam name="T">The type of <paramref name="xs"/></typeparam>
            <param name="xs">The collection to check.</param>
            <param name="k">The number of elements.</param>
            <returns>True if <paramref name="xs"/> has exactly <paramref name="k"/> elements, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.HasRepeats``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0},System.Collections.Generic.List{``0}@)">
            <summary>
            Determines if the given collection <see cref="!:xs"/> has any repeated values.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="xs"></param>
            <param name="equalityComparer"></param>
            <param name="repeats">The values which repeat.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.HasRepeats``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.List{``0}@)">
            <summary>
            Determines if the given collection <see cref="!:xs"/> has any repeated values.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="xs"></param>
            <param name="repeats">The values which repeat.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.HasRepeats``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Determines if the given collection <see cref="!:xs"/> has any repeated values.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="xs"></param>
            <param name="equalityComparer"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.HasRepeats``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Boolean})">
            <summary>
            Determines if the given collection <see cref="!:xs"/> has any repeated values.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="xs"></param>
            <param name="equalityComparer"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.RotateLeft``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
                Pull off the first <paramref name="amount" /> elements of an enumeration and put them at the end. Named in analogy
                with bit rotation.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="xs"></param>
            <param name="amount">Number of elements to skip at the beginning.</param>
            <returns>
                All of the elements in <paramref name="xs" /> in the same order, except starting <paramref name="amount" />
                elements in and then continuing back at the start.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.RotateRight``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
                Pull off the last <paramref name="amount" /> elements of an enumeration and put them at the start. Named in analogy
                with bit rotation.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="xs"></param>
            <param name="amount">Number of elements to grab from the end.</param>
            <returns>
                All of the elements in <paramref name="xs" /> in the same order, except starting <paramref name="amount" />
                elements from the end and then continuing back at the start.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.IsNullOrEmpty``1(System.Collections.Generic.IReadOnlyList{``0})">
            <summary>
                Returns a bool indicating if the given list is null or empty.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.Mode``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
                Returns the most common element in <paramref name="xs" />.
            </summary>
            <typeparam name="T">Type of elements.</typeparam>
            <param name="xs">A non-empty collection.</param>
            <param name="comparer">Used to determine what elements are considered equal.</param>
            <returns>
                The first element of <paramref name="xs" /> for which no other element has more other elements of
                <paramref name="xs" /> equal to it.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.AdjacentClumps(System.Collections.Generic.IEnumerable{System.Int32},System.Int32,System.Nullable{System.Int32})">
            <summary>
                Groups a sorted list of numbers into adjacent clumps.
                Buckets values into clumps to account for them not being exact or being rounded.
                e.g., [1,2,10,20,21,22,23,24,25,26] -> [1,2], [10,10], [20,24], [21,25], [22,26]
            </summary>
            <param name="xs">A sorted list of distinct numbers.</param>
            <param name="tolerance">
                How far away before forming a separate clump. <c>0</c> means all numbers are in separate
                clumps, <c>1</c> means no gaps are allowed.
            </param>
            <param name="maxSize">
                The size after which clumps are split. If a clump would be larger than this size, then it is
                instead returned as a set of overlapping clumps of this size covering the entire range.
            </param>
            <returns>
                A sorted list of clumps as records where the first item is the minimum of the clump and the second item is the
                maximum.
            </returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.Utils.Geometry.RangeUtils.AsRanges``1(System.Collections.Generic.IEnumerable{System.Int32})"/>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.Clear``1(System.Collections.Concurrent.BlockingCollection{``0})">
            <summary>
                Clears all of the elements from a blocking collection.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.BatchedConsumingEnumerable``1(System.Collections.Concurrent.BlockingCollection{``0},System.Threading.CancellationToken)">
            <summary>
                Blocks until a value is added to the BlockingCollection and then yields added items until there are no items left
                in the collection. 
                
                This is different from the GetConsumingEnumerable function in two ways.
                
                First: The resulting enumerable is not a snapshot. It will yield new items as they are added to the collection instead 
                of just taking a snapshot and only yielding those.
                
                Second: This function will block until an item is added so resources are not wasted spinning until an item is added 
                to the collection.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.EmptyArray``1">
            <summary>
                Returns an empty array of type <typeparamref name="T" />.
                This is a clone implementation of Net46 Array.Empty.
            </summary>
            <typeparam name="T">The array type.</typeparam>
            <returns>An empty array of type <typeparamref name="T" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.WithIndex``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary>
                Adds an index to a sequence.
            </summary>
            <typeparam name="T">The type of the sequence.</typeparam>
            <param name="seq">The sequence.</param>
            <param name="startIndex">The first/start index.</param>
            <param name="step">The step that is added to the index after each iteration.</param>
            <returns>The sequence paired with index.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.IsSorted``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
                Return true if and only if the enumerable <paramref name="seq"/> is sorted as per the 
                comparer <paramref name="comparer"/>.
            </summary>
            <typeparam name="T">Type of elements in the enumerable <paramref name="seq"/></typeparam>
            <param name="seq">The enumerable.</param>
            <param name="comparer">The comparator to use.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.IsSorted``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Return true if and only if the enumerable <paramref name="seq"/> is sorted as per the
                default comparer.
            </summary>
            <typeparam name="T">Type of elements in the enumerable <paramref name="seq"/></typeparam>
            <param name="seq">The enumerable.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.SequenceFind``1(System.Collections.Generic.IReadOnlyList{``0},System.Collections.Generic.IReadOnlyList{``0})">
            <summary>
                Find the index of the subsequence <paramref name="needle"/> in
                the sequence <paramref name="haystack"/>. Return -1 if
                <paramref name="needle"/> does not occur in <paramref
                name="haystack"/>.
            </summary>
            <param name="haystack">Sequence to search in.</param>
            <param name="needle">Subsequence to search for.</param>
            <returns>Index of the subsequence if present, and -1 otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.ToReferenceEqualityDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <summary>
                Invert the dictionary <paramref name="dict" /> with a Comparer
            </summary>
            <param name="dict">The dictionary to invert</param>
            <param name="keySelector">The key selector</param>
            <param name="valueSelector">The value selector</param>
            <returns>The inverted dictionary</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.ComparableUtilities.TryHandleNullVariables(System.Object,System.Object,System.Int32@)">
            <summary>
                Handles the null cases for a comparable implementation. If either operand is null then we return the other.
                This can be used with an inline var like so:
                    if (TryHandleNullVariables(x, y, out var result)) { return result };
            </summary>
            <param name="x">The first operand.</param>
            <param name="y">The second operand.</param>
            <param name="result">The return integer for Compare.</param>
            <returns>A bool indicating if either of the operands were null and whether result should be returned.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.CompilerResolvedType">
             <summary>
                 Represents a type in a grammar which has been resolved at compile-time to a definition in source code but
                 for which we do not have a <see cref="T:System.Type"/> since we cannot load the relevant assemblies into the
                 compiler itself.
             </summary>
             <remarks>
                 Given that this type has been resolved at compile-time, we have confidence that we can generate code which
                 assumes it can be resolved and will have access to the <see cref="T:System.Type"/> at runtime.
            
                 This abstract class allows Common code to reason about types in this state without having access to the
                 Roslyn <see cref="!:Microsoft.CodeAnalysis.INamedTypeSymbol"/> to which the type has been resolved.  We don't
                 take a dependency on Roslyn in the Common assembly, but we do take that dependency in the Compiler, and it
                 has a concrete derived class <see cref="!:Microsoft.ProgramSynthesis.Compiler2.RoslynResolvedType"/> which
                 contains the backing Roslyn type symbol object.
             </remarks>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.CompilerResolvedType.Type">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.CSharpCodeProvider">
            <summary>
            Class of helper methods for generating CSharp source code as text.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.EquatablePair`2">
            <summary>
                A Pair struct similar to KeyValuePair, for Equatable types.
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.EquatablePair`2.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
            <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.EquatablePair`2.Item1">
            <summary>
                The first item.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.EquatablePair`2.Item2">
            <summary>
                The second item.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.EquatablePair`2.Equals(Microsoft.ProgramSynthesis.Utils.EquatablePair{`0,`1})">
            <summary>Indicates whether the current object is equal to another object of the same type.</summary>
            <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.EquatablePair`2.Equals(System.Object)">
            <summary>Indicates whether this instance and a specified object are equal.</summary>
            <returns>
                true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise,
                false.
            </returns>
            <param name="obj">The object to compare with the current instance. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.EquatablePair`2.#ctor(`0,`1)">
            <summary>
                Initializes a new Pair from two given items.
            </summary>
            <param name="item1">The first item.</param>
            <param name="item2">The second item.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.EquatablePair`2.Reverse">
            <summary>
                Reverse a pair.
            </summary>
            <returns>
                A new pair with the elements in the reverse order.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.EquatablePair`2.ToString">
            <summary>Returns the fully qualified type name of this instance.</summary>
            <returns>A <see cref="T:System.String" /> containing a fully qualified type name.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.EquatablePair.Create``2(``0,``1)">
            <summary>
                A helper function that uses type inference to produce the pair of the right-type.
            </summary>
            <typeparam name="T1">Type of the first item.</typeparam>
            <typeparam name="T2">Type of the second item.</typeparam>
            <param name="item1">The first item.</param>
            <param name="item2">The second item.</param>
            <returns>
                A new pair with the provided items.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.EquatablePair.AsEnumerable``1(Microsoft.ProgramSynthesis.Utils.EquatablePair{``0,``0})">
            <summary>
                Constructs an enumerable over a pair.
            </summary>
            <typeparam name="T">The type of elements in the pair.</typeparam>
            <param name="pair">The pair.</param>
            <returns>
                An enumerable over the elements in the pair.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.ExceptionUtils.DefaultIfException``2(System.Func{``0})">
            <summary>
                Perform a computation and return the result; return the
                default value if the computation throws an exception.
            </summary>
            <typeparam name="TReturn">Type of return value.</typeparam>
            <typeparam name="TException">The type of the exception to ignore.</typeparam>
            <param name="computation">Computation to perform.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.ExceptionUtils.OnException``1(System.Action,System.Action)">
            <summary>
                Run a computation; if there is an exception, run the exception handler.
                default value if the computation throws an exception.
            </summary>
            <typeparam name="TException">The type of the exception to handle.</typeparam>
            <param name="computation">Computation to run.</param>
            <param name="exceptionHandler">Exception handler to run.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.FunctionUtils">
            <summary>
                Utilities for manipulating function objects.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.FunctionUtils.IdentityIfNull``1(System.Func{``0,``0})">
            <summary>
                Returns the identity function if <paramref name="fun" /> is <c>null</c>,
                otherwise, returns <paramref name="fun" />.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Geometry.Axis">
            <summary>
                One of two dimensions. Used to abstract operations across dimensions, particularly via the
                <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.AxisAligned`1" /> data structure and types implemented using it.
            </summary>
            <seealso cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Direction" />
            <seealso cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Ordinal" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Geometry.AxisAligned`1">
            <summary>
                An immutable lookup keyed on <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Axis" />. Used to keep track of features that are grouped by axis.
            </summary>
            <typeparam name="T">Type of values.</typeparam>
            <seealso cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.AxisAlignedList`1" />
            <seealso cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.AxisAlignedSet`1" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Geometry.AxisAlignedList`1">
            <summary>
                Helper type for constructing <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.AxisAligned`1" />s whose values are lists.
            </summary>
            <typeparam name="T">Type of elements of the list.</typeparam>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Geometry.AxisAlignedSet`1">
            <summary>
                Helper type for constructing <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.AxisAligned`1" />s whose values are sets.
            </summary>
            <typeparam name="T">Type of elements of the sets.</typeparam>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Geometry.AxisAlignedLine`1">
            <summary>
                A horizontal or vertical line.
            </summary>
            <typeparam name="TUnit">Unit of the line's coordinates.</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Geometry.AxisAlignedLine`1.Axis">
            <summary>
                Axis the line is along. <see cref="P:Microsoft.ProgramSynthesis.Utils.Geometry.AxisAlignedLine`1.Range" /> is coordinates along this axis while <see cref="P:Microsoft.ProgramSynthesis.Utils.Geometry.AxisAlignedLine`1.Position" /> is in the
                <see cref="M:Microsoft.ProgramSynthesis.Utils.Geometry.AxisUtilities.Perpendicular(Microsoft.ProgramSynthesis.Utils.Geometry.Axis)" /> axis.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Geometry.AxisAlignedLine`1.Range">
            <summary>
                The range of positions along <see cref="P:Microsoft.ProgramSynthesis.Utils.Geometry.AxisAlignedLine`1.Axis" /> this line covers.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Geometry.AxisAlignedLine`1.Position">
            <summary>
                The position of this line in the axis perpendicular to <see cref="P:Microsoft.ProgramSynthesis.Utils.Geometry.AxisAlignedLine`1.Axis" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.AxisAlignedLineUtilities.MaybeAsAxisAlignedLine``1(Microsoft.ProgramSynthesis.Utils.Record{Microsoft.ProgramSynthesis.Utils.Geometry.Vector{``0},Microsoft.ProgramSynthesis.Utils.Geometry.Vector{``0}})">
            <summary>
                Given a line defined by two <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Vector`1" />s, construct an <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.AxisAlignedLine`1" /> if
                possible.
            </summary>
            <typeparam name="TUnit">The units of the vectors.</typeparam>
            <param name="line">The line specified as a pair of <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Vector`1" />s.</param>
            <returns>
                <paramref name="line" /> specified as an <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.AxisAlignedLine`1" /> or
                <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.AxisAlignedLineUtilities.AsBoxes(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Utils.Geometry.AxisAlignedLine{Microsoft.ProgramSynthesis.Utils.Geometry.PixelUnit}})">
            <summary>
                Splits a polygon defined by a sequence of <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.AxisAlignedLine`1" />s into a collection of
                <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Bounds`1" /> covering the same area.
            </summary>
            <param name="linesEnumerable">The lines outlining the polygon.</param>
            <returns>The area of the polygon represented as a collection of <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Bounds`1" />.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Geometry.BoundsUnit">
            <summary>
                Type of units for <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Bounds`1" />. This type and its subtypes are only used as type arguments to tag
                the units; they are never instantiated. <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Range`1" />, <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Bounds`1" />, and
                <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Vector`1" />/<see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.DoubleVector`1" /> require a subclass of this type to be specified in
                order to clarify the units to avoid confusion.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Geometry.TableUnit">
            <summary>
                Units of rows/columns in a table.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Geometry.PixelUnit">
            <summary>
                Units of pixels.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Geometry.IndexUnit">
            <summary>
                Units of indexing into an array.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Geometry.Bounds`1">
            <summary>
                The bounds of some document feature in <typeparamref name="TUnit" /> coordinates. The axis-aligned rectangle which
                the feature is contained within. All bounds are inclusive, so there is no way to specify an empty bounds.
            </summary>
            <typeparam name="TUnit">Unit this bounds is in.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.Bounds`1.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                Creates a new Bounds object. Note: left must be less than right and
                top must be less than bottom.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.Bounds`1.IsAfter(Microsoft.ProgramSynthesis.Utils.Geometry.Bounds{`0},Microsoft.ProgramSynthesis.Utils.Geometry.Axis,System.Boolean)">
            <summary>
                Determines if this bounds occurs after <see cref="!:other" /> when projected upon <see cref="!:axis" />.
            </summary>
            <param name="other"></param>
            <param name="axis"></param>
            <param name="includingIntersection">
                If true, this checks if the leading edge of this bounds is after
                the leading edge <see cref="!:other" />. Otherwise it checks if the
                trailing edge of this bounds is after the leading edge.
            </param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.Bounds`1.IsBefore(Microsoft.ProgramSynthesis.Utils.Geometry.Bounds{`0},Microsoft.ProgramSynthesis.Utils.Geometry.Axis,System.Boolean)">
            <summary>
                Determines if this bounds occurs before <see cref="!:other" /> when projected upon <see cref="!:axis" />.
            </summary>
            <param name="other"></param>
            <param name="axis"></param>
            <param name="includingIntersection">
                If true, this checks if the trailing edge of this bounds is before
                the trailing edge <see cref="!:other" />. Otherwise it checks if the
                leading edge of this bounds is before the trailing edge.
            </param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.Bounds`1.MaybeBetween(Microsoft.ProgramSynthesis.Utils.Geometry.Bounds{`0},Microsoft.ProgramSynthesis.Utils.Geometry.Bounds{`0})">
            <summary>
                The area that is lined up with both <paramref name="first" /> and <paramref name="second" /> and between them but
                not overlapping either one, if such an area exists.
            </summary>
            <param name="first">A <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Bounds`1" />.</param>
            <param name="second">Another <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Bounds`1" />.</param>
            <returns>
                <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if <paramref name="first" /> and <paramref name="second" /> are not lined
                up in either axis. Otherwise, the area that overlaps both of them in that axis and is between them in the other
                axis.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.Bounds`1.MaybeBetweenCenters(Microsoft.ProgramSynthesis.Utils.Geometry.Axis,Microsoft.ProgramSynthesis.Utils.Geometry.Bounds{`0},Microsoft.ProgramSynthesis.Utils.Geometry.Bounds{`0})">
            <summary>
                The area between halfway through <paramref name="first" /> along <paramref name="axis" /> to halfway through
                <paramref name="second" /> along the same axis, limited to the overlapping range in the perpendicular axis, if any.
            </summary>
            <param name="axis">Axis to select center along.</param>
            <param name="first">A <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Bounds`1" />.</param>
            <param name="second">Another <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Bounds`1" />.</param>
            <returns>
                <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if <paramref name="first" /> and <paramref name="second" /> are not lined
                up along <paramref name="axis" /> or the bounds between them inclusive up to their center along that axis.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.Bounds`1.MaybeJoinExact(Microsoft.ProgramSynthesis.Utils.Geometry.Bounds{`0})">
            <summary>
                The same as <see cref="M:Microsoft.ProgramSynthesis.Utils.Geometry.Bounds`1.Join(Microsoft.ProgramSynthesis.Utils.Geometry.Bounds{`0})" /> except return <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if the join is
                bigger than the union (i.e. there exists any point in the join that is not in either of the bounds).
            </summary>
            <param name="other">Bounds to join with.</param>
            <returns>The union of the two bounds if expressible as a single rectangle.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Geometry.Bounds`1.Edges">
            <summary>
                The 1-unit wide/tall bounds contained by this bounds on each edge.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Geometry.Directed`1">
            <summary>
                An immutable lookup keyed on <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Direction" />.
            </summary>
            <typeparam name="T">Type of values.</typeparam>
            <seealso cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.DirectedList`1" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Geometry.Direction">
            <summary>
                One of the four cardinal directions. Used to abstract operations over directions, especially using the
                <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Directed`1" /> data structure.
            </summary>
            <seealso cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Axis" />
            <seealso cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Ordinal" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Geometry.Derivative">
            <summary>
                A choice of increasing or decreasing used to distinguish the <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Direction" />s along an
                <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Axis" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.DirectionUtilities.Relative(Microsoft.ProgramSynthesis.Utils.Geometry.Direction,Microsoft.ProgramSynthesis.Utils.Geometry.Direction)">
             <summary>
             Calculates the direction relative to <see cref="!:direction"/> if you assume <see cref="!:direction"/> is Direction.Up.
            
             Ex:
                 Direction.Right.Relative(Direction.Left) => Direction.Up
                 Direction.Left.Relative(Direction.Down) => Direction.Right
             </summary>
             <param name="direction"></param>
             <param name="relativeDirection"></param>
             <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.DirectionUtilities.Relative(Microsoft.ProgramSynthesis.Utils.Geometry.Direction,Microsoft.ProgramSynthesis.Utils.Geometry.Ordinal)">
             <summary>
             Calculates the ordinal relative to <see cref="!:direction"/> if you assume <see cref="!:direction"/> is Direction.Up.
            
             Ex:
                 Direction.Right.Relative(Ordinal.TopLeft) => Ordinal.TopRight
                 Direction.Left.Relative(Direction.BottomLeft) => Ordinal.BottomRight
             </summary>
             <param name="direction"></param>
             <param name="relativeOrdinal"></param>
             <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.DirectionUtilities.Up(Microsoft.ProgramSynthesis.Utils.Geometry.Direction)">
            <summary>
            Calculates the relative Up for a given direction assuming the given direction is Up. This ends up being the identity.
            </summary>
            <param name="direction"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.DirectionUtilities.Right(Microsoft.ProgramSynthesis.Utils.Geometry.Direction)">
            <summary>
            Calculates the relative Right for a given direction assuming the given direction is Up.
            </summary>
            <param name="direction"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.DirectionUtilities.Down(Microsoft.ProgramSynthesis.Utils.Geometry.Direction)">
            <summary>
            Calculates the relative Down for a given direction assuming the given direction is Up.
            </summary>
            <param name="direction"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.DirectionUtilities.Left(Microsoft.ProgramSynthesis.Utils.Geometry.Direction)">
            <summary>
            Calculates the relative Left for a given direction assuming the given direction is Up.
            </summary>
            <param name="direction"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.DirectionUtilities.TopLeft(Microsoft.ProgramSynthesis.Utils.Geometry.Direction)">
            <summary>
            Calculates the relative TopLeft for a given direction assuming the given direction is Up.
            </summary>
            <param name="direction"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.DirectionUtilities.TopRight(Microsoft.ProgramSynthesis.Utils.Geometry.Direction)">
            <summary>
            Calculates the relative TopRight for a given direction assuming the given direction is Up.
            </summary>
            <param name="direction"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.DirectionUtilities.BottomRight(Microsoft.ProgramSynthesis.Utils.Geometry.Direction)">
            <summary>
            Calculates the relative BottomRight for a given direction assuming the given direction is Up.
            </summary>
            <param name="direction"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.DirectionUtilities.BottomLeft(Microsoft.ProgramSynthesis.Utils.Geometry.Direction)">
            <summary>
            Calculates the relative BottomLeft for a given direction assuming the given direction is Up.
            </summary>
            <param name="direction"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.DirectionUtilities.ClockwiseOrdinal(Microsoft.ProgramSynthesis.Utils.Geometry.Direction)">
            <summary>
            Returns the Ordinal which is next in the clockwise direction from <see cref="!:dir"/>. This turns out
            to be equivalent to dir.Relative(Ordinal.TopRight)
            </summary>
            <param name="dir"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.DirectionUtilities.CounterClockwiseOrdinal(Microsoft.ProgramSynthesis.Utils.Geometry.Direction)">
            <summary>
            Returns the Ordinal which is next in the counter clockwise direction from <see cref="!:dir"/>. This turns
            out to be equivalent to dir.Relative(Ordinal.TopLeft)
            </summary>
            <param name="dir"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.DirectionUtilities.ClockwiseDirection(Microsoft.ProgramSynthesis.Utils.Geometry.Direction)">
            <summary>
            Returns the Direction which is next in the clockwise direction from <see cref="!:dir"/>. This turns out
            to be equivalent to dir.Relative(Direction.Right)
            </summary>
            <param name="dir"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.DirectionUtilities.CounterClockwiseDirection(Microsoft.ProgramSynthesis.Utils.Geometry.Direction)">
            <summary>
            Returns The Direction which is next in the counter clockwise direction from <see cref="!:dir"/>. This turns
            out to be equivalent to dir.Relative(Direction.Left)
            </summary>
            <param name="dir"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.DirectionUtilities.Opposite(Microsoft.ProgramSynthesis.Utils.Geometry.Direction)">
            <summary>
            Returns the direction opposite from <see cref="!:dir"/>. This turns out to be equivalent to
            dir.Relative(Direction.Down)
            </summary>
            <param name="dir"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Geometry.IBounded`1">
            <summary>
                Interface that provides a <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Bounds`1" /> to allow for geometric helper functions that work on any
                object with a position.
            </summary>
            <typeparam name="TUnit">Unit of the bounds.</typeparam>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Geometry.IPixelBounded">
            <summary>
                Variant of <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.IBounded`1" /> that includes a property with the unit name in the property name to make
                non-unit-generic code more readable.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Geometry.ITableBounded">
            <summary>
                Variant of <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.IBounded`1" /> that includes a property with the unit name in the property name to make
                non-unit-generic code more readable.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Geometry.IRotatedPixelBounded">
            <summary>
                Interface for <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.IApparentPixelBounded" /> objects which may be rotated and have a concept of interacting
                with only objects of the same <see cref="P:Microsoft.ProgramSynthesis.Utils.Geometry.IRotatedPixelBounded.RotationAngle" />. Then when using
                <see cref="P:Microsoft.ProgramSynthesis.Utils.Geometry.IRotatedPixelBounded.ApparentPixelBoundsWithoutRotation" />, the logic can pretend it is working with a non-rotated object.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Geometry.IRotatedPixelBounded.ApparentPixelBoundsWithoutRotation">
            <summary>
                The pixel bounds this should be treated as having when assuming directions are properly oriented (i.e. down is
                where the base line is and right is the direction of the next word for a language with left-to-right reading
                order). This is the <see cref="P:Microsoft.ProgramSynthesis.Utils.Geometry.IApparentPixelBounded.ApparentPixelBounds" /> with a rotation around the origin of
                -<see cref="P:Microsoft.ProgramSynthesis.Utils.Geometry.IRotatedPixelBounded.RotationAngle" />. It only makes sense to use this when comparing to other bounds with the same
                <see cref="P:Microsoft.ProgramSynthesis.Utils.Geometry.IRotatedPixelBounded.RotationAngle" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Geometry.IRotatedPixelBounded.RotationAngle">
            <summary>
                If this is rotated, the angle (in radians) it is rotated by. The
                <see cref="P:Microsoft.ProgramSynthesis.Utils.Geometry.IApparentPixelBounded.StablePixelBounds" /> has already been rotated by this much. The
                <see cref="P:Microsoft.ProgramSynthesis.Utils.Geometry.IApparentPixelBounded.ApparentPixelBounds" /> is this rotation of
                <see cref="P:Microsoft.ProgramSynthesis.Utils.Geometry.IRotatedPixelBounded.ApparentPixelBoundsWithoutRotation" />.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Geometry.IApparentPixelBounded">
            <summary>
                Interface for objects which have a concept of a computed apparent bounds that differs from the bounds provided by
                the ingestion engine. Note this <em>does not</em> extend <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.IBounded`1" /> in order to force users of
                this interface to be explicit about which kind of pixel bounds is desired.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Geometry.IApparentPixelBounded.StablePixelBounds">
            <summary>
                Pixel bounds computed using information on the glyph bounds from the ingestion engine which is expected to be
                stable for use in tests/annotations.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Geometry.IApparentPixelBounded.ApparentPixelBounds">
            <summary>
                Pixel bounds computed to be the apparent bounds of the object. For example, the bounds of the border around a cell
                or a glyph without the whitespace around it.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Geometry.ApparentPixelBoundsWrapper">
            <summary>
                An immutable <c>struct</c> that trivially implements <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.IApparentPixelBounded" /> for calling into
                operations that require one.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Geometry.BoundsWrapper`1">
            <summary>
                An immutable <c>struct</c> that trivially implements <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.IBounded`1" /> for calling into operations
                that expect an <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.IBounded`1" /> when only a <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Bounds`1" /> is available.
            </summary>
            <typeparam name="TUnit">Unit of the bounds.</typeparam>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Geometry.Ordinal">
            <summary>
                An enumeration of the ordinal (or diagonal) directions. Used to refer to the <see cref="M:Microsoft.ProgramSynthesis.Utils.Geometry.Bounds`1.Corner(Microsoft.ProgramSynthesis.Utils.Geometry.Ordinal)" /> of
                a <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Bounds`1" />.
            </summary>
            <seealso cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Direction" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.OrdinalUtilities.Relative(Microsoft.ProgramSynthesis.Utils.Geometry.Ordinal,Microsoft.ProgramSynthesis.Utils.Geometry.Direction)">
             <summary>
             Calculates the direction relative to <see cref="!:ordinal"/> if you assume <see cref="!:ordinal"/> is Ordinal.TopLeft.
            
             Ex:
                 Direction.TopRight.Relative(Direction.Left) => Direction.Up
                 Direction.BottomLeft.Relative(Direction.Down) => Direction.Right
             </summary>
             <param name="ordinal"></param>
             <param name="relativeDirection"></param>
             <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.OrdinalUtilities.Relative(Microsoft.ProgramSynthesis.Utils.Geometry.Ordinal,Microsoft.ProgramSynthesis.Utils.Geometry.Ordinal)">
             <summary>
             Calculates the ordinal relative to <see cref="!:ordinal"/> if you assume <see cref="!:ordinal"/> is Ordinal.TopLeft.
            
             Ex:
                 Direction.TopRight.Relative(Ordinal.BottomRight) => Ordinal.BottomLeft
                 Direction.BottomLeft.Relative(Direction.BottomLeft) => Ordinal.BottomRight
             </summary>
             <param name="ordinal"></param>
             <param name="relativeOrdinal"></param>
             <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.OrdinalUtilities.TopLeft(Microsoft.ProgramSynthesis.Utils.Geometry.Ordinal)">
            <summary>
            Calculates the relative TopLeft for a given ordinal assuming the given ordinal is TopLeft. This ends up being the identity.
            </summary>
            <param name="ordinal"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.OrdinalUtilities.TopRight(Microsoft.ProgramSynthesis.Utils.Geometry.Ordinal)">
            <summary>
            Calculates the relative TopRight for a given ordinal assuming the given ordinal is TopLeft. This ends up being the identity.
            </summary>
            <param name="ordinal"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.OrdinalUtilities.BottomRight(Microsoft.ProgramSynthesis.Utils.Geometry.Ordinal)">
            <summary>
            Calculates the relative BottomRight for a given ordinal assuming the given ordinal is TopLeft. This ends up being the identity.
            </summary>
            <param name="ordinal"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.OrdinalUtilities.BottomLeft(Microsoft.ProgramSynthesis.Utils.Geometry.Ordinal)">
            <summary>
            Calculates the relative BottomLeft for a given ordinal assuming the given ordinal is TopLeft. This ends up being the identity.
            </summary>
            <param name="ordinal"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.OrdinalUtilities.Up(Microsoft.ProgramSynthesis.Utils.Geometry.Ordinal)">
            <summary>
            Calculates the relative Up for a given direction assuming the given ordinal is TopLeft.
            </summary>
            <param name="ordinal"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.OrdinalUtilities.Right(Microsoft.ProgramSynthesis.Utils.Geometry.Ordinal)">
            <summary>
            Calculates the relative Right for a given direction assuming the given ordinal is TopLeft.
            </summary>
            <param name="ordinal"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.OrdinalUtilities.Down(Microsoft.ProgramSynthesis.Utils.Geometry.Ordinal)">
            <summary>
            Calculates the relative Down for a given direction assuming the given ordinal is TopLeft.
            </summary>
            <param name="ordinal"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.OrdinalUtilities.Left(Microsoft.ProgramSynthesis.Utils.Geometry.Ordinal)">
            <summary>
            Calculates the relative Left for a given direction assuming the given ordinal is TopLeft.
            </summary>
            <param name="ordinal"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.OrdinalUtilities.ClockwiseDirection(Microsoft.ProgramSynthesis.Utils.Geometry.Ordinal)">
            <summary>
            Returns the Direction which is next in the clockwise direction from <see cref="!:ordinal"/>. This turns out
            to be equivalent to ordinal.Relative(Direction.Up)
            </summary>
            <param name="ordinal"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.OrdinalUtilities.CounterClockwiseDirection(Microsoft.ProgramSynthesis.Utils.Geometry.Ordinal)">
            <summary>
            Returns the Direction which is next in the counter clockwise direction from <see cref="!:ordinal"/>. This
            turns out to be equivalent to ordinal.Relative(Direction.Left)
            </summary>
            <param name="ordinal"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.OrdinalUtilities.ClockwiseOrdinal(Microsoft.ProgramSynthesis.Utils.Geometry.Ordinal)">
            <summary>
            Returns the Ordinal which is next in the clockwise direction from <see cref="!:ordinal"/>. This turns out
            to be equivalent to ordinal.Relative(Ordinal.TopRight)
            </summary>
            <param name="ordinal"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.OrdinalUtilities.CounterClockwiseOrdinal(Microsoft.ProgramSynthesis.Utils.Geometry.Ordinal)">
            <summary>
            Returns the Ordinal which is next in the counter clockwise direction from <see cref="!:ordinal"/>. This
            turns out to be equivalent to ordinal.Relative(Ordinal.BottomLeft)
            </summary>
            <param name="ordinal"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.OrdinalUtilities.Opposite(Microsoft.ProgramSynthesis.Utils.Geometry.Ordinal)">
            <summary>
            Returns the direction opposite from <see cref="!:ordinal"/>. This turns out to be equivalent to
            ordinal.Relative(Ordinal.BottomRight)
            </summary>
            <param name="ordinal"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Geometry.Range`1">
            <summary>
                An inclusive range between two integers to be used with <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Bounds`1" />. A range only makes sense in
                the context of which <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Axis" /> it is a range of, but it does not store that information.
            </summary>
            <typeparam name="TUnit">Unit this range is in.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.Range`1.Size">
            <summary>
                Returns the inclusive size of a range. For example, range (5, 5) will return 1.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.Range`1.BetweenInclusive(Microsoft.ProgramSynthesis.Utils.Geometry.Range{`0})">
            <summary>
                The range between the two ranges, including the edges of the ranges on either side.
                For example the range between [3,5] and [8,9] is [5,8].
            </summary>
            <param name="other">The other range.</param>
            <returns><c>null</c> if the two ranges are too close to have a range between them or the range between them.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.Range`1.BetweenExclusive(Microsoft.ProgramSynthesis.Utils.Geometry.Range{`0})">
            <summary>
                The range between the two ranges, not including the ranges on either side.
                For example the range between [3,5] and [8,9] is [6,7].
            </summary>
            <param name="other">The other range.</param>
            <returns><c>null</c> if the two ranges are too close to have a range between them or the range between them.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.Range`1.Expand(System.Int32)">
            <summary>
                Create a range larger than this one by <paramref name="amount" /> on both sides (or smaller if <paramref name="amount"/> is negative).
            </summary>
            <param name="amount">Amount to decrease the <see cref="P:Microsoft.ProgramSynthesis.Utils.Geometry.Range`1.Min" /> and increase the <see cref="P:Microsoft.ProgramSynthesis.Utils.Geometry.Range`1.Max" /> by.</param>
            <returns>A range similar to this one with its boundaries adjusted by <paramref name="amount" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.Range`1.Expand(System.Int32,Microsoft.ProgramSynthesis.Utils.Geometry.Derivative)">
            <summary>
                Create a range larger than this one by <paramref name="amount" /> on one side (or smaller if
                <paramref name="amount" /> is negative).
            </summary>
            <param name="amount">Amount to decrease the <see cref="P:Microsoft.ProgramSynthesis.Utils.Geometry.Range`1.Min" /> or increase the <see cref="P:Microsoft.ProgramSynthesis.Utils.Geometry.Range`1.Max" /> by.</param>
            <param name="side">Which side to mutate (<see cref="F:Microsoft.ProgramSynthesis.Utils.Geometry.Derivative.Decreasing" /> means <see cref="P:Microsoft.ProgramSynthesis.Utils.Geometry.Range`1.Min" />.</param>
            <returns>A range similar to this one with its boundaries adjusted by <paramref name="amount" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.RangeUtils.AsRanges``1(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
                Groups a sorted list of <c>int</c>s into a series of ranges covering the same <c>int</c>s. That is,
                <c>AsRanges(xs).SelectMany(x => x.AsEnumerable)</c> contains the same values as <c>xs</c>.
            </summary>
            <typeparam name="T">Unit of range to generate.</typeparam>
            <param name="xs">A sorted (ascending or descending) list of <c>int</c>s.</param>
            <returns>A lazily computed sequence of <see cref="M:Microsoft.ProgramSynthesis.Utils.Geometry.RangeUtils.Range``1(System.Collections.Generic.IEnumerable{System.Int32})" />s covering the same values as <paramref name="xs" />.</returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.AdjacentClumps(System.Collections.Generic.IEnumerable{System.Int32},System.Int32,System.Nullable{System.Int32})" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Geometry.Ranges`1">
            <summary>
                A representation of a set of points in a line as a collection of non-overlapping <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Range`1" />s.
            </summary>
            <typeparam name="TUnit">Unit these ranges are in.</typeparam>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Geometry.Ranges`1._entireRange">
            <summary>
                The entire range covered by these ranges. <see cref="F:Microsoft.ProgramSynthesis.Utils.Geometry.Ranges`1._ranges" /> represents this range, possibly with gaps.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.Ranges`1.#ctor(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Utils.Geometry.Range{`0}})">
            <summary>
                Constructs a collection of ranges.
            </summary>
            <param name="ranges">A non-overlapping collection of <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Range`1" />s.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.Ranges`1.MinDistance(Microsoft.ProgramSynthesis.Utils.Geometry.Ranges{`0})">
            <summary>
                Computes the distance between this collection of ranges and another collection of ranges, defined as the minimum
                distance between any pair of ranges in this collection and in the other collection.
            </summary>
            <param name="other">The other collection of ranges to find the distance to.</param>
            <returns>
                <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if either collection of ranges is empty or, otherwise, the minimum distance
                from any range in this collection to a range in <paramref name="other" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.RectangularArrayExtensions.Select``1(Microsoft.ProgramSynthesis.Utils.Geometry.Bounds{Microsoft.ProgramSynthesis.Utils.Geometry.TableUnit},System.Func{Microsoft.ProgramSynthesis.Utils.Geometry.Vector{Microsoft.ProgramSynthesis.Utils.Geometry.TableUnit},``0})">
            <summary>
                Construct of a <see cref="T:Microsoft.ProgramSynthesis.Utils.RectangularArray`1" /> based on information about a given <see cref="T:Microsoft.ProgramSynthesis.Utils.Geometry.Bounds`1" />
            </summary>
            <typeparam name="T">Type of elements of the resulting array.</typeparam>
            <param name="bounds">
                Area to base array on. Each point in this area will have a corresponding element in the resulting
                array.
            </param>
            <param name="func">Function which returns information on a point to put in the resulting array.</param>
            <returns>
                A <see cref="T:Microsoft.ProgramSynthesis.Utils.RectangularArray`1" /> where each element corresponds to a point in <paramref name="bounds" />
                and contains the result of computing <paramref name="func" /> on that point.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.RectangularArrayExtensions.Enumerate``1(Microsoft.ProgramSynthesis.Utils.RectangularArray{``0},Microsoft.ProgramSynthesis.Utils.Geometry.Axis,Microsoft.ProgramSynthesis.Utils.Geometry.Derivative)">
            <summary>
                Enumerate over the values of a <see cref="T:Microsoft.ProgramSynthesis.Utils.RectangularArray`1" /> along with their indexes.
            </summary>
            <typeparam name="T">Type of elements.</typeparam>
            <param name="xs">The <see cref="T:Microsoft.ProgramSynthesis.Utils.RectangularArray`1" /> to enumerate.</param>
            <param name="majorAxis"><see cref="M:Microsoft.ProgramSynthesis.Utils.Geometry.Bounds`1.AsEnumerable(Microsoft.ProgramSynthesis.Utils.Geometry.Axis,Microsoft.ProgramSynthesis.Utils.Geometry.Derivative)" /></param>
            <param name="derivative"><see cref="M:Microsoft.ProgramSynthesis.Utils.Geometry.Bounds`1.AsEnumerable(Microsoft.ProgramSynthesis.Utils.Geometry.Axis,Microsoft.ProgramSynthesis.Utils.Geometry.Derivative)" /></param>
            <returns>Pairs of indexes and values of <paramref name="xs" /> in the specified order.</returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.Utils.CollectionUtils.Enumerate``1(System.Collections.Generic.IEnumerable{``0})" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.RectangularArrayExtensions.ToRectangularArray``1(System.Collections.Generic.IReadOnlyList{System.Collections.Generic.IReadOnlyList{``0}},Microsoft.ProgramSynthesis.Utils.Geometry.Axis)">
            <summary>
                Convert a list of lists to a <see cref="T:Microsoft.ProgramSynthesis.Utils.RectangularArray`1" />.
            </summary>
            <typeparam name="T">Type of elements.</typeparam>
            <param name="xss">A list of equal length lists.</param>
            <param name="majorAxis">
                If <see cref="F:Microsoft.ProgramSynthesis.Utils.Geometry.Axis.Horizontal" />, <paramref name="xss" /> is a list of rows,
                otherwise it is a list of columns.
            </param>
            <returns>A <see cref="T:Microsoft.ProgramSynthesis.Utils.RectangularArray`1" /> containing the same values as <paramref name="xss" /></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.RectangularArrayExtensions.ToRectangularArray``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}},Microsoft.ProgramSynthesis.Utils.Geometry.Axis)">
            <summary>
                Convert an enumerable of enumerables to a <see cref="T:Microsoft.ProgramSynthesis.Utils.RectangularArray`1" />.
            </summary>
            <typeparam name="T">Type of elements.</typeparam>
            <param name="xss">An enumerable of equal length enumerables.</param>
            <param name="majorAxis">
                If <see cref="F:Microsoft.ProgramSynthesis.Utils.Geometry.Axis.Horizontal" />, <paramref name="xss" /> is an enumerable of rows,
                otherwise it is an enumerable of columns.
            </param>
            <returns>A <see cref="T:Microsoft.ProgramSynthesis.Utils.RectangularArray`1" /> containing the same values as <paramref name="xss" /></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Geometry.Vector`1">
            <summary>
                A pair of numbers representing either a change in two dimensional coordinates
                or a position in the 2D integer plane.
            </summary>
            <typeparam name="TUnit"></typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.Vector`1.#ctor(Microsoft.ProgramSynthesis.Utils.Geometry.Direction,System.Int32)">
            <summary>
                Initializes the vector as a change in position of <see cref="!:amount" /> in direction <see cref="!:direction" />
            </summary>
            <param name="direction"></param>
            <param name="amount"></param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.Vector`1.#ctor(Microsoft.ProgramSynthesis.Utils.Geometry.Ordinal,System.Int32)">
            <summary>
                Initializes the vector as a change in position of <see cref="!:amount" /> in direction <see cref="!:ordinal" />
            </summary>
            <param name="ordinal"></param>
            <param name="amount"></param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Geometry.DoubleVector`1">
            <summary>
                A pair of numbers representing either a change in two dimensional coordinates or a position in the 2D floating
                point plane.
            </summary>
            <typeparam name="TUnit"></typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.DoubleVector`1.#ctor(Microsoft.ProgramSynthesis.Utils.Geometry.Direction,System.Double)">
            <summary>
                Initializes the vector as a change in position of <see cref="!:amount" /> in direction <see cref="!:direction" />
            </summary>
            <param name="direction"></param>
            <param name="amount"></param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.DoubleVector`1.#ctor(Microsoft.ProgramSynthesis.Utils.Geometry.Ordinal,System.Double)">
            <summary>
                Initializes the vector as a change in position of <see cref="!:amount" /> in direction <see cref="!:ordinal" />
            </summary>
            <param name="ordinal"></param>
            <param name="amount"></param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Geometry.DoubleVector`1.DistanceTo(Microsoft.ProgramSynthesis.Utils.Geometry.DoubleVector{`0})">
            <summary>
                The distance from this point to another point.
            </summary>
            <param name="other">Point to get the distance to.</param>
            <returns>The distance between the two points.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Geometry.DoubleVector`1.Length">
            <summary>
                The length of this vector (or, equivalently, the distance from the origin to this point).
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.GrammarType">
            <summary>
                Represents a resolved or unresolved type in a grammar.  Unresolved types are only used when
                only compiling C# utilities from a grammar file.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.GrammarType.CsName">
            <summary>
                Returns the C# name of the type.
            </summary>
            <returns>The C# name of the type.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.GrammarType.Type">
            <summary>
                Returns the resolved type, if available.  Otherwise returns <c>null</c>.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.GrammarType.IsStatic">
            <summary>
                Returns whether or not the type in question is static, if available.  Otherwise returns <c>null</c>.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.GrammarType.Location">
            <summary>
                Returns a <see cref="P:Microsoft.ProgramSynthesis.Utils.GrammarType.Location"/> for the definition of the type (either in source or an assembly) if
                available.  Otherwise returns <c>null</c>.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.GrammarType.Name">
            <summary>
                Returns the name of the type if available.  Otherwise returns <c>null</c>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.GrammarType.GetMethod(System.String,System.Reflection.BindingFlags,System.Type[])">
            <summary>
                Returns the specified <see cref="T:System.Reflection.MethodInfo"/> if available.  Otherwise returns <c>null</c>.
            </summary>
            <remarks>
                Only returns non-null when this is actually a <see cref="T:Microsoft.ProgramSynthesis.Utils.ResolvedType"/> (ie. at runtime).
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.GrammarType.GetMethods(System.Reflection.BindingFlags)">
            <summary>
                Returns an array of <see cref="T:System.Reflection.MethodInfo"/> for the specified methods.  Otherwise returns an empty
                array.
            </summary>
            <remarks>
                Only returns non-empty when this is actually a <see cref="T:Microsoft.ProgramSynthesis.Utils.ResolvedType"/> (ie. at runtime).
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.GrammarType.GetMember(System.String)">
            <summary>
                Returns MemberInfos for matching public members on the type if available.  Otherwise returns an empty
                array.
            </summary>
            <remarks>
                Only returns non-empty when this is actually a <see cref="T:Microsoft.ProgramSynthesis.Utils.ResolvedType"/> (ie. at runtime).
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.GrammarType.op_Equality(Microsoft.ProgramSynthesis.Utils.GrammarType,Microsoft.ProgramSynthesis.Utils.GrammarType)">
            <summary>
                Determines whether the specified types are equal.
            </summary>
            <param name="type1">The first type to compare.</param>
            <param name="type2">The second type to compare.</param>
            <returns>True of the types are equal.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.GrammarType.op_Inequality(Microsoft.ProgramSynthesis.Utils.GrammarType,Microsoft.ProgramSynthesis.Utils.GrammarType)">
            <summary>
                Determines whether the specified types are not equal.
            </summary>
            <param name="type1">The first type to compare.</param>
            <param name="type2">The second type to compare.</param>
            <returns>True of the types are not equal.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.GrammarType.Equals(Microsoft.ProgramSynthesis.Utils.GrammarType)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.GrammarType.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.GrammarType.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.HttpUtils.CreateHttpClient">
            <summary>
            Create HttpClient -- ensuring that we check certificate revocation list even on Net45
            </summary>
            <returns>A new instance of HttpClient</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interval.Equals(Microsoft.ProgramSynthesis.Utils.Interval)">
            <summary>Indicates whether the current object is equal to another object of the same type.</summary>
            <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interval.Equals(System.Object)">
            <summary>Indicates whether this instance and a specified object are equal.</summary>
            <returns>
                true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise,
                false.
            </returns>
            <param name="obj">The object to compare with the current instance. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interval.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
            <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Interval.ToString">
            <summary>Returns the fully qualified type name of this instance.</summary>
            <returns>A <see cref="T:System.String" /> containing a fully qualified type name.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.IntervalSet">
            <summary>
                A data structure for representing a collection of <see cref="T:Microsoft.ProgramSynthesis.Utils.Interval"/>s,
                allowing fast computation of the <see cref="T:Microsoft.ProgramSynthesis.Utils.Interval"/>s in a region
                that are not covered by other <see cref="T:Microsoft.ProgramSynthesis.Utils.Interval"/>s.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IntervalSet.#ctor(System.Int32,System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="universeStart">The start index of the <see cref="T:Microsoft.ProgramSynthesis.Utils.Interval"/> universe.</param>
            <param name="universeEnd">The end index of the <see cref="T:Microsoft.ProgramSynthesis.Utils.Interval"/> universe.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IntervalSet.#ctor(Microsoft.ProgramSynthesis.Utils.Interval)">
            <summary>
                Constructor.
            </summary>
            <param name="universe">The <see cref="T:Microsoft.ProgramSynthesis.Utils.Interval"/> universe.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.IntervalSet.Universe">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.Utils.Interval"/> universe.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.IntervalSet.UniverseStart">
            <summary>
                The first index in the <see cref="T:Microsoft.ProgramSynthesis.Utils.Interval"/> universe.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.IntervalSet.UniverseEnd">
            <summary>
                The last index (exclusive) in the <see cref="T:Microsoft.ProgramSynthesis.Utils.Interval"/> universe.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.IntervalSet.UniverseLength">
            <summary>
                The length of the <see cref="T:Microsoft.ProgramSynthesis.Utils.Interval"/> universe.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.IntervalSet.UncoveredIntervals">
            <summary>
                The set of <see cref="T:Microsoft.ProgramSynthesis.Utils.Interval"/>s in <see cref="P:Microsoft.ProgramSynthesis.Utils.IntervalSet.Universe"/> that are not covered by any other <see cref="T:Microsoft.ProgramSynthesis.Utils.Interval"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IntervalSet.CoverInterval(Microsoft.ProgramSynthesis.Utils.Interval)">
            <summary>
                Mark an interval as being covered.
            </summary>
            <param name="interval">The interval to mark as being covered.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IntervalSet.CoverInterval(System.Int32,System.Int32)">
            <summary>
                Mark an interval as being covered.
            </summary>
            <param name="intervalStart">The start of the interval.</param>
            <param name="intervalEnd">The end of the interval.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IOUtils.RepeatRead(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
                Reads a sequence of bytes from the given stream and advances the position within the stream by the
                number of bytes read.
            </summary>
            <param name="s">The stream to read from.</param>
            <param name="buffer">
                An array of bytes.  When this method returns, the buffer contains the specified byte array with the
                values between <c>offset</c> and <c>(offset + [return value] - 1)</c> replaced by the bytes read from
                the source.
            </param>
            <param name="offset">
                The zero-based byte offset in buffer at which to begin storing the data read from s.
            </param>
            <param name="count">The maximum number of bytes to be read from the stream.</param>
            <returns>
                The total number of bytes read into the buffer.  This can be less than the number of bytes requested
                if the end of the stream has been reached.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IOUtils.RepeatReadAndAllocate(System.IO.Stream,System.Int32)">
            <summary>
                Reads a sequence of bytes from the given stream and advances the position within the stream by the
                number of bytes read.
            </summary>
            <param name="s">The stream to read from.</param>
            <param name="count">The maximum number of bytes to be read from the stream.</param>
            <returns>
                A buffer that contains the bytes read from the stream.  This can be less than the number of bytes
                requested if the end of the stream has been reached.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.IRegion`1">
            <summary>
            Represents a region in a document such as a string in a text file.
            </summary>
            <typeparam name="T">The region type.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IRegion`1.Contains(`0)">
            <summary>
                Checks if this region contains <paramref name="other" /> region.
            </summary>
            <param name="other">The region to look for in this region.</param>
            <returns>True if <paramref name="other" /> is a region in the same document contained inside or equal to this region.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IRegion`1.IntersectNonEmpty(`0)">
            <summary>
            Checks if this region intersects with <paramref name="other" /> region.
            </summary>
            <param name="other">The region needs to check for intersection.</param>
            <returns>True if they intersect, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IRegion`1.IsBefore(`0)">
            <summary>
            Checks if this region appears before <paramref name="other" /> region.
            </summary>
            <param name="other">The region to check.</param>
            <returns>True if this region appears first, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IRegion`1.ClipBefore(`0)">
            <summary>
                Clip this region to end before <paramref name="other" />.
            </summary>
            <param name="other">A region starting after this one.</param>
            <returns>A region that starts at the same position but ends before <paramref name="other" />.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.IRenderableLiteral">
            <summary><para>
            A type that can be used as a literal value in Microsoft.ProgramSynthesis ASTs.
            It needs to support rendering itself in two standard ways: XML representation (using <see cref="M:Microsoft.ProgramSynthesis.Utils.IRenderableLiteral.RenderXML"/>) and human-readable
            string representation (using <see cref="M:Microsoft.ProgramSynthesis.Utils.IRenderableLiteral.RenderHumanReadable"/>).
            </para>
            <para>
            This type has to be also marked with <see cref="T:Microsoft.ProgramSynthesis.Utils.ParseableAttribute"/>, which specifies the corresponding methods for parsing the
            instances out of their rendered representations.
            Parsing an XML representation is a required capability (using the method specified in <see cref="P:Microsoft.ProgramSynthesis.Utils.ParseableAttribute.ParseXML"/>).
            Parsing a human-readable string is optional (using the method specified in <see cref="P:Microsoft.ProgramSynthesis.Utils.ParseableAttribute.ParseHumanReadableString"/>).
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IRenderableLiteral.RenderHumanReadable">
            <summary>
                Render this as a human-readable string representation. This should be parseable by the corresponding
                <see cref="P:Microsoft.ProgramSynthesis.Utils.ParseableAttribute.ParseHumanReadableString" /> method.
            </summary>
            <returns>A compact string representation of this object that is easy for a human to understand.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.IRenderableLiteral.RenderXML">
            <summary>
                Render this as XML. This should be parseable by the corresponding <see cref="P:Microsoft.ProgramSynthesis.Utils.ParseableAttribute.ParseXML" />
                method.
            </summary>
            <returns>An XML representation of this object.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.ParseableAttribute.ParseHumanReadableString">
            <summary>
            An optional method for parsing a human-readable <see cref="T:System.String"/> instance into an instance of a target class.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.ParseableAttribute.ParseXML">
            <summary>
            A required method for parsing an <see cref="T:System.Xml.Linq.XElement"/> instance into an instance of a target class.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.ParseableAttribute.DeclaringType">
            <summary>
            The type on which <see cref="P:Microsoft.ProgramSynthesis.Utils.ParseableAttribute.ParseHumanReadableString"/> and <see cref="P:Microsoft.ProgramSynthesis.Utils.ParseableAttribute.ParseXML"/> methods are defined.
            By default, uses the target type of this attribute.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.NamespaceDoc">
            <summary>
                For internal use only; members are <c>public</c> due to technical restrictions.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.CanBeNullAttribute">
            <summary>
                Indicates that the value of the marked element could be <c>null</c> sometimes,
                so the check for <c>null</c> is necessary before its usage.
            </summary>
            <example>
                <code>
            [CanBeNull] object Test() => null;
            
            void UseTest() {
              var p = Test();
              var s = p.ToString(); // Warning: Possible 'System.NullReferenceException'
            }
            </code>
            </example>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.NotNullAttribute">
            <summary>
                Indicates that the value of the marked element could never be <c>null</c>.
            </summary>
            <example>
                <code>
            [NotNull] object Foo() {
              return null; // Warning: Possible 'null' assignment
            }
            </code>
            </example>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.ItemNotNullAttribute">
            <summary>
                Can be appplied to symbols of types derived from IEnumerable as well as to symbols of Task
                and Lazy classes to indicate that the value of a collection item, of the Task.Result property
                or of the Lazy.Value property can never be null.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.ItemCanBeNullAttribute">
            <summary>
                Can be appplied to symbols of types derived from IEnumerable as well as to symbols of Task
                and Lazy classes to indicate that the value of a collection item, of the Task.Result property
                or of the Lazy.Value property can be null.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.StringFormatMethodAttribute">
            <summary>
                Indicates that the marked method builds string by format pattern and (optional) arguments.
                Parameter, which contains format string, should be given in constructor. The format string
                should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />-like form.
            </summary>
            <example>
                <code>
            [StringFormatMethod("message")]
            void ShowError(string message, params object[] args) { /* do something */ }
            
            void Foo() {
              ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
            }
            </code>
            </example>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <param name="formatParameterName">
                Specifies which parameter of an annotated method should be treated as format-string
            </param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.ValueProviderAttribute">
            <summary>
                For a parameter that is expected to be one of the limited set of values.
                Specify fields of which type should be used as values for this parameter.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.InvokerParameterNameAttribute">
            <summary>
                Indicates that the function argument should be string literal and match one
                of the parameters of the caller function. For example, ReSharper annotates
                the parameter of <see cref="T:System.ArgumentNullException" />.
            </summary>
            <example>
                <code>
            void Foo(string param) {
              if (param == null)
                throw new ArgumentNullException("par"); // Warning: Cannot resolve symbol
            }
            </code>
            </example>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.NotifyPropertyChangedInvocatorAttribute">
            <summary>
                Indicates that the method is contained in a type that implements
                <c>System.ComponentModel.INotifyPropertyChanged</c> interface and this method
                is used to notify that some property value changed.
            </summary>
            <remarks>
                The method should be non-static and conform to one of the supported signatures:
                <list>
                    <item><c>NotifyChanged(string)</c></item>
                    <item><c>NotifyChanged(params string[])</c></item>
                    <item><c>NotifyChanged{T}(Expression{Func{T}})</c></item>
                    <item><c>NotifyChanged{T,U}(Expression{Func{T,U}})</c></item>
                    <item><c>SetProperty{T}(ref T, T, string)</c></item>
                </list>
            </remarks>
            <example>
                <code>
             public class Foo : INotifyPropertyChanged {
               public event PropertyChangedEventHandler PropertyChanged;
             
               [NotifyPropertyChangedInvocator]
               protected virtual void NotifyChanged(string propertyName) { ... }
            
               string _name;
             
               public string Name {
                 get { return _name; }
                 set { _name = value; NotifyChanged("LastName"); /* Warning */ }
               }
             }
             </code>
                Examples of generated notifications:
                <list>
                    <item><c>NotifyChanged("Property")</c></item>
                    <item><c>NotifyChanged(() =&gt; Property)</c></item>
                    <item><c>NotifyChanged((VM x) =&gt; x.Property)</c></item>
                    <item><c>SetProperty(ref myField, value, "Property")</c></item>
                </list>
            </example>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.ContractAnnotationAttribute">
            <summary>
                Describes dependency between method input and output.
            </summary>
            <syntax>
                <p>Function Definition Table syntax:</p>
                <list>
                    <item>FDT      ::= FDTRow [;FDTRow]*</item>
                    <item>FDTRow   ::= Input =&gt; Output | Output &lt;= Input</item>
                    <item>Input    ::= ParameterName: Value [, Input]*</item>
                    <item>Output   ::= [ParameterName: Value]* {halt|stop|void|nothing|Value}</item>
                    <item>Value    ::= true | false | null | notnull | canbenull</item>
                </list>
                If method has single input parameter, it's name could be omitted.<br />
                Using <c>halt</c> (or <c>void</c>/<c>nothing</c>, which is the same) for method output
                means that the methos doesn't return normally (throws or terminates the process).<br />
                Value <c>canbenull</c> is only applicable for output parameters.<br />
                You can use multiple <c>[ContractAnnotation]</c> for each FDT row, or use single attribute
                with rows separated by semicolon. There is no notion of order rows, all rows are checked
                for applicability and applied per each program state tracked by R# analysis.<br />
            </syntax>
            <examples>
                <list>
                    <item>
                        <code>
            [ContractAnnotation("=&gt; halt")]
            public void TerminationMethod()
            </code>
                    </item>
                    <item>
                        <code>
            [ContractAnnotation("halt &lt;= condition: false")]
            public void Assert(bool condition, string text) // regular assertion method
            </code>
                    </item>
                    <item>
                        <code>
            [ContractAnnotation("s:null =&gt; true")]
            public bool IsNullOrEmpty(string s) // string.IsNullOrEmpty()
            </code>
                    </item>
                    <item>
                        <code>
            // A method that returns null if the parameter is null,
            // and not null if the parameter is not null
            [ContractAnnotation("null =&gt; null; notnull =&gt; notnull")]
            public object Transform(object data)
            </code>
                    </item>
                    <item>
                        <code>
            [ContractAnnotation("=&gt; true, result: notnull; =&gt; false, result: null")]
            public bool TryParse(string s, out Person result)
            </code>
                    </item>
                </list>
            </examples>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.LocalizationRequiredAttribute">
            <summary>
                Indicates that marked element should be localized or not.
            </summary>
            <example>
                <code>
            [LocalizationRequiredAttribute(true)]
            class Foo {
              string str = "my string"; // Warning: Localizable string
            }
            </code>
            </example>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.CannotApplyEqualityOperatorAttribute">
            <summary>
                Indicates that the value of the marked type (or its derivatives)
                cannot be compared using '==' or '!=' operators and <c>Equals()</c>
                should be used instead. However, using '==' or '!=' for comparison
                with <c>null</c> is always permitted.
            </summary>
            <example>
                <code>
            [CannotApplyEqualityOperator]
            class NoEquality { }
            
            class UsesNoEquality {
              void Test() {
                var ca1 = new NoEquality();
                var ca2 = new NoEquality();
                if (ca1 != null) { // OK
                  bool condition = ca1 == ca2; // Warning
                }
              }
            }
            </code>
            </example>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.BaseTypeRequiredAttribute">
            <summary>
                When applied to a target attribute, specifies a requirement for any type marked
                with the target attribute to implement or inherit specific type or types.
            </summary>
            <example>
                <code>
            [BaseTypeRequired(typeof(IComponent)] // Specify requirement
            class ComponentAttribute : Attribute { }
            
            [Component] // ComponentAttribute requires implementing IComponent interface
            class MyComponent : IComponent { }
            </code>
            </example>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.UsedImplicitlyAttribute">
            <summary>
                Indicates that the marked symbol is used implicitly (e.g. via reflection, in external library),
                so this symbol will not be marked as unused (as well as by other usage inspections).
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.MeansImplicitUseAttribute">
            <summary>
                Should be used on attributes and causes ReSharper to not mark symbols marked with such attributes
                as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.ImplicitUseKindFlags.Access">
            <summary>Only entity marked with attribute considered used.</summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.ImplicitUseKindFlags.Assign">
            <summary>Indicates implicit assignment to a member.</summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.ImplicitUseKindFlags.InstantiatedWithFixedConstructorSignature">
            <summary>
                Indicates implicit instantiation of a type with fixed constructor signature.
                That means any unused constructor parameters won't be reported as such.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.ImplicitUseKindFlags.InstantiatedNoFixedConstructorSignature">
            <summary>Indicates implicit instantiation of a type.</summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.ImplicitUseTargetFlags">
            <summary>
                Specify what is considered used implicitly when marked
                with <see cref="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.MeansImplicitUseAttribute" /> or <see cref="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.UsedImplicitlyAttribute" />.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.ImplicitUseTargetFlags.Members">
            <summary>Members of entity marked with attribute are considered used.</summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.ImplicitUseTargetFlags.WithMembers">
            <summary>Entity marked with attribute and all its members considered used.</summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.PublicAPIAttribute">
            <summary>
                This attribute is intended to mark publicly available API
                which should not be removed and so is treated as used.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.InstantHandleAttribute">
            <summary>
                Tells code analysis engine if the parameter is completely handled when the invoked method is on stack.
                If the parameter is a delegate, indicates that delegate is executed while the method is executed.
                If the parameter is an enumerable, indicates that it is enumerated while the method is executed.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.PureAttribute">
            <summary>
                Indicates that a method does not make any observable state changes.
                The same as <c>System.Diagnostics.Contracts.PureAttribute</c>.
            </summary>
            <example>
                <code>
            [Pure] int Multiply(int x, int y) => x * y;
            
            void M() {
              Multiply(123, 42); // Waring: Return value of pure method is not used
            }
            </code>
            </example>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.MustUseReturnValueAttribute">
            <summary>
                Indicates that the return value of method invocation must be used.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.ProvidesContextAttribute">
            <summary>
                Indicates the type member or parameter of some type, that should be used instead of all other ways
                to get the value that type. This annotation is useful when you have some "context" value evaluated
                and stored somewhere, meaning that all other ways to get this value must be consolidated with existing one.
            </summary>
            <example>
                <code>
            class Foo {
              [ProvidesContext] IBarService _barService = ...;
            
              void ProcessNode(INode node) {
                DoSomething(node, node.GetGlobalServices().Bar);
                //              ^ Warning: use value of '_barService' field
              }
            }
            </code>
            </example>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.PathReferenceAttribute">
            <summary>
                Indicates that a parameter is a path to a file or a folder within a web project.
                Path can be relative or absolute, starting from web root (~).
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.SourceTemplateAttribute">
            <summary>
                An extension method marked with this attribute is processed by ReSharper code completion
                as a 'Source Template'. When extension method is completed over some expression, it's source code
                is automatically expanded like a template at call site.
            </summary>
            <remarks>
                Template method body can contain valid source code and/or special comments starting with '$'.
                Text inside these comments is added as source code when the template is applied. Template parameters
                can be used either as additional method parameters or as identifiers wrapped in two '$' signs.
                Use the <see cref="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.MacroAttribute" /> attribute to specify macros for parameters.
            </remarks>
            <example>
                In this example, the 'forEach' method is a source template available over all values
                of enumerable types, producing ordinary C# 'foreach' statement and placing caret inside block:
                <code>
            [SourceTemplate]
            public static void forEach&lt;T&gt;(this IEnumerable&lt;T&gt; xs) {
              foreach (var x in xs) {
                 //$ $END$
              }
            }
            </code>
            </example>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.MacroAttribute">
            <summary>
                Allows specifying a macro for a parameter of a <see cref="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.SourceTemplateAttribute">source template</see>.
            </summary>
            <remarks>
                You can apply the attribute on the whole method or on any of its additional parameters. The macro expression
                is defined in the <see cref="P:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.MacroAttribute.Expression" /> property. When applied on a method, the target
                template parameter is defined in the <see cref="P:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.MacroAttribute.Target" /> property. To apply the macro silently
                for the parameter, set the <see cref="P:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.MacroAttribute.Editable" /> property value = -1.
            </remarks>
            <example>
                Applying the attribute on a source template method:
                <code>
            [SourceTemplate, Macro(Target = "item", Expression = "suggestVariableName()")]
            public static void forEach&lt;T&gt;(this IEnumerable&lt;T&gt; collection) {
              foreach (var item in collection) {
                //$ $END$
              }
            }
            </code>
                Applying the attribute on a template method parameter:
                <code>
            [SourceTemplate]
            public static void something(this Entity x, [Macro(Expression = "guid()", Editable = -1)] string newguid) {
              /*$ var $x$Id = "$newguid$" + x.ToString();
              x.DoSomething($x$Id); */
            }
            </code>
            </example>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.MacroAttribute.Expression">
            <summary>
                Allows specifying a macro that will be executed for a <see cref="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.SourceTemplateAttribute">source template</see>
                parameter when the template is expanded.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.MacroAttribute.Editable">
            <summary>
                Allows specifying which occurrence of the target parameter becomes editable when the template is deployed.
            </summary>
            <remarks>
                If the target parameter is used several times in the template, only one occurrence becomes editable;
                other occurrences are changed synchronously. To specify the zero-based index of the editable occurrence,
                use values >= 0. To make the parameter non-editable when the template is expanded, use -1.
            </remarks>
            >
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.MacroAttribute.Target">
            <summary>
                Identifies the target parameter of a <see cref="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.SourceTemplateAttribute">source template</see> if the
                <see cref="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.MacroAttribute" /> is applied on a template method.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.AspMvcActionAttribute">
            <summary>
                ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
                is an MVC action. If applied to a method, the MVC action name is calculated
                implicitly from the context. Use this attribute for custom wrappers similar to
                <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.AspMvcAreaAttribute">
            <summary>
                ASP.NET MVC attribute. Indicates that a parameter is an MVC area.
                Use this attribute for custom wrappers similar to
                <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.AspMvcControllerAttribute">
            <summary>
                ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is
                an MVC controller. If applied to a method, the MVC controller name is calculated
                implicitly from the context. Use this attribute for custom wrappers similar to
                <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String, String)</c>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.AspMvcMasterAttribute">
            <summary>
                ASP.NET MVC attribute. Indicates that a parameter is an MVC Master. Use this attribute
                for custom wrappers similar to <c>System.Web.Mvc.Controller.View(String, String)</c>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.AspMvcModelTypeAttribute">
            <summary>
                ASP.NET MVC attribute. Indicates that a parameter is an MVC model type. Use this attribute
                for custom wrappers similar to <c>System.Web.Mvc.Controller.View(String, Object)</c>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.AspMvcPartialViewAttribute">
            <summary>
                ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is an MVC
                partial view. If applied to a method, the MVC partial view name is calculated implicitly
                from the context. Use this attribute for custom wrappers similar to
                <c>System.Web.Mvc.Html.RenderPartialExtensions.RenderPartial(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.AspMvcSuppressViewErrorAttribute">
            <summary>
                ASP.NET MVC attribute. Allows disabling inspections for MVC views within a class or a method.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.AspMvcDisplayTemplateAttribute">
            <summary>
                ASP.NET MVC attribute. Indicates that a parameter is an MVC display template.
                Use this attribute for custom wrappers similar to
                <c>System.Web.Mvc.Html.DisplayExtensions.DisplayForModel(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.AspMvcEditorTemplateAttribute">
            <summary>
                ASP.NET MVC attribute. Indicates that a parameter is an MVC editor template.
                Use this attribute for custom wrappers similar to
                <c>System.Web.Mvc.Html.EditorExtensions.EditorForModel(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.AspMvcTemplateAttribute">
            <summary>
                ASP.NET MVC attribute. Indicates that a parameter is an MVC template.
                Use this attribute for custom wrappers similar to
                <c>System.ComponentModel.DataAnnotations.UIHintAttribute(System.String)</c>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.AspMvcViewAttribute">
            <summary>
                ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
                is an MVC view component. If applied to a method, the MVC view name is calculated implicitly
                from the context. Use this attribute for custom wrappers similar to
                <c>System.Web.Mvc.Controller.View(Object)</c>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.AspMvcViewComponentAttribute">
            <summary>
                ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
                is an MVC view component name.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.AspMvcViewComponentViewAttribute">
            <summary>
                ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
                is an MVC view component view. If applied to a method, the MVC view component view name is default.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.AspMvcActionSelectorAttribute">
            <summary>
                ASP.NET MVC attribute. When applied to a parameter of an attribute,
                indicates that this parameter is an MVC action name.
            </summary>
            <example>
                <code>
            [ActionName("Foo")]
            public ActionResult Login(string returnUrl) {
              ViewBag.ReturnUrl = Url.Action("Foo"); // OK
              return RedirectToAction("Bar"); // Error: Cannot resolve action
            }
            </code>
            </example>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.RazorSectionAttribute">
            <summary>
                Razor attribute. Indicates that a parameter or a method is a Razor section.
                Use this attribute for custom wrappers similar to
                <c>System.Web.WebPages.WebPageBase.RenderSection(String)</c>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.CollectionAccessAttribute">
            <summary>
                Indicates how method, constructor invocation or property access
                over collection type affects content of the collection.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.CollectionAccessType.None">
            <summary>Method does not use or modify content of the collection.</summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.CollectionAccessType.Read">
            <summary>Method only reads content of the collection but does not modify it.</summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.CollectionAccessType.ModifyExistingContent">
            <summary>Method can change content of the collection but does not add new elements.</summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.CollectionAccessType.UpdatedContent">
            <summary>Method can add new elements to the collection.</summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.AssertionMethodAttribute">
            <summary>
                Indicates that the marked method is assertion method, i.e. it halts control flow if
                one of the conditions is satisfied. To set the condition, mark one of the parameters with
                <see cref="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.AssertionConditionAttribute" /> attribute.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.AssertionConditionAttribute">
            <summary>
                Indicates the condition parameter of the assertion method. The method itself should be
                marked by <see cref="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.AssertionMethodAttribute" /> attribute. The mandatory argument of
                the attribute is the assertion type.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.AssertionConditionType">
            <summary>
                Specifies assertion type. If the assertion method argument satisfies the condition,
                then the execution continues. Otherwise, execution is assumed to be halted.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.AssertionConditionType.IS_TRUE">
            <summary>Marked parameter should be evaluated to true.</summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.AssertionConditionType.IS_FALSE">
            <summary>Marked parameter should be evaluated to false.</summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.AssertionConditionType.IS_NULL">
            <summary>Marked parameter should be evaluated to null value.</summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.AssertionConditionType.IS_NOT_NULL">
            <summary>Marked parameter should be evaluated to not null value.</summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.TerminatesProgramAttribute">
            <summary>
                Indicates that the marked method unconditionally terminates control flow execution.
                For example, it could unconditionally throw exception.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.LinqTunnelAttribute">
            <summary>
                Indicates that method is pure LINQ method, with postponed enumeration (like Enumerable.Select,
                .Where). This annotation allows inference of [InstantHandle] annotation for parameters
                of delegate type by analyzing LINQ method chains.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.NoEnumerationAttribute">
            <summary>
                Indicates that IEnumerable, passed as parameter, is not enumerated.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.RegexPatternAttribute">
            <summary>
                Indicates that parameter is regular expression pattern.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.NoReorderAttribute">
            <summary>
                Prevents the Member Reordering feature from tossing members of the marked class.
            </summary>
            <remarks>
                The attribute must be mentioned in your member reordering patterns
            </remarks>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.XamlItemsControlAttribute">
            <summary>
                XAML attribute. Indicates the type that has <c>ItemsSource</c> property and should be treated
                as <c>ItemsControl</c>-derived type, to enable inner items <c>DataContext</c> type resolve.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.XamlItemBindingOfItemsControlAttribute">
            <summary>
                XAML attribute. Indicates the property of some <c>BindingBase</c>-derived type, that
                is used to bind some item of <c>ItemsControl</c>-derived type. This annotation will
                enable the <c>DataContext</c> type resolve for XAML bindings for such properties.
            </summary>
            <remarks>
                Property should have the tree ancestor of the <c>ItemsControl</c> type or
                marked with the <see cref="T:Microsoft.ProgramSynthesis.Utils.JetBrains.Annotations.XamlItemsControlAttribute" /> attribute.
            </remarks>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.KnownTypesJsonConverter">
             <summary>
                 This is used for serializing and deserializing objects while preserving polymorphic types from a known list.
             </summary>
             <remarks>
                 Ideally, we would create an implementation of ISerializationBinder for this purpose and set it onto the
                 JsonSerializerSettings since that mechanism is designed exactly for this purpose.  At the time we originally
                 created this class, however, Newtonsoft Json did not yet have ISerializationBinder, so we had to go with
                 this lower-level converter mechanism instead.  We have evaluated switching to ISerializationBinder now that
                 it is available, but doing so would change our serialization format since when using ISerializationBinder,
                 the type information is written to a property named "$type" instead of "$$type" (a decision we 
                 semi-arbitrarily made when first implementing this).  If we want to configure Newtonsoft Json to use our
                 preferred type name property, then we would be back to implementing a converter anyway.  So, we're leaving
                 the implementation as is even though that means we have to disable warning CA2330 which basically says we
                 should use ISerializationBinder.
            
                 The way our known types converter works is that we use JsonReader and JsonWriter to catch the process before
                 the regular converter gets going.  We then read/write the type information ourselves and delegate the rest
                 of the work to the regular serializer (which we create using the same settings as the outer serializer 
                 except that our converter has been removed).  
             </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.KnownTypesJsonConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.KnownTypesJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.KnownTypesJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.LastDistinctResultObservable">
            <summary>
                Helper class for constructing an <see cref="T:System.IObservable`1" /> which takes a sequence of computation and provides
                its <see cref="T:System.IObserver`1" />s with the result from the most recently completed computation, omitting repeats.
                The most recent result is always given to new observers, so they do not have to wait for a new result and they will
                get a result even if attached after all of the computations have completed.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Logging.IStopwatchWrapper">
            <summary>
                A wrapper for stopwatches which implements IDisposable. Meant to be used with using
                statements in order to time a block of code. Note that this is a hack to prevent
                constructing stopwatch wrappers by hand. 
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Logging.Logger">
            <summary>
                A utility class to assist in writing standard format logs out.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Logging.Logger.LogLevel">
            <summary>
                Definition of log levels is taken from NLog. Description of log types is also heavily
                influenced by NLog.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Logging.Logger.OutputLevel">
            <summary>
                The Log Level at which events will be written to the log. Anything above this level will
                also be written.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Logging.Logger.LogSourceInfo">
            <summary>
                Flag for whether source information will be logged.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.Logging.Logger.Instance">
            <summary>
               The default instance of <see cref="T:Microsoft.ProgramSynthesis.Utils.Logging.Logger"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.#ctor(System.Action{System.String},Microsoft.ProgramSynthesis.Utils.Logging.Logger.LogLevel,System.Boolean)">
            <summary>
               Construct a <see cref="T:Microsoft.ProgramSynthesis.Utils.Logging.Logger"/> with:
               1. The write log action provided by <paramref name="logWriter"/>
               2. Logging only messages with priority greater than the given <see cref="T:Microsoft.ProgramSynthesis.Utils.Logging.Logger.LogLevel"/>.
               3. Logging source info (source file and line number) only if <paramref name="logSourceInfo"/> is set.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.FileWriter(System.String)">
            <summary>
                Creates a LogWriter function. If it has permission to write to the path, the function writes to 
                the file found at the given path. If the path does not exist, the directory and file are created. 
                Otherwise, logs are appended to the existing file. If it does not have permission to write, returns 
                a function that does nothing.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Logging.Logger.LogWriter">
            <summary>
                A hook to specify how logs should be written.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.ShouldLog(Microsoft.ProgramSynthesis.Utils.Logging.Logger.LogLevel)">
            <summary>
            Determines if a log level should be written based on the output log level.
            </summary>
            <param name="logLevel"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.ShouldTrace">
            <summary>
            Determines if a trace log should be written based on the output log level.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.ShouldDebug">
            <summary>
            Determines if a debug log should be written based on the output log level.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.ShouldInfo">
            <summary>
            Determines if a info log should be written based on the output log level.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.ShouldWarn">
            <summary>
            Determines if a warn log should be written based on the output log level.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.ShouldError">
            <summary>
            Determines if a error log should be written based on the output log level.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.ShouldFatal">
            <summary>
            Determines if a fatal log should be written based on the output log level.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.Log(Microsoft.ProgramSynthesis.Utils.Logging.Logger.LogLevel,System.String,System.Object,System.String,System.Int32)">
            <summary>
            Outputs a log with <see cref="!:logLevel"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.Log(Microsoft.ProgramSynthesis.Utils.Logging.Logger.LogLevel,System.FormattableString,System.Object,System.String,System.Int32)">
            <summary>
            Outputs a log with <see cref="!:logLevel"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.Trace(System.String,System.Object,System.String,System.Int32)">
            <summary>
            Outputs a trace log. Trace logs are meant to include high volume information and
            should only be enabled during development.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.Trace(System.FormattableString,System.Object,System.String,System.Int32)">
            <summary>
            Outputs a trace log. Trace logs are meant to include high volume information and
            should only be enabled during development.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.Debug(System.String,System.Object,System.String,System.Int32)">
            <summary>
            Outputs a debug log. Debug information should happen less frequently than trace, but
            should typically not be enabled in production environments.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.Debug(System.FormattableString,System.Object,System.String,System.Int32)">
            <summary>
            Outputs a debug log. Debug information should happen less frequently than trace, but
            should typically not be enabled in production environments.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.Info(System.String,System.Object,System.String,System.Int32)">
            <summary>
            Outputs an info log. Information messages are typically enabled in production
            environments.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.Info(System.FormattableString,System.Object,System.String,System.Int32)">
            <summary>
            Outputs an info log. Information messages are typically enabled in production
            environments.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.Warn(System.String,System.Object,System.String,System.Int32)">
            <summary>
            Outputs a warn log. Warn messages are typically for non-critical issues, which can be
            recovered on temporary failures.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.Warn(System.FormattableString,System.Object,System.String,System.Int32)">
            <summary>
            Outputs a warn log. Warn messages are typically for non-critical issues, which can be
            recovered on temporary failures.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.Error(System.String,System.Object,System.String,System.Int32)">
            <summary>
            Outputs an error log. Error messages are usually output from exceptions.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.Error(System.FormattableString,System.Object,System.String,System.Int32)">
            <summary>
            Outputs an error log. Error messages are usually output from exceptions.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.Fatal(System.String,System.Object,System.String,System.Int32)">
            <summary>
            Outputs a fatal log. These are errors which require burning everything down and starting
            over. These should be used sparingly.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.Fatal(System.FormattableString,System.Object,System.String,System.Int32)">
            <summary>
            Outputs a fatal log. These are errors which require burning everything down and starting
            over. These should be used sparingly.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.LogTiming(Microsoft.ProgramSynthesis.Utils.Logging.Logger.LogLevel,System.String,System.String,System.Int32)">
            <summary>
            Outputs the timing of the lifetime of the StopwatchWrapper as a log.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.LogTiming(Microsoft.ProgramSynthesis.Utils.Logging.Logger.LogLevel,System.FormattableString,System.String,System.Int32)">
            <summary>
            Outputs the timing of the lifetime of the StopwatchWrapper as a log.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.TraceTiming(System.String,System.String,System.Int32)">
            <summary>
            Outputs timing of the lifetime of the StopwatchWrapper as a trace log. Trace logs are
            meant to include high volume information and should only be enabled during development.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.TraceTiming(System.FormattableString,System.String,System.Int32)">
            <summary>
            Outputs timing of the lifetime of the StopwatchWrapper as a trace log. Trace logs are
            meant to include high volume information and should only be enabled during development.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.DebugTiming(System.String,System.String,System.Int32)">
            <summary>
            Outputs timing of the lifetime of the StopwatchWrapper as a trace log. Debug information
            should happen less frequently than trace, but should typically not be enabled in
            production environments.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.DebugTiming(System.FormattableString,System.String,System.Int32)">
            <summary>
            Outputs timing of the lifetime of the StopwatchWrapper as a trace log. Debug information
            should happen less frequently than trace, but should typically not be enabled in
            production environments.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.InfoTiming(System.String,System.String,System.Int32)">
            <summary>
            Outputs timing of the lifetime of the StopwatchWrapper as an info log. Information
            messages are typically enabled in production environments.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Logging.Logger.InfoTiming(System.FormattableString,System.String,System.Int32)">
            <summary>
            Outputs timing of the lifetime of the StopwatchWrapper as an info log. Information
            messages are typically enabled in production environments.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.MathUtils.LogGamma(System.Double)">
            <summary>
                Logarithm of the Gamma function, approximated using Stirling's formula
                https://en.wikipedia.org/wiki/Gamma_function
                https://en.wikipedia.org/wiki/Stirling%27s_approximation
            </summary>
            <param name="x"></param>
            <returns>approximation to log (Gamma (x))</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.MathUtils.LogSumExp(System.Double,System.Double)">
            <summary>
                Log-Sum-Exp: LogSumExp(x,y) = log(e^x + e^y)
                Correctly handles numeric underflow/overflow
                https://en.wikipedia.org/wiki/LogSumExp
            </summary>
            <param name="x">a number</param>
            <param name="y">a number</param>
            <returns>A soft maximum of the two numbers</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.MathUtils.NormalizeDictionary``1(System.Collections.Generic.IReadOnlyDictionary{``0,System.Double})">
            <summary>
                Takes a dictionary representing an unnormalized probability distrubution,
                and gives you a new dictionary that has the same distrubution but normalized.
            </summary>
            <param name="dict">The map from objects to log probabilities</param>
            <typeparam name="T">The type of each object</typeparam>
            <returns>A now normalized dictionary</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.MathUtils.OrderDependentHashCode``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
                Computes an order dependent hash of a sequence of values.
            </summary>
            <typeparam name="T">The type of the values in the sequence.</typeparam>
            <param name="collection">The sequence.</param>
            <param name="comparer">The comparer.</param>
            <returns>An order dependent hash of the values in the sequence.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.MathUtils.OrderDependentHashCode(System.Collections.IEnumerable,System.Collections.IEqualityComparer)">
            <summary>
                Computes an order dependent hash of a sequence of values.
            </summary>
            <param name="collection">The sequence.</param>
            <param name="comparer">The comparer.</param>
            <returns>An order dependent hash of the values in the sequence.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.MathUtils.Normalize(System.Decimal)">
            <summary>
                Removes trailing zeros from decimal numbers.
            </summary>
            <param name="d">Number to normalize.</param>
            <returns><paramref name="d"/> normalized so it has no trailing zeros.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.MathUtils.StandardDeviation(System.Collections.Generic.IEnumerable{System.Double},System.Nullable{System.Double})">
            <summary>
                Returns the standard deviation of a collection of values.
            </summary>
            <param name="values">The values whose standard deviation is to be calculated.</param>
            <param name="mean">The average of the values. Optional, if provided, avoids an additional pass over the collection.</param>
            <returns>The standard deviation of the collection of values given by <paramref name="values" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.MathUtils.StandardDeviation(System.Collections.Generic.IEnumerable{System.Int64},System.Nullable{System.Double})">
            <summary>
                Returns the standard deviation of a collection of values.
            </summary>
            <param name="values">The values whose standard deviation is to be calculated.</param>
            <param name="mean">The average of the values. Optional, if provided, avoids an additional pass over the collection.</param>
            <returns>The standard deviation of the collection of values given by <paramref name="values" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.MathUtils.StandardDeviation(System.Collections.Generic.IEnumerable{System.Int32},System.Nullable{System.Double})">
            <summary>
                Returns the standard deviation of a collection of values.
            </summary>
            <param name="values">The values whose standard deviation is to be calculated.</param>
            <param name="mean">The average of the values. Optional, if provided, avoids an additional pass over the collection.</param>
            <returns>The standard deviation of the collection of values given by <paramref name="values" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.MathUtils.ProportionTrue``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
                Returns the proportion [0-1] of elements of <paramref name="xs" /> for which <paramref name="predicate" /> is true.
            </summary>
            <typeparam name="T">Type of elements.</typeparam>
            <param name="xs">Collection to compute proportion over.</param>
            <param name="predicate">Predicate to check elements of <paramref name="xs" /> against.</param>
            <returns><c>xs.Count(predicate)/xs.Count()</c> but only enumerating <paramref name="xs" /> once.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.MathUtils.Median(System.Collections.Generic.IReadOnlyList{System.Int32})">
            <summary>
                Returns the median of a collection of values.
            </summary>
            <param name="values">The values whose median is to be calculated.</param>
            <returns>
                The value with an equal number of values greater or less than it in the collections or the mean of the two
                such values if the list length is even or <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if <paramref name="values" />
                is empty.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.MathUtils.GetBits(System.UInt16,System.Int32)">
            <summary>
                Returns <paramref name="mask"/> represented as an array of bits (lowest first).
            </summary>
            <param name="mask">The bitmask to convert.</param>
            <param name="length">Length of the returned array. Defaults to the maximum number of possible bits in <paramref name="mask"/>.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.MathUtils.CountBits(System.UInt32)">
            <summary>
                Count the number of 1 bits in a <see cref="T:System.UInt32"/>.
            </summary>
            <param name="i">The 32-bit bit string.</param>
            <returns>The number of bits in <paramref name="i"/> that are set (0-32).</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.MathUtils.WithinTolerance(System.Double,System.Double,System.Double)">
            <summary>
                Returns a boolean indicating if the <paramref name="other"/> is in the range:
                [<paramref name="center"/> - <paramref name="tolerance"/>, <paramref name="center"/> + <paramref name="tolerance"/>].
            </summary>
            <param name="center">The center of the range.</param>
            <param name="other">The value in question.</param>
            <param name="tolerance">The radius of the range.</param>
            <returns>Boolean indicating whether other is within the range.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.MathUtils.WithinTolerance(System.Int32,System.Int32,System.Int32)">
            <summary>
                Returns a boolean indicating if the <paramref name="other"/> is in the range:
                [<paramref name="center"/> - <paramref name="tolerance"/>, <paramref name="center"/> + <paramref name="tolerance"/>].
            </summary>
            <param name="center">The center of the range.</param>
            <param name="other">The value in question.</param>
            <param name="tolerance">The radius of the range.</param>
            <returns>Boolean indicating whether other is within the range.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.MathUtils.UpdateAverage(System.Double,System.Int32,System.Double)">
            <summary>
                Returns an updated average by adding the contribution of the next element.
            </summary>
            <param name="previousAverage">The average before the new element.</param>
            <param name="count">The count including the new element.</param>
            <param name="newValue">The value of the new element.</param>
            <returns>The new average including the newValue.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.MethodUtils.ToDelegateWithParams``1(System.Reflection.MethodInfo,System.Boolean)">
            <summary>
            Creates a fast typed delegate from a runtime method information. The delegate is assumed to be of a kind
            Func&lt;T1, T2, ..., Tk, object[], object&gt;. In other words, the delegate takes several first parameters
            directly, and the rest via the residual object[] array (usually specified as a variable-length parameter on
            the calling side). The technique is explained at
            <see cref="!:https://codeblog.jonskeet.uk/2008/08/09/making-reflection-fly-and-exploring-delegates/"/>.
            </summary>
            <typeparam name="TDelegate">A delegate of a kind Func&lt;T1, T2, ..., Tk, object[], object&gt;</typeparam>
            <param name="method">MethodInfo of an external method to convert. Must be static and consistent with TDelegate.</param>
            <param name="instance">True if <typeparamref name="TDelegate"/> wraps an instance method, taking a target object as an explicit first parameter; false otherwise.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.MultisetUtils">
            <summary>
                Extension methods for treating I[ReadOnly]Dictionary&lt;TKey, int&gt; as a multiset:
                an unordered collection like a set except the number of instances of each element matters.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.MultisetUtils.GetAndIncrement``1(System.Collections.Generic.IDictionary{``0,System.Int32},``0)">
            <summary>
                Increments the value at the given <paramref name="key" /> in <paramref name="dict" />.
                If <paramref name="key" /> does not already exist in <paramref name="dict" />
                it is added and the (counter) value is set to <c>1</c>.
            </summary>
            <typeparam name="TKey">Type of keys in the counter dictionary.</typeparam>
            <param name="dict">The counter dictionary.</param>
            <param name="key">The key to increment.</param>
            <returns>The new value after the increment.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.MultisetUtils.ToMultiset``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Convert a sequence to a multi-set.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="seq">Sequence of elements.</param>
            <returns>A dictionary mapping elements to their multiplicites.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.MultisetUtils.MultisetUnion``1(System.Collections.Generic.IReadOnlyDictionary{``0,System.Int32},System.Collections.Generic.IReadOnlyDictionary{``0,System.Int32},System.Collections.Generic.EqualityComparer{``0})">
            <summary>
                Unions two multisets in the form of dictionaries. The value of a key in the output is the
                sum of its values in the two inputs.
            </summary>
            <typeparam name="T">Type of the element in the set.</typeparam>
            <param name="thisOne">Left multi-set.</param>
            <param name="thatOne">Right multi-set.</param>
            <param name="keyComparer">The comparer for key equality.</param>
            <returns>
                A multiset that represents the union of the two inputs.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.MultisetUtils.MultisetUnionWith``1(System.Collections.Generic.Dictionary{``0,System.Int32},System.Collections.Generic.IReadOnlyDictionary{``0,System.Int32})">
            <summary>
                Unions two multisets in the form of dictionaries. The value of a key in the first input is set 
                to the sum of its values in the two inputs.
            </summary>
            <typeparam name="T">Type of the element in the set.</typeparam>
            <param name="thisOne">Left multi-set.</param>
            <param name="thatOne">Right multi-set.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.MultisetUtils.MultisetDifference``1(System.Collections.Generic.IReadOnlyDictionary{``0,System.Int32},System.Collections.Generic.IReadOnlyDictionary{``0,System.Int32})">
            <summary>
                Difference of two multisets in the form of dictionaries. The value of a key in the output is the
                difference of its values in the two inputs, or zero if the difference is negative.
            </summary>
            <typeparam name="T">Type of the element in the set.</typeparam>
            <param name="thisOne">Left multi-set.</param>
            <param name="thatOne">Right multi-set.</param>
            <returns>
                A multiset that represents the difference of the two inputs.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.MultisetUtils.MultisetDifferenceIsNonEmpty``1(System.Collections.Generic.IReadOnlyDictionary{``0,System.Int32},System.Collections.Generic.IReadOnlyDictionary{``0,System.Int32})">
            <summary>
                Checks if the difference of two multisets is non-empty.
            </summary>
            <typeparam name="T">Type of the element in the set.</typeparam>
            <param name="thisOne">Left multi-set.</param>
            <param name="thatOne">Right multi-set.</param>
            <returns>
                True if the left multiset contains any elements not also in the right multiset.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.MultisetUtils.MultisetSymmetricDifference``1(System.Collections.Generic.IReadOnlyDictionary{``0,System.Int32},System.Collections.Generic.IReadOnlyDictionary{``0,System.Int32})">
            <summary>
                Symmetric distance of two multisets in the form of
                dictionaries. The value of a key in the output is the
                absolute difference of its values in the two inputs.
            </summary>
            <typeparam name="T">Type of the element in the set.</typeparam>
            <param name="thisOne">Left multi-set.</param>
            <param name="thatOne">Right multi-set.</param>
            <returns>
                A multiset that represents the difference of the two inputs.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.MultisetUtils.MultisetSignedDifference``1(System.Collections.Generic.IReadOnlyDictionary{``0,System.Int32},System.Collections.Generic.IReadOnlyDictionary{``0,System.Int32},System.Collections.Generic.EqualityComparer{``0})">
            <summary>
                Differences two multisets in the form of dictionaries. The value of a key in the output is the
                difference of its values from the Left and Right multiset.
            </summary>
            <typeparam name="T">Type of the element in the set.</typeparam>
            <param name="thisOne">Left multi-set.</param>
            <param name="thatOne">Right multi-set.</param>
            <param name="keyComparer">The comparer for key equality.</param>
            <returns>
                A multiset that represents the difference of the two inputs with negatives possible.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.NamespaceDoc">
            <summary>
                A collection of utility classes and functions used across all of Microsoft.ProgramSynthesis.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.CollectionAction">
            <summary>
                An enumeration describing the kind of action that the collection is notifying about.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.CollectionAction.PreAdd">
            <summary>
                Elements are about to be added into the collection.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.CollectionAction.Add">
            <summary>
                Elements have been added into the collection.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.CollectionAction.Remove">
            <summary>
                Elements have been removed from the collection.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.CollectionAction.Replace">
            <summary>
                Elements have been replaced in the collection.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.CollectionAction.Move">
            <summary>
                Elements have been moved in the collection.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.CollectionAction.Reset">
            <summary>
                The collection has been reset to empty.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.CollectionEvent`1">
            <inheritdoc />
            <summary>
                Information for notifying events on a generic collection.
            </summary>
            <typeparam name="T">Type of the elements of the collection this works on.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.CollectionEvent`1.#ctor(Microsoft.ProgramSynthesis.Utils.CollectionAction,System.Collections.Generic.IReadOnlyList{`0})">
            <inheritdoc />
            <summary>
                Constructor for a <see cref="T:Microsoft.ProgramSynthesis.Utils.CollectionEvent`1" />.
            </summary>
            <param name="action">What kind of event occurred on the collection.</param>
            <param name="changedItems">Which items were changed.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.CollectionEvent`1.Action">
            <summary>
                What kind of change was made.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.CollectionEvent`1.ChangedItems">
            <summary>
                Which items in the collection were changed, or <c>null</c> if not applicable to this <see cref="P:Microsoft.ProgramSynthesis.Utils.CollectionEvent`1.Action" />.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.NotifyingCollection`1">
             <inheritdoc />
             <summary>
                 A collection that notifies changes to external observers.
                 The behaviour is different from <see cref="T:System.Collections.ObjectModel.ObservableCollection`1" /> in
                 that the PreAdd notification goes out before the elements are actually added into the collection.
                 Therefore, the PreAdd notification handler can throw an exception to prevent the elements from being
                 added to the collection.
            
                 Note that the NotifyingCollection behaves like a list, i.e., it allows duplicates and retains
                 the order in which elements were added.
             </summary>
             <typeparam name="T"></typeparam>
        </member>
        <member name="E:Microsoft.ProgramSynthesis.Utils.NotifyingCollection`1.Changed">
            <summary>
                Event handler that is called when the collection changes.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.NotifyingCollection`1._backingStore">
            <summary>
                The backing collection for this collection.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.NotifyingCollection`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.NotifyingCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.NotifyingCollection`1.Add(System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Add items to the collection, sending out the <see cref="F:Microsoft.ProgramSynthesis.Utils.CollectionAction.PreAdd" />
                and <see cref="F:Microsoft.ProgramSynthesis.Utils.CollectionAction.Add" /> notifications respectively.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.NotifyingCollection`1.Add(`0)">
            <inheritdoc cref="M:Microsoft.ProgramSynthesis.Utils.NotifyingCollection`1.Add(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.NotifyingCollection`1.Add(`0,`0[])">
            <inheritdoc cref="M:Microsoft.ProgramSynthesis.Utils.NotifyingCollection`1.Add(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.NotifyingCollection`1.Clear">
            <inheritdoc />
            <summary>
                Remove all items from the collection, sending out the <see cref="F:Microsoft.ProgramSynthesis.Utils.CollectionAction.Reset" />
                notification.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.NotifyingCollection`1.Remove(System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Remove items from the collection, sending out the <see cref="F:Microsoft.ProgramSynthesis.Utils.CollectionAction.Remove" />
                notifications.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.NotifyingCollection`1.AsImmutable">
            <summary>
                Get a snapshot of the current state of the collection.
            </summary>
            <returns>Immutable list of the current items in the collection.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.NotifyingCollection`1.Remove(`0[])">
            <inheritdoc cref="M:Microsoft.ProgramSynthesis.Utils.NotifyingCollection`1.Remove(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.NotifyingCollection`1.Remove(`0)">
            <inheritdoc cref="M:Microsoft.ProgramSynthesis.Utils.NotifyingCollection`1.Remove(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.NotifyingCollection`1.Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.NotifyingCollection`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.NotifyingCollection`1.Count">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.NotifyingCollection`1.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.Optimization">
            <summary>
                Local search procedures for finding a (possibly local) maximizer of a function.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Optimization.HillClimb(System.Func{System.Double[],System.Double},System.Double[],System.Int32,System.Double)">
            <summary>
                Maximizes a function using hill climbing (https://en.wikipedia.org/wiki/Hill_climbing).
            </summary>
            <param name="f">The function to maximize.</param>
            <param name="x0">Initial point to start hill climbing.</param>
            <param name="steps">An upper bound on the number of steps to hill climb.</param>
            <param name="stepSize">The amount to try moving along each axis during an iteration of hill climbing.</param>
            <returns>Argmax discovered by the search.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Optimization.GradientAscent(System.Func{System.Double[],Microsoft.ProgramSynthesis.Utils.Record{System.Double,System.Double[]}},System.Double[],System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
                Maximizes a function using gradient ascent (https://en.wikipedia.org/wiki/Gradient_descent).
            </summary>
            <param name="objectiveAndGradient">
                A map from a point in the parameter space to a record of the objective function and
                the gradient.
            </param>
            <param name="steps">The number of steps to run the optimizer.</param>
            <param name="x0">The initial input to start the search.</param>
            <param name="learningRate">The learning rate, or stepsize, for the optimizer.</param>
            <param name="decayRate">Rate of decay for the learning rate. If this is 1 then the learning rate will not decay. Should be in the range (0,1].</param>
            <param name="verbose">If this is true then we print out the parameters and objective function found at each iteration.</param>
            <returns>Argmax discovered by the search.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Optimization.Adagrad(System.Func{System.Double[],Microsoft.ProgramSynthesis.Utils.Record{System.Double,System.Double[]}},System.Double[],System.Int32,System.Double,System.Double,System.Boolean,System.Double)">
            <summary>
                Maximizes a function using adagrad (https://en.wikipedia.org/wiki/Stochastic_gradient_descent#AdaGrad).
            </summary>
            <param name="objectiveAndGradient">
                A map from a point in the parameter space to a record of the objective function and
                the gradient.
            </param>
            <param name="steps">The number of steps to run the optimizer.</param>
            <param name="x0">The initial input to start the search.</param>
            <param name="learningRate">
                The initial learning rate, or stepsize, for the optimizer, prior to gradient
                adaptation.
            </param>
            <param name="decayRate">Rate of decay for the learning rate. If this is 1 then the learning rate will not decay.  Should be in the range (0,1].</param>
            <param name="verbose">If this is true then we print out the parameters and objective function found at each iteration.</param>
            <param name="epsilon">
                Very small value added to accumulated gradients to prevent division by zero; the square of
                epsilon should be smaller than typical values of the gradient.
            </param>
            <returns>Argmax discovered by the search.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Optimization.Adam(System.Func{System.Double[],Microsoft.ProgramSynthesis.Utils.Record{System.Double,System.Double[]}},System.Double[],System.Int32,System.Double,System.Boolean,System.Double)">
            <summary>
                Maximizes a function using Adam (http://arxiv.org/pdf/1412.6980v8.pdf)
            </summary>
            <param name="objectiveAndGradient">
                A map from a point in the parameter space to a record of the objective function and
                the gradient.
            </param>
            <param name="steps">The number of steps to run the optimizer.</param>
            <param name="x0">The initial input to start the search.</param>
            <param name="learningRate">
                The learning rate, or stepsize, for the optimizer, prior to gradient
                adaptation.
            </param>
            <param name="verbose">If this is true then we print out the parameters and objective function found at each iteration.</param>
            <param name="epsilon">
                Very small value added to accumulated gradients to prevent division by zero; the square of
                epsilon should be smaller than typical values of the gradient.
            </param>
            <returns>Argmax discovered by the search.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Optimization.RMSProp(System.Func{System.Double[],Microsoft.ProgramSynthesis.Utils.Record{System.Double,System.Double[]}},System.Double[],System.Int32,System.Double,System.Double,System.Boolean,System.Double)">
            <summary>
                Maximizes a function using RMSProp (http://sebastianruder.com/optimizing-gradient-descent/index.html#rmsprop).
            </summary>
            <param name="objectiveAndGradient">
                A map from a point in the parameter space to a record of the objective function and
                the gradient.
            </param>
            <param name="steps">The number of steps to run the optimizer.</param>
            <param name="x0">The initial input to start the search.</param>
            <param name="learningRate">
                The learning rate, or stepsize, for the optimizer, prior to gradient
                adaptation.
            </param>
            <param name="decayRate">Rate of decay for the learning rate. If this is 1 then the learning rate will not decay. Should be in the range (0,1].</param>
            <param name="verbose">If this is true then we print out the parameters and objective function found at each iteration.</param>
            <param name="epsilon">
                Very small value added to accumulated gradients to prevent division by zero; the square of
                epsilon should be smaller than typical values of the gradient.
            </param>
            <returns>Argmax discovered by the search.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.OptionalUtils.MaybeElementAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
                <see cref="M:System.Linq.Enumerable.ElementAtOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" /> reimplemented to return an <see cref="T:Microsoft.ProgramSynthesis.Utils.Optional`1" /> which
                may be easier to work with in some cases, especially where the element returned may be <c>default</c>.
            </summary>
            <typeparam name="T">Type of elements.</typeparam>
            <param name="items">Collection to index.</param>
            <param name="k">Index into <paramref name="items" />.</param>
            <returns>
                The element at index <paramref name="k" /> of <paramref name="items" /> if possible or
                <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.ProcessUtils.RunProcess(System.String,System.String,System.String@,System.String@,System.String,System.Int32)">
            <summary>
                Runs a process with <paramref name="fileName" /> with arguments <paramref name="arguments" /> and
                current working directory set to <paramref name="cwd" />. Along with exit code, it returns
                output and error data of process.
                Note: Since this collects output and error in a static variables, this method is not thread-safe and shouldn't be
                used simultaneously on different threads.
                Timeout by default is -1 (wait infinitely) or some valid no. of seconds for which process should wait to exit.
            </summary>
            <param name="fileName">File to execute</param>
            <param name="arguments">Arguments to the process</param>
            <param name="output">Standard output from process</param>
            <param name="error">Standard error from process</param>
            <param name="cwd">Current working directory for process to execute</param>
            <param name="timeoutInSeconds">Time in seconds to wait before it will be terminated</param>
            <returns>
                Exit code from process if it terminated within the timeout.  Will always contain a value if no timeout
                is specified.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.ProcessUtils.RunProcess(System.String,System.String,System.Diagnostics.DataReceivedEventHandler,System.Diagnostics.DataReceivedEventHandler,System.String,System.Int32)">
            <summary>
                Runs a process with <paramref name="fileName" /> with arguments <paramref name="arguments" /> and
                current working directory set to <paramref name="cwd" />. It also takes <see cref="T:System.Diagnostics.DataReceivedEventHandler" />
                to track output and error messages.
                Timeout by default is -1 (wait infinitely) or some valid no. of seconds for which process should wait to exit.
            </summary>
            <param name="fileName">File to execute</param>
            <param name="arguments">Arguments to the process</param>
            <param name="outputHandler">Delegate to handle standard output from process</param>
            <param name="errorHandler">Delegate to handle standard error from process</param>
            <param name="cwd">Current working directory for process to execute</param>
            <param name="timeoutInSeconds">Time in seconds to wait before it will be terminated</param>
            <returns>
                Exit code from process if it terminated within the timeout.  Will always contain a value if no timeout
                is specified.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RandomUtils.Next(System.Random,System.Numerics.BigInteger)">
            <summary>
            Returns a non-negative random BigInteger that is less than the specified maximum.
            </summary>
            <param name="random">underlying random value generator</param>
            <param name="maxValue">a positive BigInteger value</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RandomUtils.NewRandom">
            <summary>
            Creates a new instance of Random. The seed is derived from a global instance of Random, rather than time.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.RandomUtils.ThreadLocalRandom">
            <summary>
            Returns an instance of Random which can be used freely within the current thread.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RandomUtils.Next``1(System.Random,System.Collections.Generic.ICollection{``0})">
            <summary>
                Returns a random element of <paramref name="xs" />.
            </summary>
            <typeparam name="T">The type of <paramref name="xs" />.</typeparam>
            <param name="random">The <see cref="T:System.Random" /> object.</param>
            <param name="xs">The list to get the element from.</param>
            <returns>The random element.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.RectangularArray`1">
            <summary>
                A rectangular array implemented using a jagged array for performance reasons.
            </summary>
            <typeparam name="T">Type of elements of the array.</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.RectangularArray`1.Width">
            <summary>
                Size of the array in the first dimension.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.RectangularArray`1.Height">
            <summary>
                Size of the array in the second dimension.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.RectangularArray`1.Span">
            <summary>
                Span valid indexes into this array.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Utils.RectangularArray`1._array">
            <summary>
                The actual backing array.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RectangularArray`1.#ctor(System.Int32,System.Int32)">
            <summary>
                Constructs a <see cref="T:Microsoft.ProgramSynthesis.Utils.RectangularArray`1" /> of the given size where all elements are <c>default</c>.
            </summary>
            <param name="width">Size in the first dimension.</param>
            <param name="height">Size in the second dimension.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RectangularArray`1.#ctor(Microsoft.ProgramSynthesis.Utils.Geometry.Vector{Microsoft.ProgramSynthesis.Utils.Geometry.TableUnit})">
            <summary>
                Constructs a <see cref="T:Microsoft.ProgramSynthesis.Utils.RectangularArray`1" /> of the given size where all elements are <c>default</c>.
            </summary>
            <param name="size">
                Size in both dimensions. Note that because the array is 0-indexed,
                <c>new RectangularArray(size)[size]</c> is out-of-bounds of the array.
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RectangularArray`1.#ctor(`0[0:,0:])">
            <summary>
                Convert a .NET native two-dimensional array to a <see cref="T:Microsoft.ProgramSynthesis.Utils.RectangularArray`1" />.
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RectangularArray`1.ToEnumerable">
            <summary>
                Functionally equivalent to Cast().Collect() but with less boxing.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RectangularArray`1.Section(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                Pulls a section out of a two dimensional array.
            </summary>
            <param name="minX">The minimum x bound of the sub table inclusive</param>
            <param name="minY">The minimum y bound of the sub table inclusive</param>
            <param name="maxX">The maximum x bound of the sub table exclusive</param>
            <param name="maxY">The maximum y bound of the sub table exclusive</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RectangularArray`1.Section(Microsoft.ProgramSynthesis.Utils.Geometry.Bounds{Microsoft.ProgramSynthesis.Utils.Geometry.TableUnit})">
            <summary>
                Pulls a section out of a two dimensional array.
            </summary>
            <param name="bounds">The bounds of the sub table, inclusive on all sides.</param>
            <returns>The subtable of this array.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RectangularArray`1.StructuralEqual(Microsoft.ProgramSynthesis.Utils.RectangularArray{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
                Two dimensional equivalent of sequence equal except ensures that
                the two tables are the same size.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.RegexUtils.NonCachingMatches(System.Text.RegularExpressions.Regex,System.String)">
            <summary>
                Returns the list of all <see cref="T:System.Text.RegularExpressions.Match" />(es) of <paramref name="regex" /> in <paramref name="s" />.
                Unlike Regex.Matches(Content) that creates many cache objects, this method does all the bookkeeping to
                avoid creating these cache objects.
            </summary>
            <param name="regex">The matching <see cref="T:System.Text.RegularExpressions.Regex" />.</param>
            <param name="s">The string to match against.</param>
            <returns>The list of all matches.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.ResolvedType">
            <summary>
                Represents a resolved type in a grammar.  A resolved type is a <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.ResolvedType.#ctor(System.Type)">
            <summary>
                Constructs a resolved type from a <see cref="T:System.Type"/>.
            </summary>
            <param name="type">The resolved type.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.ResolvedType.IsStatic">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.ResolvedType.Location">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.ResolvedType.Name">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.ResolvedType.GetMethod(System.String,System.Reflection.BindingFlags,System.Type[])">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.ResolvedType.GetMethods(System.Reflection.BindingFlags)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.ResolvedType.GetMember(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.ResolvedType.CsName">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.ResolvedType.Type">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.ResolvedType.ToString">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.ResolvedType.Equals(Microsoft.ProgramSynthesis.Utils.ResolvedType)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.ResolvedType.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.ResolvedType.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.ReverseComparer`1">
            <summary>
            An implementation of IComparer which takes an instance of a comparer reverses the order
            Taken from https://stackoverflow.com/questions/13323267/sorteddictionary-in-reverse-order-of-keys/13323288#13323288
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.SelectFromAlternatives">
            <summary>
                A static class that implements the function to pick a correct program from alternatives.
                Alternatives are generated using a user-provided function that maps ProgramNode to a collection
                of alternative ProgramNodes, and the homomorphic lifting of this function.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.SelectFromAlternatives.SelectAlternative``3(``0,Microsoft.ProgramSynthesis.Wrangling.IProgramLoader{``0,``1,``2},System.Func{Microsoft.ProgramSynthesis.AST.ProgramNode,System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.AST.ProgramNode}},System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{``1,``2}},System.Collections.Generic.IEnumerable{``1})">
            <summary>
                Generate alternative programs (nodes) for the given <paramref name="program" />
                and return the one that works.
            </summary>
            <param name="program"> The program to simplify.</param>
            <param name="loader"> A program loader used to create a program from a program node.</param>
            <param name="getAlternatives"> The function that generates variants of the given program node.</param>
            <param name="constraints"> The constraints that should continue to remain valid.</param>
            <param name="additionalInputs"> The inputs on which the transformed program should work as before.</param>
            <returns>
                The new alternative program, generated by applying <paramref name="getAlternatives" /> on
                <paramref name="program" />, which preserves behavior on all the
                <paramref name="additionalInputs" /> and validates all <paramref name="constraints" />.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.StopwatchUtils">
            <summary>
                Utility functions for working with <see cref="T:System.Diagnostics.Stopwatch" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.StopwatchUtils.ElapsedMillisecondsAsDouble(System.Diagnostics.Stopwatch)">
            <summary>
                Returns the elapsed time measured by a stopwatch as a double number of milliseconds (unlike the
                ElapsedMilliseconds property which returns a long rounded down to the nearest whole number).
            </summary>
            <param name="stopwatch">The <see cref="T:System.Diagnostics.Stopwatch" /> to measure.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.StringDiffUtils.StringDiff.ComputeStringDiff(System.String,System.String)">
            <summary>
            Calculates and returns a single point of difference between two strings
            </summary>
            <param name="str1"> Represents the first verion of the string </param>
            <param name="str2"> Represents the second version of the string </param>
            <returns> Returns the index of change with respect to str1 and the New Text that goes there.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.StringDiffUtils.StringDiff.ApplyStringDiff(System.String)">
            <summary>
             Given a string, returns a string after applying StringDiff to the string
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.StringDiffUtils.ApplyAllStringDiffs(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Utils.StringDiffUtils.StringDiff},System.String)">
            <summary>
             Given a string and a Batch of TextDiffs, returns a string after applying all of them at once on the string
            </summary>
            <param name="str"></param>
            <param name="textDiffs"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.StringUtils.Slice(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Int32)">
            <summary>
            Creates a "pythonic" slice of a string. See <see cref="!:http://stackoverflow.com/questions/509211/pythons-slice-notation"/>
            </summary>
            <param name="str">String to slice</param>
            <param name="start">Slice start, inclusive. Negative to count from the end of the string.</param>
            <param name="end">Slice end, exclusive. Negative to count from the end of the string.</param>
            <param name="step">Slice step. Positive for forward slicing direction, negative for backward.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.StringUtils.LongestCommonSubstrings(System.Collections.Generic.IEnumerable{System.String},System.Int32,System.Boolean,System.Int32)">
            <summary>
            Finds a set of longest common substrings in a set of strings
            </summary>
            <param name="strings">Input set of strings</param>
            <param name="minLength">Minimum length of the substring</param>
            <param name="splitLines">Split string beforehand on line boundaries?</param>
            <param name="maxLength">Maximum length of the substring</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.StringUtils.ReverseUnicodeString(System.String)">
            <summary>
                Reverses the string while being sensitive to Unicode characters.
                Example: "Les Misérables".Reverse() == "selbarésiM seL"
            </summary>
            <returns>The reversed string, which might contain Unicode characters.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.StringUtils.SubstringEquals(System.String,System.String,System.Int32)">
            <summary>
                Checks if the given substring of <paramref name="str" /> is equal to <paramref name="needle" />. This performs a
                <see cref="F:System.StringComparison.Ordinal" /> comparison. This is equivalent to
                <c>
                    <paramref name="str" />.Substring(<paramref name="start" />, <paramref name="needle" />.Length).Equals(
                    <paramref name="needle" />)
                </c>
                without actually allocating the substring or
                <c>
                    <paramref name="str" />.IndexOf(<paramref name="needle" />, <see cref="F:System.StringComparison.Ordinal" />) ==
                    <paramref name="start" />
                </c>
                without searching the entire string.
            </summary>
            <param name="str">Larger string to look in.</param>
            <param name="needle">String to look for.</param>
            <param name="start">Index into <paramref name="str" /> to look for <paramref name="needle" /> starting at.</param>
            <returns>
                <c>true</c> if <paramref name="needle" /> is contained in <paramref name="str" /> at exactly index
                <paramref name="start" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.StringUtils.AddSuffix(System.String,System.String)">
            <summary>
                Add a suffix to another <see cref="T:System.String"/>.
                Same as <c>str0 + str1</c> but allows <c>str0?.AddSuffix(str1)</c>.
            </summary>
            <param name="str0">The original string.</param>
            <param name="str1">The suffix to add to the original string.</param>
            <returns>The concatenation of <paramref name="str0"/> and <paramref name="str1"/>.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.StringUtils.AddPrefix(System.String,System.String)">
            <summary>
                Add a prefix to another <see cref="T:System.String"/>.
                Same as <c>str1 + str0</c> but allows <c>str0?.AddPrefix(str1)</c>.
            </summary>
            <param name="str0">The original string.</param>
            <param name="str1">The prefix to add to the original string.</param>
            <returns>The concatenation of <paramref name="str0"/> and <paramref name="str1"/>.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.StringUtils.SplitIntoLines(System.String)">
            <summary>
                Produces an IEnumerable which contains the lines from <see cref="!:str"/>.
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.StringUtils.MaybeLastChar(System.String)">
            <summary>
                Returns the last <see cref="T:System.Char" /> of the string or <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if the string is
                empty.
            </summary>
            <param name="str">The string.</param>
            <returns>The end of the substring.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.StringUtils.NormalizeNewlines(System.String)">
            <summary>
                Returns a string with all CR-LF replaced with LF.
            </summary>
            <param name="str">The string.</param>
            <returns>String with CRLF replaced with LF.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.StringUtils.AllIndexesOf(System.String,System.String,System.StringComparison)">
            <summary>
                Returns indices of all matches of <paramref name="substring" />.
            </summary>
            <param name="str">The string.</param>
            <param name="substring">The substring.</param>
            <returns>All matching indices.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.Text.TextTableBuilder.Rows">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Text.TextTableBuilder.InsertRow(System.Int32,Microsoft.ProgramSynthesis.Utils.Text.ITextRow)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.Text.TextTableBuilder.RemoveRow(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.TimeSpanUtils">
            <summary>
                Utility functions for working with <see cref="T:System.TimeSpan" />s.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.TimeSpanUtils.Multiply(System.TimeSpan,System.Double)">
            <summary>
                Scales a <see cref="T:System.TimeSpan" /> by a constant factor.
            </summary>
            <param name="timeSpan">The <see cref="T:System.TimeSpan" /> to scale.</param>
            <param name="multiplier">The scaling factor.</param>
            <returns>A <see cref="T:System.TimeSpan" /> that is <paramref name="timeSpan" /> scaled by <paramref name="multiplier" />.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.UnicodeUtils">
            <summary>
                A set of utility functions for dealing with unicode strings.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.UnicodeUtils.MatchedQuotedStringRegex">
            <summary>
                A <see cref="T:System.Text.RegularExpressions.Regex" /> that matches a matched quoted string. e.g. "ABC" or ``ABC'' or 'ABC' or `ABC`
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.UnicodeUtils.AnchoredMatchedQuotedStringRegex">
            <summary>
                A <see cref="T:System.Text.RegularExpressions.Regex" /> that matches a string that only consists of a quoted string.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.UnicodeUtils.ParenthesizedStringRegex">
            <summary>
                A <see cref="T:System.Text.RegularExpressions.Regex" /> that matches a parenthesized string.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.UnicodeUtils.AnchoredParenthesizedStringRegex">
            <summary>
                A <see cref="T:System.Text.RegularExpressions.Regex" /> that matches a parenthesized string exclusively.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.UnicodeUtils.MinusChars">
            <summary>
                A set of <see cref="T:System.Char" />s that are commonly used to represent the minus sign
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.UnicodeUtils.PlusChars">
            <summary>
                A set of <see cref="T:System.Char" />s that are commonly used to represent the plus sign
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.UnicodeUtils.SignChars">
            <summary>
                A set of <see cref="T:System.Char" />s that are commonly used to represent the plus or minus sign
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.UnicodeUtils.MinusRegex">
            <summary>
                A <see cref="T:System.Text.RegularExpressions.Regex" /> that matches characters commonly used as the minus sign.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.UnicodeUtils.AnchoredMinusRegex">
            <summary>
                A <see cref="T:System.Text.RegularExpressions.Regex" /> that matches characters commonly used as the minus sign, exclusively.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.UnicodeUtils.PlusRegex">
            <summary>
                A <see cref="T:System.Text.RegularExpressions.Regex" /> that matches characters commonly used as the plus sign.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.UnicodeUtils.AnchoredPlusRegex">
            <summary>
                A <see cref="T:System.Text.RegularExpressions.Regex" /> that matches characters commonly used as the plus sign, exclusively.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.UnicodeUtils.IsQuotedUnicodeString(System.String,System.String@,System.String@)">
            <summary>
                Checks if the string is a quoted unicode string. The quote strings are returned in <paramref name="leftQuote" />
                and <paramref name="rightQuote" />.
                If the string is not quoted then <paramref name="leftQuote" /> and <paramref name="rightQuote" /> are set to
                <see cref="F:System.String.Empty" />.
            </summary>
            <remarks><paramref name="str" /> is assumed to be normalized.</remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.UnicodeUtils.IsParenthesizedUnicodeString(System.String,System.String@,System.String@)">
            <summary>
                Checks if the string is a parenthesized unicode string. The strings corresponding to the opening and closing
                parenthesis are returned in the out parameters <paramref name="leftParenthesis" /> and
                <paramref name="rightParenthesis" /> respectively.
                If <paramref name="str" /> is not parenthesized then <paramref name="leftParenthesis" /> and
                <paramref name="rightParenthesis" /> are set
                to <see cref="F:System.String.Empty" />.
            </summary>
            <remarks><paramref name="str" /> is assumed to be normalized.</remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.UnicodeUtils.UnparenthesizeStringIfParenthesized(System.String)">
            <summary>
                Unparenthesized a string if it is parenthesized. Otherwise, returns <paramref name="str" /> unchanged.
            </summary>
            <remarks><paramref name="str" /> is assumed to be normalized.</remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.UnicodeUtils.UnparenthesizeStringIfParenthesized(System.String,System.String@,System.String@)">
            <summary>
                Unparenthesized a string if it is parenthesized. Otherwise, returns <paramref name="str" /> unchanged.The strings
                corresponding to the opening and closing parenthesis are returned in the out parameters
                <paramref name="leftParenthesis" /> and <paramref name="rightParenthesis" /> respectively. If
                <paramref name="str" /> is not parenthesized then <paramref name="leftParenthesis" /> and
                <paramref name="rightParenthesis" /> are set to <see cref="F:System.String.Empty" />.
            </summary>
            <remarks><paramref name="str" /> is assumed to be normalized.</remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.UnicodeUtils.UnquoteStringIfQuoted(System.String)">
            <summary>
                Unquotes a string if it is quoted. Otherwise, returns <paramref name="str" /> unchanged.
            </summary>
            <remarks><paramref name="str" /> is assumed to be normalized.</remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.UnicodeUtils.UnquoteStringIfQuoted(System.String,System.String@,System.String@)">
            <summary>
                Unquotes a quoted unicode string. The quote strings are returned in <paramref name="leftQuote" />
                and <paramref name="rightQuote" />.
                If the string is not quoted then <paramref name="leftQuote" /> and <paramref name="rightQuote" /> are set to
                <see cref="F:System.String.Empty" />, and <paramref name="str" /> is returned unchanged.
            </summary>
            <remarks><paramref name="str" /> is assumed to be normalized.</remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.UnicodeUtils.Normalize(System.String,System.Text.NormalizationForm)">
            <summary>
                Returns a copy of the string normalized according to <paramref name="normalizationForm" />.
                If non-unicode characters were encountered during normalization, then returns <c>null</c>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.UnicodeUtils.NormalizeAndTrim(System.String,System.Text.NormalizationForm)">
            <summary>
                Returns a copy of <paramref name="value" /> that has been normalized and trimmed.
                If non-unicode characters were encountered during normalization, then returns <c>null</c>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.UnitType">
            <summary>
                A unit type has a single value and is therefore useful for representing no meaningful value.
                In this way, it is similar to <see cref="T:System.Void"/> except that <see cref="T:Microsoft.ProgramSynthesis.Utils.UnitType"/>
                can be used as an argument to a generic class or method (for example, a visitor's return type).
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.UnitType.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.UnitType.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.UnitType.Equals(Microsoft.ProgramSynthesis.Utils.UnitType)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Utils.UnresolvedType">
            <summary>
                Represents an unresolved type in a grammar.  Unresolved types are only used when
                only compiling C# utilities from a grammar file.  An unresolve type is a name.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.UnresolvedType.#ctor(System.String)">
            <summary>
                Constructs an unresolved type from a name.
            </summary>
            <param name="name">The name of the unresolved type.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.UnresolvedType.CsName">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.UnresolvedType.Type">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Utils.UnresolvedType.Name">
            <summary>
               The name of the unresolved type.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.UnresolvedType.ToString">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.UnresolvedType.Equals(Microsoft.ProgramSynthesis.Utils.UnresolvedType)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.UnresolvedType.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.UnresolvedType.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.ValueEquality`1.Equals(`0,`0)">
            <summary>
                Determines whether the specified objects are equal.
            </summary>
            <returns>
                true if the specified objects are equal; otherwise, false.
            </returns>
            <param name="x">The first object of type <typeparamref name="T" /> to compare.</param>
            <param name="y">The second object of type <typeparamref name="T" /> to compare.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.ValueEquality`1.GetHashCode(`0)">
            <summary>
                Returns a hash code for the specified object.
            </summary>
            <returns>
                A hash code for the specified object.
            </returns>
            <param name="obj">The <see cref="T:System.Object" /> for which a hash code is to be returned.</param>
            <exception cref="T:System.ArgumentNullException">
                The type of <paramref name="obj" /> is a reference type and
                <paramref name="obj" /> is null.
            </exception>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Utils.XmlUtils.DeserializeFromXml``1(System.Xml.Linq.XElement)">
            <summary>
            Deserializes object <paramref name="serializedObject"/> of type <typeparamref name="T"/>. />
            </summary>
            <typeparam name="T"> Type of serialized object. </typeparam>
            <param name="serializedObject"> Serialized object. </param>
            <returns> Deserialized object. </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Program`2">
            <summary>
                A program in a DSL.
                This wraps a <see cref="P:Microsoft.ProgramSynthesis.Program`2.ProgramNode" /> with type information so it's more convenient to use.
            </summary>
            <typeparam name="TInput">The input type of the program.</typeparam>
            <typeparam name="TOutput">The output type of the program.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Program`2.#ctor(Microsoft.ProgramSynthesis.AST.ProgramNode,System.Double,System.Func{Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode})">
            <summary>
                Constructs a program wrapping <paramref name="programNode" /> with the score <paramref name="score" />.
            </summary>
            <param name="programNode">The program to wrap.</param>
            <param name="score">The ranking score of <paramref name="programNode" />.</param>
            <param name="programNormalizingFunc">
                Optional function to transform <paramref name="programNode" />. The pre-transform
                <paramref name="programNode" /> can be accessed via <see cref="P:Microsoft.ProgramSynthesis.Program`2.RawProgramNode" />.
            </param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Program`2.ProgramNode">
            <summary>
                The <see cref="P:Microsoft.ProgramSynthesis.Program`2.ProgramNode" /> object which contains the actual program.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Program`2.RawProgramNode">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Program`2.Score">
            <summary>
                The ranking score of the program (the higher the better).
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Program`2.Version">
            <summary>
                The version of the program.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Program`2.Equals(Microsoft.ProgramSynthesis.Program{`0,`1})">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Program`2.Equals(System.Object)">
            <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Program`2.GetHashCode">
            <summary>
                Serves as the default hash function.
            </summary>
            <returns>
                A hash code for the current object.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Program`2.ToString">
            <summary>
                Prints the internal program node in human-readable format.
            </summary>
            <returns>The serialized program.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Program`2.Serialize(Microsoft.ProgramSynthesis.AST.ASTSerializationFormat)">
            <summary>
                Serializes the program to a string.
            </summary>
            <param name="serializationFormat">The desired serialization format (XML or human-readable).</param>
            <returns>The serialized program.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Program`2.Serialize(Microsoft.ProgramSynthesis.AST.ASTSerializationSettings)">
            <summary>
                Serializes the program to a string.
            </summary>
            <param name="serializationSettings">The desired serialization settings (such as XML or human-readable).</param>
            <returns>The serialized program.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Program`2.SerializeAnonymized(Microsoft.ProgramSynthesis.AST.ASTSerializationFormat)">
            <summary>
                Serializes a subset of the program appropriate for data collection. The resulting string <b>must</b> not contain
                any PII (personally identifiable information). Implementations should omit any information that cannot be confirmed
                to not contain PII. By default this omits all literal values and includes only the AST structure and operator
                names.
            </summary>
            <param name="serializationFormat">The desired serialization format (XML or human-readable).</param>
            <returns>The serialized program without any information that might possibly be private like constant strings.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Program`2.SerializeAnonymized(Microsoft.ProgramSynthesis.AST.ASTSerializationSettings)">
            <summary>
                Serializes a subset of the program appropriate for data collection. The resulting string <b>must</b> not contain
                any PII (personally identifiable information). Implementations should omit any information that cannot be confirmed
                to not contain PII. By default this omits all literal values and includes only the AST structure and operator
                names.
            </summary>
            <param name="serializationSettings">The desired serialization settings (such as XML or human-readable).</param>
            <returns>The serialized program without any information that might possibly be private like constant strings.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Program`2.Describe(System.Globalization.CultureInfo)">
            <summary>
                Describes the functionality of the program at a high level.
                Returns null if program description is not available.
            </summary>
            <param name="cultureInfo">The culture info.</param>
            <returns>The program description (null if not available)</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Program`2.Microsoft#ProgramSynthesis#IProgram#Run(System.Object)">
            <summary>
                Executes the program on the <paramref name="input" /> to obtain the output.
            </summary>
            <param name="input">The input.</param>
            <returns>The program's output.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Program`2.Run(`0)">
            <summary>
                Executes the program on the <paramref name="input" /> to obtain the output.
            </summary>
            <param name="input">The input.</param>
            <returns>The output.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.BlackBoxRule.GetTopKStream(Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet,Microsoft.ProgramSynthesis.Features.IFeature,System.Int32,Microsoft.ProgramSynthesis.Features.FeatureCalculationContext,Microsoft.ProgramSynthesis.Learning.Logging.LogListener)">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Rules.Concepts.ConceptRule.IsChildLambdaInConceptAst">
            <summary>
                A list of boolean values which indicate whether the child at the specified index is a lambda node or not.
                The indexing corresponds to the children of the Concept ASTs.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.Concepts.ConceptRule.GetTopKStream(Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet,Microsoft.ProgramSynthesis.Features.IFeature,System.Int32,Microsoft.ProgramSynthesis.Features.FeatureCalculationContext,Microsoft.ProgramSynthesis.Learning.Logging.LogListener)">
            <summary>
                Computes the top-k on a program set.
            </summary>
            <param name="programSet">
                The <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet" /> rooted at this rule, from which the top k programs are to be
                computed.
            </param>
            <param name="feature">The feature based on which the top-k is to be computed.</param>
            <param name="k">The number of top programs to return.</param>
            <param name="fcc">The <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext" />.</param>
            <param name="logListener">Logger to inform of this TopK call.</param>
            <returns>
                A sequence of the top programs in <paramref name="programSet" />, sorted in descending order of the value for
                <paramref name="feature" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.Concepts.ConceptRule.GetParameterPositionInConcept(System.Int32)">
            <summary>
            Given a parameter index in the DSL operator, returns the position of the corresponding child in the concept implementation
            as a coordinate path.
            </summary>
            <param name="dslParameterIndex">The index of the requested child in the list of DSL operator parameters</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Rules.Concepts.ConceptParameterUsage">
            <summary>
            Describe usage properties of a parameter of a concept rule as an argument in its concept implementation.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Rules.Concepts.ParameterUsage">
            <summary>
            How the formal parameter corresponds to the concept argument? It can be either used directly as an argument
            symbol, or passed on to the argument symbol as a child (if the argument symbol is a lambda symbol or another
            concept).
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Rules.Concepts.ConceptTopKStreamHelper">
            <summary>
                A helper class for computing topK streams on Concept ProgramSets.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.Concepts.ConceptTopKStreamHelper.SequenceTransformerTopKStream(Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet,Microsoft.ProgramSynthesis.Features.IFeature,System.Int32,System.Int32,System.Func{Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode},System.Int32,Microsoft.ProgramSynthesis.Features.FeatureCalculationContext,Microsoft.ProgramSynthesis.Learning.Logging.LogListener)">
            <summary>
                Computes the topK stream for a sequence transformer concept.
                e.g. Map, Filter, First, etc.
            </summary>
            <param name="programSet">The <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet" /> for which the topK stream is to be computed.</param>
            <param name="feature">The feature used for scoring.</param>
            <param name="sequenceGeneratorIndex">
                The index of the parameter of <paramref name="programSet" /> which contains the
                sequence generator for this concept.
            </param>
            <param name="sequenceTransformerIndex">
                The index of the parameter of <paramref name="programSet" /> which contains the
                sequence transformer for this concept.
            </param>
            <param name="builder">
                A function that takes a generator program and a transformer program and constructs a concept
                program.
            </param>
            <param name="k">The number of top concept programs requierd.</param>
            <param name="fcc">The <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext" /> that is applicable at the concept program level.</param>
            <param name="logListener">Logger to inform of this TopK call.</param>
            <returns>A sequence of top concept programs.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.Concepts.Filter.GetInputTransformer(Microsoft.ProgramSynthesis.AST.ProgramNode,System.Int32)">
            <summary>
                Returns a transformer that transforms inputs to the program <paramref name="p" />, which
                is derived from this <see cref="T:Microsoft.ProgramSynthesis.Rules.GrammarRule" />, into inputs for the child of <paramref name="p" />,
                which is at index <paramref name="childIndex" />.
                If a <c>null</c> <see cref="T:Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer" /> is returned, then the inputs to <paramref name="p" />
                are also applicable to the child of <paramref name="p" /> at index <paramref name="childIndex" /> without
                any transformations.
            </summary>
            <param name="p">The program.</param>
            <param name="childIndex">The index of the child of <paramref name="p" /> for which inputs are to be transformed.</param>
            <returns>An <see cref="T:Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer" />.</returns>
            <remarks>In the case of concept rules, <paramref name="childIndex" /> refers to the index of the child in the DSL AST.</remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.Concepts.Filter.GetTopKStream(Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet,Microsoft.ProgramSynthesis.Features.IFeature,System.Int32,Microsoft.ProgramSynthesis.Features.FeatureCalculationContext,Microsoft.ProgramSynthesis.Learning.Logging.LogListener)">
            <summary>
                Computes the top-k on a program set.
            </summary>
            <param name="programSet">
                The <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet" /> rooted at this rule, from which the top k programs are to be
                computed.
            </param>
            <param name="feature">The feature based on which the top-k is to be computed.</param>
            <param name="k">The number of top programs to return.</param>
            <param name="fcc">The <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext" />.</param>
            <param name="logListener">Logger to inform of this TopK call.</param>
            <returns>
                A sequence of the top programs in <paramref name="programSet" />, sorted in descending order of the value for
                <paramref name="feature" />.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Rules.Concepts.FilterNot">
            <summary>
                Removes elements from a set that satisfy a predicate, i.e.,
                FilterNot(\x => pred(x), list) = { x | x \in list, !pred(x) }.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Rules.Concepts.FilterNot.Predicate">
            <summary>
                The eliminating predicate.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Rules.Concepts.FilterNot.Set">
            <summary>
                The elements.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.Concepts.FilterNot.GetInputTransformer(Microsoft.ProgramSynthesis.AST.ProgramNode,System.Int32)">
            <summary>
                Returns a transformer that transforms inputs to the program <paramref name="p" />, which
                is derived from this <see cref="T:Microsoft.ProgramSynthesis.Rules.GrammarRule" />, into inputs for the child of <paramref name="p" />,
                which is at index <paramref name="childIndex" />.
                If a <c>null</c> <see cref="T:Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer" /> is returned, then the inputs to <paramref name="p" />
                are also applicable to the child of <paramref name="p" /> at index <paramref name="childIndex" /> without
                any transformations.
            </summary>
            <param name="p">The program.</param>
            <param name="childIndex">The index of the child of <paramref name="p" /> for which inputs are to be transformed.</param>
            <returns>An <see cref="T:Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.Concepts.FilterNot.GetTopKStream(Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet,Microsoft.ProgramSynthesis.Features.IFeature,System.Int32,Microsoft.ProgramSynthesis.Features.FeatureCalculationContext,Microsoft.ProgramSynthesis.Learning.Logging.LogListener)">
            <summary>
                Computes the top-k on a program set.
            </summary>
            <param name="programSet">
                The <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet" /> rooted at this rule, from which the top k programs are to be
                computed.
            </param>
            <param name="feature">The feature based on which the top-k is to be computed.</param>
            <param name="k">The number of top programs to return.</param>
            <param name="fcc">The <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext" />.</param>
            <param name="logListener">Logger to inform of this TopK call.</param>
            <returns>
                A sequence of the top programs in <paramref name="programSet" />, sorted in descending order of the value for
                <paramref name="feature" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.Concepts.First.GetInputTransformer(Microsoft.ProgramSynthesis.AST.ProgramNode,System.Int32)">
            <summary>
                Returns a transformer that transforms inputs to the program <paramref name="p" />, which
                is derived from this <see cref="T:Microsoft.ProgramSynthesis.Rules.GrammarRule" />, into inputs for the child of <paramref name="p" />,
                which is at index <paramref name="childIndex" />.
                If a <c>null</c> <see cref="T:Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer" /> is returned, then the inputs to <paramref name="p" />
                are also applicable to the child of <paramref name="p" /> at index <paramref name="childIndex" /> without
                any transformations.
            </summary>
            <param name="p">The program.</param>
            <param name="childIndex">The index of the child of <paramref name="p" /> for which inputs are to be transformed.</param>
            <returns>An <see cref="T:Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer" />.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Rules.Concepts.Kth">
            <summary>
                Kth(L, k) selects the kth element from the sequence L.
                If k is non-negative, we select the element in the forward order (starting from 0 for the 1st element, 1 for the
                2nd element, and so on).
                If k is negative, we select the element in the backward order (starting from -1 for the last element, -2 for the
                penultimate element, and so on)
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.Concepts.Map.GetInputTransformer(Microsoft.ProgramSynthesis.AST.ProgramNode,System.Int32)">
            <summary>
                Returns a transformer that transforms inputs to the program <paramref name="p" />, which
                is derived from this <see cref="T:Microsoft.ProgramSynthesis.Rules.GrammarRule" />, into inputs for the child of <paramref name="p" />,
                which is at index <paramref name="childIndex" />.
                If a <c>null</c> <see cref="T:Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer" /> is returned, then the inputs to <paramref name="p" />
                are also applicable to the child of <paramref name="p" /> at index <paramref name="childIndex" /> without
                any transformations.
            </summary>
            <param name="p">The program.</param>
            <param name="childIndex">The index of the child of <paramref name="p" /> for which inputs are to be transformed.</param>
            <returns>An <see cref="T:Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer" />.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Rules.Concepts.NamespaceDoc">
            <summary>
                Functions common to many DSLs are defined using <see cref="T:Microsoft.ProgramSynthesis.Rules.Concepts.ConceptRule"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.Concepts.SelectMany.GetInputTransformer(Microsoft.ProgramSynthesis.AST.ProgramNode,System.Int32)">
            <summary>
                Returns a transformer that transforms inputs to the program <paramref name="p" />, which
                is derived from this <see cref="T:Microsoft.ProgramSynthesis.Rules.GrammarRule" />, into inputs for the child of <paramref name="p" />,
                which is at index <paramref name="childIndex" />.
                If a <c>null</c> <see cref="T:Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer" /> is returned, then the inputs to <paramref name="p" />
                are also applicable to the child of <paramref name="p" /> at index <paramref name="childIndex" /> without
                any transformations.
            </summary>
            <param name="p">The program.</param>
            <param name="childIndex">The index of the child of <paramref name="p" /> for which inputs are to be transformed.</param>
            <returns>An <see cref="T:Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.Concepts.Split.GetInputTransformer(Microsoft.ProgramSynthesis.AST.ProgramNode,System.Int32)">
            <summary>
                Returns a transformer that transforms inputs to the program <paramref name="p" />, which
                is derived from this <see cref="T:Microsoft.ProgramSynthesis.Rules.GrammarRule" />, into inputs for the child of <paramref name="p" />,
                which is at index <paramref name="childIndex" />.
                If a <c>null</c> <see cref="T:Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer" /> is returned, then the inputs to <paramref name="p" />
                are also applicable to the child of <paramref name="p" /> at index <paramref name="childIndex" /> without
                any transformations.
            </summary>
            <param name="p">The program.</param>
            <param name="childIndex">The index of the child of <paramref name="p" /> for which inputs are to be transformed.</param>
            <returns>An <see cref="T:Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.Concepts.TakeWhile.GetInputTransformer(Microsoft.ProgramSynthesis.AST.ProgramNode,System.Int32)">
            <summary>
                Returns a transformer that transforms inputs to the program <paramref name="p" />, which
                is derived from this <see cref="T:Microsoft.ProgramSynthesis.Rules.GrammarRule" />, into inputs for the child of <paramref name="p" />,
                which is at index <paramref name="childIndex" />.
                If a <c>null</c> <see cref="T:Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer" /> is returned, then the inputs to <paramref name="p" />
                are also applicable to the child of <paramref name="p" /> at index <paramref name="childIndex" /> without
                any transformations.
            </summary>
            <param name="p">The program.</param>
            <param name="childIndex">The index of the child of <paramref name="p" /> for which inputs are to be transformed.</param>
            <returns>An <see cref="T:Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer" />.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Rules.ConversionRule.Substitutions">
            <summary>
                The substitutions to be applied if the head and body of this <see cref="T:Microsoft.ProgramSynthesis.Rules.ConversionRule" /> belong
                to different DSL grammars.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Rules.ConversionRule.IsTrivial">
            <summary>
                A <see cref="T:Microsoft.ProgramSynthesis.Rules.ConversionRule" /> is trivial if it does not contain any variable substitutions for
                interfacing with an external grammar.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.ConversionRule.GetTopKStream(Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet,Microsoft.ProgramSynthesis.Features.IFeature,System.Int32,Microsoft.ProgramSynthesis.Features.FeatureCalculationContext,Microsoft.ProgramSynthesis.Learning.Logging.LogListener)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.GrammarRule.Intersect(Microsoft.ProgramSynthesis.ILanguage)">
            <summary>
                Intersects <paramref name="other" /> with this language. The implicit assumption is that <paramref name="other" />
                is a subset of the language defined by the <see cref="P:Microsoft.ProgramSynthesis.Rules.GrammarRule.Grammar" /> that this rule is associated with.
            </summary>
            <param name="other">The language to intersect with.</param>
            <returns>A language corresponding to the intersection of <code>this</code> with <paramref name="other" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.GrammarRule.GetInputTransformer(Microsoft.ProgramSynthesis.AST.ProgramNode,System.Int32)">
            <summary>
                Returns a transformer that transforms inputs to the program <paramref name="p" />, which
                is derived from this <see cref="T:Microsoft.ProgramSynthesis.Rules.GrammarRule" />, into inputs for the child of <paramref name="p" />,
                which is at index <paramref name="childIndex" />.
                If a <c>null</c> <see cref="T:Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer" /> is returned, then the inputs to <paramref name="p" />
                are also applicable to the child of <paramref name="p" /> at index <paramref name="childIndex" /> without
                any transformations.
            </summary>
            <param name="p">The program.</param>
            <param name="childIndex">The index of the child of <paramref name="p" /> for which inputs are to be transformed.</param>
            <returns>An <see cref="T:Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer" />.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Rules.GrammarRule.RecursionLimit">
            <summary>
            A list of recursion limits for each body parameter;
            <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing"/> if the parameter is not recursive, or recursion is unlimited.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.GrammarRule.AddStandardWitnessFunction(Microsoft.ProgramSynthesis.Learning.WitnessFunction.Static.Delegate,System.Int32,Microsoft.ProgramSynthesis.Learning.WitnessFunctionAttribute)">
            <summary>
                Add a standard witness function by means of a delegate specifying its behavior
            </summary>
            <remarks>
                For this delegate case, <paramref name="attr" /> must be specified because the delegate won't be
                carrying any useful custom attributes.
            </remarks>
            <param name="witnessFunction">A delegate specifying the behavior of the witness function</param>
            <param name="parameter">The index of the parameter being learned</param>
            <param name="attr">Attribute containing metadata about the witness function</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.GrammarRule.AddStandardWitnessFunction(System.Linq.Expressions.Expression{System.Action},System.Int32,Microsoft.ProgramSynthesis.Learning.WitnessFunctionAttribute)">
            <summary>
                Add a standard witness function by means of an <see cref="T:System.Linq.Expressions.Expression"></see>.
            </summary>
            <param name="surroundWitnessFunction">
                An <see cref="T:System.Linq.Expressions.Expression"></see> used to specify the witness function.  It must be
                of the form <c>() => TheWitnessFunction(ignoredParameters)</c>.  This method will extract the method
                being called and discard the remainder of the <see cref="T:System.Linq.Expressions.Expression"></see>.
            </param>
            <param name="parameter">The index of the parameter being learned</param>
            <param name="attr">Attribute containing metadata about the witness function</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.LambdaRule.GetTopKStream(Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet,Microsoft.ProgramSynthesis.Features.IFeature,System.Int32,Microsoft.ProgramSynthesis.Features.FeatureCalculationContext,Microsoft.ProgramSynthesis.Learning.Logging.LogListener)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.LambdaRule.GetInputTransformer(Microsoft.ProgramSynthesis.AST.ProgramNode,System.Int32)">
            <summary>
                Returns a transformer that transforms inputs to the program <paramref name="p" />, which
                is derived from this <see cref="T:Microsoft.ProgramSynthesis.Rules.GrammarRule" />, into inputs for the child of <paramref name="p" />,
                which is at index <paramref name="childIndex" />.
                If a <c>null</c> <see cref="T:Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer" /> is returned, then the inputs to <paramref name="p" />
                are also applicable to the child of <paramref name="p" /> at index <paramref name="childIndex" /> without
                any transformations.
            </summary>
            <param name="p">The program.</param>
            <param name="childIndex">The index of the child of <paramref name="p" /> for which inputs are to be transformed.</param>
            <returns>An <see cref="T:Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer" />.</returns>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Rules.LetRule.LetBindingIndex">
            <summary>
                The index of the let binding in <see cref="P:Microsoft.ProgramSynthesis.Rules.GrammarRule.Body" /> or <see cref="P:Microsoft.ProgramSynthesis.AST.ProgramNode.Children" />.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Rules.LetRule.LetBodyIndex">
            <summary>
                The index of the let body in <see cref="P:Microsoft.ProgramSynthesis.Rules.GrammarRule.Body" /> or <see cref="P:Microsoft.ProgramSynthesis.AST.ProgramNode.Children" />.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Rules.LetRule.NumBindings">
            <summary>
                Number of bindings in a let rule. This is used to mark places in the code that assume let rule have a single binding.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.LetRule.GetTopKStream(Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet,Microsoft.ProgramSynthesis.Features.IFeature,System.Int32,Microsoft.ProgramSynthesis.Features.FeatureCalculationContext,Microsoft.ProgramSynthesis.Learning.Logging.LogListener)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.LetRule.GetInputTransformer(Microsoft.ProgramSynthesis.AST.ProgramNode,System.Int32)">
            <summary>
                Returns a transformer that transforms inputs to the program <paramref name="p" />, which
                is derived from this <see cref="T:Microsoft.ProgramSynthesis.Rules.GrammarRule" />, into inputs for the child of <paramref name="p" />,
                which is at index <paramref name="childIndex" />.
                If a <c>null</c> <see cref="T:Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer" /> is returned, then the inputs to <paramref name="p" />
                are also applicable to the child of <paramref name="p" /> at index <paramref name="childIndex" /> without
                any transformations.
            </summary>
            <param name="p">The program.</param>
            <param name="childIndex">The index of the child of <paramref name="p" /> for which inputs are to be transformed.</param>
            <returns>An <see cref="T:Microsoft.ProgramSynthesis.Features.InputTransformation.IInputTransformer" />.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Rules.NamespaceDoc">
            <summary>
                Classes for representing DSL grammars (<see cref="T:Microsoft.ProgramSynthesis.Grammar"/>) in memory,
                which are made out of <see cref="T:Microsoft.ProgramSynthesis.Rules.GrammarRule"/> and its subclasses.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.NonterminalRule.ValidStateFromArgumentInvocations(Microsoft.ProgramSynthesis.Utils.Record{Microsoft.ProgramSynthesis.State,System.Object}[])">
            <summary>
                Constructs a valid State with which this rule should have been invoked to produce the given
                <param name="argumentInvocations">states and values</param>
                for its parameter invocations.
            </summary>
            <returns>Null if the given states are incompatible with the rule logic; a valid State otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.NonterminalRule.GetTopKStream(Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet,Microsoft.ProgramSynthesis.Features.IFeature,System.Int32,Microsoft.ProgramSynthesis.Features.FeatureCalculationContext,Microsoft.ProgramSynthesis.Learning.Logging.LogListener)">
            <summary>
                Computes the top-k on a program set.
            </summary>
            <param name="programSet">
                The <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet" /> rooted at this rule, from which the top k programs are to be
                computed.
            </param>
            <param name="feature">The feature based on which the top-k is to be computed.</param>
            <param name="k">The number of top programs to return.</param>
            <param name="fcc">The <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext" />.</param>
            <param name="logListener">Logger to inform of this TopK call.</param>
            <returns>
                A sequence of the top programs in <paramref name="programSet" />, sorted in descending order of the value for
                <paramref name="feature" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.NonterminalRule.ComputeParamK(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{System.Numerics.BigInteger})">
            <summary>
                Computes the number of top programs to take from each of the parameter spaces of a
                <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet" />, in order to compute the TopK programs from the
                <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet" />.
            </summary>
            <param name="k">The number of top programs required.</param>
            <param name="arity">The arity of <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet" />.</param>
            <param name="paramSpaceSizes">
                The sizes of the parameter spaces in the <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet" />
                over which the top k programs are to be computed.
            </param>
            <returns>
                An list of integers that indicates how many top programs to gather from the
                corresponding parameter space of the <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.NonterminalRule.ComputeParamK(System.Int32,System.Numerics.BigInteger,System.Numerics.BigInteger)">
            <inheritdoc cref="M:Microsoft.ProgramSynthesis.Rules.NonterminalRule.ComputeParamK(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{System.Numerics.BigInteger})" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.NonterminalRule.GenericTopKStream(Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet,Microsoft.ProgramSynthesis.Features.IFeature,System.Int32,Microsoft.ProgramSynthesis.Features.FeatureCalculationContext,Microsoft.ProgramSynthesis.Learning.Logging.LogListener)">
            <summary>
                Generates a top-k stream in a generic manner, without giving any special consideration to
                how the <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext" /> (<paramref name="fcc" />) is adapted to
                various parts of the program set.
            </summary>
            <param name="programSet">The <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet" />.</param>
            <param name="feature">The feature with respect to which the top-k stream is to be computed.</param>
            <param name="k">The number of programs in the stream.</param>
            <param name="fcc">The <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureCalculationContext" />.</param>
            <param name="logListener">Logger to inform of this TopK call.</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Rules.OperatorRule.OperatorSemantics">
            <summary>
            The semantics of an operator rule: ⟦f(N₁, ..., Nₖ)⟧ σ = f(⟦N₁⟧ σ, ..., ⟦Nₖ⟧ σ).
            Such a function does not change its given state σ during execution, therefore it is not given this state explicitly.
            </summary>
            <param name="args">The values of the evaluated argument nodes: [⟦N₁⟧ σ, ..., ⟦Nₖ⟧ σ].</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Specifications.DisjunctiveSubsequenceSpec">
            <summary>
                An output of the program is a set of objects.
                A spec provides possible subsets of the output on a given input.
                An invocation of a program on the same input
                is valid if its output is a superset of one of the example outputs.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.ExampleWithNegativesSpec.TransformInputs(System.Func{Microsoft.ProgramSynthesis.State,Microsoft.ProgramSynthesis.State})">
            <summary>
                Produces a copy of this <see cref="T:Microsoft.ProgramSynthesis.Specifications.Spec" /> where the provided inputs
                are transformed with a given
                transformer function <paramref name="transformer" />, and the associated constrains on the inputs remain the same.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Specifications.Extensions.NamespaceDoc">
            <summary>
                Helper methods for <see cref="T:Microsoft.ProgramSynthesis.Specifications.Spec"/> and related types.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Specifications.GroupedExamplesSpec">
            <summary>
                An ExampleSpec which keeps count of duplicate examples as well.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.GroupedExamplesSpec.#ctor(System.Collections.Generic.IReadOnlyDictionary{Microsoft.ProgramSynthesis.State,System.Collections.Generic.KeyValuePair{System.Object,System.UInt32}})">
            <summary>
                Instantiates a new <see cref="T:Microsoft.ProgramSynthesis.Specifications.GroupedExamplesSpec" /> from counts of examples.
            </summary>
            <param name="examplesWithCounts">Dictionary of states mapped to the result and count.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.GroupedExamplesSpec.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{Microsoft.ProgramSynthesis.State,System.Collections.Generic.KeyValuePair{System.Object,System.UInt32}}})">
            <summary>
                Instantiates a new <see cref="T:Microsoft.ProgramSynthesis.Specifications.GroupedExamplesSpec" /> from counts of examples.
            </summary>
            <param name="examplesWithCounts">
                An Enumerable of KeyValuePairs with states mapped to the result and count.
            </param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Specifications.GroupedExamplesSpec.ExamplesWithCounts">
            <summary>
                Dictionary of states mapped to the result and count.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.GroupedExamplesSpec.FromExamples(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{Microsoft.ProgramSynthesis.State,System.Object}},System.Collections.Generic.IEqualityComparer{System.Collections.Generic.KeyValuePair{Microsoft.ProgramSynthesis.State,System.Object}})">
            <summary>
                Construct a new instance of <see cref="T:Microsoft.ProgramSynthesis.Specifications.GroupedExamplesSpec" /> from an enumerable of examples which may have
                duplicates, and an equality comparer.
            </summary>
            <param name="examples">An enumerable of examples.</param>
            <param name="equalityComparer">An equality comparer for examples.</param>
            <returns>
                An instance of <see cref="T:Microsoft.ProgramSynthesis.Specifications.GroupedExamplesSpec" />.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Specifications.NamespaceDoc">
            <summary>
                <see cref="T:Microsoft.ProgramSynthesis.Specifications.Spec" /> and subclasses for conditions a learned program is expected to satisfy.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Specifications.PrefixSpec">
            <summary>
                An output of the program is a sequence of objects. This specification provides: (a) a prefix of the output on a
                given input, and (b) a set of the negative examples on a given input which the output should not intersect with.
                An output of the program is a sequence of objects. This spec provides a prefix of the output on a given input. An
                invocation of a program on the same input is valid if the example output is the prefix of the program's output, and
                the output does not intersect with the negative examples.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.PrefixSpec.#ctor(Microsoft.ProgramSynthesis.State,System.Collections.Generic.IEnumerable{System.Object},System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                Creates a specification with the prefix and optional negative examples on a single input.
            </summary>
            <param name="input">The input state.</param>
            <param name="prefix">The prefix of the output.</param>
            <param name="negativeExamples">The optional negative examples.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.PrefixSpec.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{Microsoft.ProgramSynthesis.State,System.Collections.Generic.IEnumerable{System.Object}}})">
            <summary>
                Creates a specification with only the prefix.
                <param name="prefix">The prefix of the output.</param>
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.PrefixSpec.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{Microsoft.ProgramSynthesis.State,Microsoft.ProgramSynthesis.Utils.Record{System.Collections.Generic.IEnumerable{System.Object},System.Collections.Generic.IEnumerable{System.Object}}}})">
            <summary>
                Creates a specification with both prefix and negative examples.
                <param name="examples">The pairs of prefix and negative examples.</param>
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.PrefixSpec.ToString">
            <summary>
                Returns the string representation.
            </summary>
            <returns>The string representation</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Specifications.PrefixTableSpec">
            <summary>
                An output of the program is a table.
                This specification provides a prefix of the output table on a given input.
                An invocation of a program on the same input is valid if the example output is a prefix of its output table.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.PrefixTableSpec.#ctor(Microsoft.ProgramSynthesis.State,Microsoft.ProgramSynthesis.Wrangling.Schema.TableOutput.ITable{System.Object})">
            <summary>
                Creates a specification with a table example on a single input.
            </summary>
            <param name="input">The input state.</param>
            <param name="example">The exemplar prefix table.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Specifications.PrefixTableSpec.PrefixTables">
            <summary>
                The exemplar prefix tables.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.PrefixTableSpec.ToString">
            <summary>
                Returns the string representation.
            </summary>
            <returns>The string representation</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.Spec.#ctor(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.State},System.Boolean)">
            <summary>
                Constructs a new spec from the given inputs
            </summary>
            <param name="inputs">The input states for the spec</param>
            <param name="disallowDuplicateInputs">Whether duplicate inputs are permitted (duplicates may be required to convey distribution/proportion of recurring values for some applications)</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Specifications.Spec.ProvidedInputs">
            <summary>
                The input states this spec is defined on.
                For each input in <see cref="P:Microsoft.ProgramSynthesis.Specifications.Spec.ProvidedInputs" /> the spec stores some constraint that
                the desired program output should satisfy.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.Spec.CorrectOnProvided(Microsoft.ProgramSynthesis.State,System.Object)">
            <summary>
                Checks if <paramref name="output" /> satisfies this spec on a given input <paramref name="state" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.Spec.CorrectOnAllProvided(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                Checks if all the <paramref name="outputs" /> satisfy this spec.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.Spec.CorrectOnAllProvided(System.Object)">
            <summary>
                Checks if <paramref name="output" /> satisfies this spec.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.Spec.CorrectOnAllProvided(Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Checks if the given <paramref name="program" /> satisfies this spec by invoking it on all the provided
                inputs in <see cref="P:Microsoft.ProgramSynthesis.Specifications.Spec.ProvidedInputs" /> and checking the outputs using <see cref="M:Microsoft.ProgramSynthesis.Specifications.Spec.CorrectOnProvided(Microsoft.ProgramSynthesis.State,System.Object)" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.Spec.Valid(Microsoft.ProgramSynthesis.State,System.Object)">
            <summary>
                Checks if the <paramref name="output" /> satisfies this spec on a given <paramref name="input" />.
                If <paramref name="input" /> is not present in <see cref="P:Microsoft.ProgramSynthesis.Specifications.Spec.ProvidedInputs" />, this method conservatively
                returns <c>true</c> without any verification.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.Spec.EqualsOnInput(Microsoft.ProgramSynthesis.State,Microsoft.ProgramSynthesis.Specifications.Spec)">
            <summary>
                For a given input <paramref name="state" />, checks if the content of this spec is the same
                as in the <paramref name="other" /> given spec.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.Spec.GetHashCodeOnInput(Microsoft.ProgramSynthesis.State)">
            <summary>
                Computes a hash code of the content of this spec associated with a given <paramref name="state" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.Spec.NullToBottom">
            <summary>
                Returns a copy of this spec where all instances of <c>null</c> in the output constraints
                are replaced with the special value <see cref="T:Microsoft.ProgramSynthesis.Utils.Bottom" />.
            </summary>
            <remarks>
                A typical implementation makes use of the helper method <see cref="M:Microsoft.ProgramSynthesis.Utils.ObjectUtils.NullToBottom(System.Object)" />.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.Spec.BottomToNull">
            <summary>
                Returns a copy of this spec where all instances of <see cref="T:Microsoft.ProgramSynthesis.Utils.Bottom" /> in the output constraints
                are replaced with <c>null</c>.
            </summary>
            <remarks>
                A typical implementation makes use of the helper method <see cref="M:Microsoft.ProgramSynthesis.Utils.ObjectUtils.BottomToNull(System.Object)" />.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.Spec.InputToXML(Microsoft.ProgramSynthesis.State,System.Collections.Generic.Dictionary{System.Object,System.Int32})">
            <summary>
                Returns an XML representation of the content of this spec
                associated with a given <paramref name="input" /> state.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.Spec.TransformInputs(System.Func{Microsoft.ProgramSynthesis.State,Microsoft.ProgramSynthesis.State})">
            <summary>
                Produces a copy of this <see cref="T:Microsoft.ProgramSynthesis.Specifications.Spec" /> where the provided inputs are transformed with a given
                <paramref name="transformer" /> function, and the associated constrains on the inputs remain the same.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Specifications.SubsequenceSpec">
            <summary>
                An output of the program is a set of objects.
                This specification provides: (a) a subset of the output on a given input, and (b) a set of the negative examples on
                a given input which
                the output should not intersect with. An invocation of a program on the same input
                is valid if its output is a superset of the example output, and the output does not intersect with the negative
                examples.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.SubsequenceSpec.#ctor(Microsoft.ProgramSynthesis.State,System.Collections.Generic.IEnumerable{System.Object},System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                Creates a specification with positive examples and optional negative examples on a single input.
            </summary>
            <param name="input">The input state.</param>
            <param name="positiveExamples">The positive examples.</param>
            <param name="negativeExamples">The optional negative examples.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.SubsequenceSpec.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{Microsoft.ProgramSynthesis.State,System.Collections.Generic.IEnumerable{System.Object}}})">
            <summary>
                Creates a specification with only positive examples.
                <param name="positiveExamples">The positive examples.</param>
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.SubsequenceSpec.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{Microsoft.ProgramSynthesis.State,Microsoft.ProgramSynthesis.Utils.Record{System.Collections.Generic.IEnumerable{System.Object},System.Collections.Generic.IEnumerable{System.Object}}}})">
            <summary>
                Creates a specification with both positive and negative examples.
                <param name="examples">The pairs of positive and negative examples.</param>
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Specifications.SubsequenceSpec.PositiveExamples">
            <summary>
                The positive examples.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Specifications.SubsequenceSpec.NegativeExamples">
            <summary>
                The negative examples.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.SubsequenceSpec.ToString">
            <summary>
                Returns the string representation.
            </summary>
            <returns>The string representation</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Specifications.TopSpec">
            <summary>
                A trivial spec that stores no inputs, and is satisfied by any program.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Specifications.WithInputTopSpec">
            <summary>
                A trivial spec that contains several inputs and is satisfied by any program.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.State.SmallStateThreshold">
            <summary>
                States that hold fewer than <see cref="F:Microsoft.ProgramSynthesis.State.SmallStateThreshold" /> variables are stored as <see cref="T:Microsoft.ProgramSynthesis.State.SmallState" />
                with <see cref="T:System.Collections.Immutable.ImmutableList`1" /> for underlying storage. States that hold more variables are stored as
                <see cref="T:Microsoft.ProgramSynthesis.State.BigState" /> with <see cref="T:System.Collections.Immutable.ImmutableDictionary`2" /> for underlying storage.
                The choice of <see cref="T:Microsoft.ProgramSynthesis.State.SmallState" /> vs. <see cref="T:Microsoft.ProgramSynthesis.State.BigState" /> in
                <see>
                    <cref>Create(IList{KeyValuePair{Symbol, object}}, FunctionalInputs)</cref>
                </see>
                is done based on the length of the longest chain of variables bindings that may appear in a given
                <see cref="T:Microsoft.ProgramSynthesis.Grammar" />.
                This property is stored as <see cref="P:Microsoft.ProgramSynthesis.Grammar.FreeVariableHeight" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.State.CreateForExecution(Microsoft.ProgramSynthesis.Symbol,System.Object)">
            <summary>
                Creates a <see cref="T:Microsoft.ProgramSynthesis.State" /> in which <paramref name="symbol" /> is bound to <paramref name="value" />.
                This method does not create a hash code. It is usually used in <see cref="M:Microsoft.ProgramSynthesis.Program`2.Run(`0)" />
                because this method does not compare states.
                Its counter part is <seealso cref="M:Microsoft.ProgramSynthesis.State.CreateForLearning(Microsoft.ProgramSynthesis.Symbol,System.Object)" /> which computes hash code and is used during
                learning.
            </summary>
            <param name="symbol">The symbol.</param>
            <param name="value">The value of <paramref name="symbol" />.</param>
            <returns>A <see cref="T:Microsoft.ProgramSynthesis.State" /> in which <paramref name="symbol" /> is bound to <paramref name="value" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.State.CreateForExecution(System.Collections.Generic.KeyValuePair{Microsoft.ProgramSynthesis.Symbol,System.Object}[])">
            <summary>
                Creates a <see cref="T:Microsoft.ProgramSynthesis.State" /> for a list of binding symbol, object pairs.
                This method does not create a hash code. It is usually used in <see cref="M:Microsoft.ProgramSynthesis.Program`2.Run(`0)" />
                because this method does not compare states.
            </summary>
            <param name="values">The list of bindings.</param>
            <returns>The state.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.State.CreateForLearning(Microsoft.ProgramSynthesis.Symbol,System.Object)">
            <summary>
                Creates a <see cref="T:Microsoft.ProgramSynthesis.State" /> in which <paramref name="symbol" /> is bound to <paramref name="value" />.
                This method creates a hash code eagerly. It is usually used in learning where state comparison are perform
                frequently.
                Its counter part is <seealso cref="M:Microsoft.ProgramSynthesis.State.CreateForExecution(Microsoft.ProgramSynthesis.Symbol,System.Object)" /> which does not compute hash code
                and is used during execution.
            </summary>
            <param name="symbol">The symbol.</param>
            <param name="value">The value of <paramref name="symbol" />.</param>
            <returns>A <see cref="T:Microsoft.ProgramSynthesis.State" /> in which <paramref name="symbol" /> is bound to <paramref name="value" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.State.CreateForLearning(Microsoft.ProgramSynthesis.Symbol,System.Object,Microsoft.ProgramSynthesis.Utils.Optional{System.Object})">
            <summary>
                Creates a <see cref="T:Microsoft.ProgramSynthesis.State" /> in which <paramref name="symbol" /> is bound to <paramref name="value" /> and has
                <paramref name="functionalInput" />
                This method creates a hash code eagerly. It is usually used in learning where state comparison are perform
                frequently.
            </summary>
            <param name="symbol">The symbol.</param>
            <param name="value">The value of <paramref name="symbol" />.</param>
            <param name="functionalInput">The functional input.</param>
            <returns>The state.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.State.CreateForLearning(System.Collections.Generic.IList{System.Collections.Generic.KeyValuePair{Microsoft.ProgramSynthesis.Symbol,System.Object}})">
            <summary>
                Creates a <see cref="T:Microsoft.ProgramSynthesis.State" /> for a list of binding symbol, object pairs.
                This method creates a hash code eagerly. It is usually used in learning where state comparison are perform
                frequently.
            </summary>
            <param name="values">The list of bindings.</param>
            <returns>The state.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.State.CreateForLearning(System.Collections.Generic.IList{System.Collections.Generic.KeyValuePair{Microsoft.ProgramSynthesis.Symbol,System.Object}},Microsoft.ProgramSynthesis.Utils.Optional{System.Object})">
            <summary>
                Creates a <see cref="T:Microsoft.ProgramSynthesis.State" /> for a list of binding symbol, object pairs and has a <paramref name="functionalInput"/>.
                This method creates a hash code eagerly. It is usually used in learning where state comparison are perform
                frequently.
            </summary>
            <param name="values">The list of bindings.</param>
            <param name="functionalInput">The functional input.</param>
            <returns>The state.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.State.CreateForLearning(System.Collections.Generic.KeyValuePair{Microsoft.ProgramSynthesis.Symbol,System.Object}[])">
            <summary>
                Creates a <see cref="T:Microsoft.ProgramSynthesis.State" /> for a list of binding symbol, object pairs.
                This method creates a hash code eagerly. It is usually used in learning where state comparison are perform
                frequently.
            </summary>
            <param name="values">The list of bindings.</param>
            <returns>The state.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.State.SerializeToXML(Microsoft.ProgramSynthesis.Specifications.Serialization.SpecSerializationContext)">
            <summary>
                Serializes this <see cref="T:Microsoft.ProgramSynthesis.State" /> into XML.
            </summary>
            <param name="serializers">
                The <see cref="T:Microsoft.ProgramSynthesis.Specifications.Serialization.SpecSerializationContext" /> that handles the serialization of types
                contained in this <see cref="T:Microsoft.ProgramSynthesis.State" />.
            </param>
            <returns>An <see cref="T:System.Xml.Linq.XElement" /> that represents the serialized state.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.State.SerializeToXML(System.Collections.Generic.Dictionary{System.Object,System.Int32},Microsoft.ProgramSynthesis.Specifications.Serialization.SpecSerializationContext)">
            <summary>
                Serializes this <see cref="T:Microsoft.ProgramSynthesis.State" /> into XML.
            </summary>
            <param name="identityCache">A cache for interned objects.</param>
            <param name="serializers">
                The <see cref="T:Microsoft.ProgramSynthesis.Specifications.Serialization.SpecSerializationContext" /> that handles the serialization of types
                contained in this <see cref="T:Microsoft.ProgramSynthesis.State" />.
            </param>
            <returns>An <see cref="T:System.Xml.Linq.XElement" /> that represents the serialized state.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.State.DeserializeFromXML(System.Xml.Linq.XElement,Microsoft.ProgramSynthesis.Specifications.Serialization.SpecSerializationContext)">
            <summary>
                Deserializes a <see cref="T:Microsoft.ProgramSynthesis.State" /> from an <see cref="T:System.Xml.Linq.XElement" /> produced by a previous call
                to <see cref="M:Microsoft.ProgramSynthesis.State.SerializeToXML(Microsoft.ProgramSynthesis.Specifications.Serialization.SpecSerializationContext)" />.
            </summary>
            <param name="node">The XML node representing the serialized <see cref="T:Microsoft.ProgramSynthesis.State" />.</param>
            <param name="serializers">
                A <see cref="T:Microsoft.ProgramSynthesis.Specifications.Serialization.SpecSerializationContext" /> that handles the deserialization of types contained
                in the resulting <see cref="T:Microsoft.ProgramSynthesis.State" />.
            </param>
            <returns>A deserialized <see cref="T:Microsoft.ProgramSynthesis.State"/>.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.State.DeserializeFromXML(System.Xml.Linq.XElement,Microsoft.ProgramSynthesis.Specifications.Serialization.SpecSerializationContext,System.Collections.Generic.Dictionary{System.Int32,System.Object})">
            <summary>
                Deserializes a <see cref="T:Microsoft.ProgramSynthesis.State" /> from an <see cref="T:System.Xml.Linq.XElement" /> produced by a previous call
                to <see cref="M:Microsoft.ProgramSynthesis.State.SerializeToXML(Microsoft.ProgramSynthesis.Specifications.Serialization.SpecSerializationContext)" />.
            </summary>
            <param name="node">The XML node representing the serialized <see cref="T:Microsoft.ProgramSynthesis.State" />.</param>
            <param name="serializers">
                A <see cref="T:Microsoft.ProgramSynthesis.Specifications.Serialization.SpecSerializationContext" /> that handles the deserialization of types contained
                in the resulting <see cref="T:Microsoft.ProgramSynthesis.State" />.
            </param>
            <param name="identityCache">A cache for interned objects.</param>
            <returns>A deserialized <see cref="T:Microsoft.ProgramSynthesis.State"/>.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Symbol.TryGetAllPrograms(System.Boolean,System.Boolean)">
            <summary>
                Returns a set of all possible programs in the grammar that this symbol can expand to, or
                <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if the set is undefined due to unlimited recursion or unrestricted literals
                without explicit value generators on the leaf level.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.BasicFunctionInliner">
            <summary>
                Perform function inlining in the special case where body of function f(x) has one line,
                which is <code>return g(x)</code>, and there is no other call to g in the code.
                We remove g and bind f to the body of g.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.BasicFunctionInliner.Instance">
            <summary>
                The singleton instance of <see cref="T:Microsoft.ProgramSynthesis.Translation.BasicFunctionInliner" />
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.BasicFunctionInliner.AllUsedFunctions(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,Microsoft.ProgramSynthesis.Translation.SSAGeneratedFunction}})">
            <summary>
                Find all function calls in all function bodies in the given list of functions.
            </summary>
            <param name="functions">List of functions contained in the module.</param>
            <returns>
                A list of function names that are called in the bodies of all
                <see cref="T:Microsoft.ProgramSynthesis.Translation.SSAGeneratedFunction" />s in the given list.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.BasicFunctionInliner.PassThroughFunctions(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,Microsoft.ProgramSynthesis.Translation.SSAGeneratedFunction}})">
            <summary>
                Find all instances of functions f(x) that just return g(x), and g is called nowhere else.
            </summary>
            <param name="functions">List of functions contained in the module.</param>
            <returns>
                A list of pairs of function names with the above property.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.BasicFunctionInliner.TransitivelyCollapse(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Translation.BasicFunctionInliner.CallerCalleePair})">
            <summary>
                Remove redundant intermediates; e.g. TransitivelyCollapse({f=>g, g=>h}) is {f=>h, g=>h}
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.BasicFunctionInliner.ModifyBinding(System.Collections.Generic.Dictionary{System.String,Microsoft.ProgramSynthesis.Translation.IGeneratedFunction},System.Collections.Generic.IReadOnlyDictionary{System.String,Microsoft.ProgramSynthesis.Translation.IGeneratedFunction})">
            <summary>
                Modify the binding (maybe depending on the type of functions).
            </summary>
            <param name="newBinding">Binding from function name to Function body being considered for updating the module.</param>
            <returns>
                The given binding, possibly modified in DSL-specific ways.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.CodeForGeneratedFunction">
            <summary>
                Represents the code generated by a call to <see cref="M:Microsoft.ProgramSynthesis.Translation.IGeneratedFunction.GenerateCode(System.String,Microsoft.ProgramSynthesis.Translation.OptimizeFor)" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.CodeForGeneratedFunction.StaticCode">
            <summary>
                Static code for the function, i.e., code that does not depend on the input to the function.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.CodeForGeneratedFunction.DynamicCode">
            <summary>
                Dynamic code for the function, i.e., code that must be re-evaluated for each different input
                to the function. Note that this code might depend on <see cref="P:Microsoft.ProgramSynthesis.Translation.CodeForGeneratedFunction.StaticCode" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.CodeForGeneratedFunction.#ctor(Microsoft.ProgramSynthesis.Utils.CodeBuilder,Microsoft.ProgramSynthesis.Utils.CodeBuilder)">
            <summary>
                Constructor.
            </summary>
            <param name="staticCode">The static code. See <see cref="P:Microsoft.ProgramSynthesis.Translation.CodeForGeneratedFunction.StaticCode"/>.</param>
            <param name="dynamicCode">The dynamic code. See <see cref="P:Microsoft.ProgramSynthesis.Translation.CodeForGeneratedFunction.DynamicCode"/>.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.CodeForGeneratedFunction.Concat(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Translation.CodeForGeneratedFunction})">
            <summary>
                Concatenates a sequence of <see cref="T:Microsoft.ProgramSynthesis.Translation.CodeForGeneratedFunction" />s.
            </summary>
            <param name="codes">The <see cref="T:Microsoft.ProgramSynthesis.Translation.CodeForGeneratedFunction" /> objects to concatenate.</param>
            <returns>A <see cref="T:Microsoft.ProgramSynthesis.Translation.CodeForGeneratedFunction" /> that represents the concatenation of <paramref name="codes" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.CodeForGeneratedFunction.Concat(Microsoft.ProgramSynthesis.Translation.CodeForGeneratedFunction[])">
            <summary>
                Concatenates a sequence of <see cref="T:Microsoft.ProgramSynthesis.Translation.CodeForGeneratedFunction" />s.
            </summary>
            <param name="codes">The <see cref="T:Microsoft.ProgramSynthesis.Translation.CodeForGeneratedFunction" /> objects to concatenate.</param>
            <returns>A <see cref="T:Microsoft.ProgramSynthesis.Translation.CodeForGeneratedFunction" /> that represents the concatenation of <paramref name="codes" />.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.ConstantExpressionEvaluator">
            <summary>
                After applying certain optimizers, such as Inliner and Constant ValueProp,
                we can potentially get constant expressions, such as 1 != 2, in the code.
                This optimizer replaces such expressions by the evaluated value (for e.g., True).
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.ConstantExpressionEvaluator.Instance">
            <summary>
                The singleton instance of <see cref="T:Microsoft.ProgramSynthesis.Translation.ConstantExpressionEvaluator" />
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.ConstantExpressionEvaluator.Optimize(System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.Translation.SSAStep})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.ConstantExpressionEvaluator.ConstantExpressionEvaluatorRec(Microsoft.ProgramSynthesis.Translation.SSAValue)">
            Recursively evaluate expression
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.ConstantLifter">
            <summary>
                Lifts all definitions that do not depend on any variables.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.ConstantLifter.ConstantDefinitions">
            <summary>
                After a call to <see cref="M:Microsoft.ProgramSynthesis.Translation.ConstantLifter.Optimize(System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.Translation.SSAStep},Microsoft.ProgramSynthesis.Translation.OptimizeFor)" />, this contains the
                <see cref="T:Microsoft.ProgramSynthesis.Translation.SSAStep" />s that are invariant, i.e., do not depend on
                any variable.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.DeadCodeEliminator">
            <summary>
                Some optimizations result in unused computations. This removes such computations.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.DeadCodeEliminator.Instance">
            <summary>
                The singleton instance of <see cref="T:Microsoft.ProgramSynthesis.Translation.DeadCodeEliminator" />
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.DeadCodeEliminator.Optimize(System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.Translation.SSAStep})">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.GeneratedFunction">
            <summary>
                A simple helper class that implements the functionality commmon to all generated functions
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.GeneratedFunction.Parameters">
            <summary>
                The names and types of the parameters that this function accepts.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.GeneratedFunction.ReturnType">
            <summary>
                The return type of this function.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.GeneratedFunction.Optimize(Microsoft.ProgramSynthesis.Translation.IOptimizer)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.GeneratedFunction.GenerateCode(System.String,Microsoft.ProgramSynthesis.Translation.OptimizeFor)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.GeneratedFunction.#ctor(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Utils.Record{System.String,System.Type}},System.Type)">
            <summary>
                Constructor.
            </summary>
            <param name="parameters">The name and types of the parameters to this function.</param>
            <param name="returnType">The return type of this function.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.IGeneratedFunction">
            <summary>
                An interface for representing functions generated during translation.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.IGeneratedFunction.Parameters">
            <summary>
                The names and types of the parameters that this function accepts.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.IGeneratedFunction.ReturnType">
            <summary>
                The return type of this function.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.IGeneratedFunction.Optimize(Microsoft.ProgramSynthesis.Translation.IOptimizer)">
            <summary>
                Performs optimizations.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.IGeneratedFunction.GenerateCode(System.String,Microsoft.ProgramSynthesis.Translation.OptimizeFor)">
            <summary>
                Generates code for this <see cref="T:Microsoft.ProgramSynthesis.Translation.IGeneratedFunction" />.
            </summary>
            <param name="headerModuleName">The name of the header module.</param>
            <param name="optimization">The optimization setting to use while generating code.</param>
            <returns>Code (as a <see cref="T:Microsoft.ProgramSynthesis.Translation.CodeForGeneratedFunction"/>) for this <see cref="T:Microsoft.ProgramSynthesis.Translation.IGeneratedFunction"/>.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.IModuleOptimizer">
            <summary>
                An interface for interprocedural optimization on code in a module.
                Use IOptimizer for implementing intraprocedural optimization.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.IModuleOptimizer.Optimize(System.Collections.Generic.IReadOnlyDictionary{System.String,Microsoft.ProgramSynthesis.Translation.IGeneratedFunction},System.Collections.Generic.List{System.String}@)">
            <summary>
                Optimizes a collection of function definitions.
            </summary>
            <param name="boundFunctions">The collection of functions to be optimized.</param>
            <param name="toBeRemovedFunctions">The names of functions to be unbound.</param>
            <returns>
                New bindings from function names to function bodies s.t. the module can update its bindings 
                based on the returned dictionary without changing the semantics.
                The output <paramref name="toBeRemovedFunctions"/> is populated by function names that should be unbound.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.Inliner">
            <summary>
                In the SSA representation, the result of every function call is
                assigned to a temporary variable/register. The value of the register
                is used wherever the result of that function call is required.
                In languages where variable lookup is implemented as a dictionary/hash-map lookup,
                creating lots of temporary variables might have a performance implication.
                This optimization eliminates the temporary registers by inlining the function
                call directly where its result is used, but ONLY if the result of the function call
                is used EXACTLY once. Otherwise, we would be recomputing the result of the function.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.Inliner.Instance">
            <summary>
                The singleton instance of <see cref="T:Microsoft.ProgramSynthesis.Translation.Inliner" />
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Inliner.DepthUpToKTermFilter(Microsoft.ProgramSynthesis.Translation.SSAValue,System.Int32)">
            <summary>
                Return true if the term <paramref name="ssaValue"/> has depth less-than or equal to k
                Depth of a variable or constant is 0, and depth(f(x,y)) is 1 + max(depth(x), depth(y))
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Inliner.SubtermAtDepthUpToK(Microsoft.ProgramSynthesis.Translation.SSAValue,Microsoft.ProgramSynthesis.Translation.SSAValue,System.Int32)">
            <summary>
                Return true if the term <paramref name="subterm"/> ocurs in the term <paramref name="ssaValue"/>
                at depth at most k. For e.g., in f(a,g(b)), a occurs at depth 1 and b occurs at depth 2.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Inliner.ShallowTermFilter(System.Collections.Generic.LinkedListNode{Microsoft.ProgramSynthesis.Translation.SSAStep})">
            <summary>
                Return true if the result of replacing all occurrences of <paramref name="step"/>.Value.LValue
                in the program by <paramref name="step"/>.Value.RValue will produce terms of depth at most 3, or
                if <paramref name="step"/>.Value.LValue does not have a given desiredName.  The reason is that
                if we don't have a desired name, its best to remove this step. If we have a desiredName, then
                we replace only if the resulting terms are "small".
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.Inliner.OperatorsOnly">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Translation.Inliner" /> that only inlines literals, uses of operators, and variables.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.Inliner.ShallowOperatorsOnly">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Translation.Inliner" /> that only inlines a step, say x = f(a,b), if f is a native (language)
                operator, and either x has a given desiredName, or the result of replacing x by f(a,b) in the
                program results in terms with depth at most 3. For e.g., on the program
                x = f(a,b); y = g(x); z = h(c,g(y)), assuming f,g,h are operators and x,y,z have desiredName, then
                this Inliner will inline x = f(a,b) to give y = g(f(a,b)), z = h(c,g(y)), but it would not inline
                y = g(f(a,b)) now, because that would result in a term with depth greater than 3.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Inliner.Optimize(System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.Translation.SSAStep})">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.IOptimizer">
            <summary>
                An interface for SSA based optimizers.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.IOptimizer.Optimize(System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.Translation.SSAStep})">
            <summary>
                Optimizes a sequence of <see cref="T:Microsoft.ProgramSynthesis.Translation.SSAStep" />s.
            </summary>
            <param name="steps">The sequence of <see cref="T:Microsoft.ProgramSynthesis.Translation.SSAStep" />s to be optimized.</param>
            <returns>
                An optimized sequence of <see cref="T:Microsoft.ProgramSynthesis.Translation.SSAStep" />s that is semantically equivalent to <paramref name="steps" />.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.ISubprogramTranslator`5">
            <summary>
                An interface for definining subprogram translators. Instances of implementations of this interface can be passed to
                the <see cref="T:Microsoft.ProgramSynthesis.Translation.Translator`5" /> object, which will then
                attempt to translate subprograms using these implementors. If any of them succeeds for a given subprogram (i.e., by
                returning <see cref="T:Microsoft.ProgramSynthesis.Utils.Optional`1" />.Some), then the result will be used as the translation for that subprogram.
                Otherwise, the normal translation will be applied for the subprogram.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.ISubprogramTranslator`5.Translate(Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.Translation.OptimizeFor,Microsoft.ProgramSynthesis.Translation.Translator{`0,`1,`2,`3,`4})">
            <summary>
                Translate the subprogram rooted at the <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> <paramref name="subprogram" />.
            </summary>
            <param name="subprogram">The subprogram to translate.</param>
            <param name="optimization">The optimization mode requested for this translation. See <see cref="T:Microsoft.ProgramSynthesis.Translation.OptimizeFor" />.</param>
            <param name="caller">
                The <see cref="T:Microsoft.ProgramSynthesis.Translation.Translator`5" /> that generated
                the call.
            </param>
            <returns>
                If the translation was successful, a <see cref="T:Microsoft.ProgramSynthesis.Translation.SubprogramTranslationResult" />, wrapped in an
                <see cref="T:Microsoft.ProgramSynthesis.Utils.Optional`1" />,
                If the subprogram could not be successfully translated, returns <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" />.
            </returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.ISubprogramTranslator`5.Name">
            <summary>
                An informative/descriptive name for this subprogram
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.Module">
            <summary>
                A Module can be thought of as a mapping from identifiers to representations of computations in the target language.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Module.AppendAuxiliaryCode(System.String,System.String)">
            <summary>
                Add arbitrary text as auxiliary code. This code will be output before the code for any of the
                generated functions. The default implementation throws an exception. Subclasses need to implement
                this method as required.
            </summary>
            <param name="codeUnitName">The name for this unit of code.</param>
            <param name="auxiliaryCode">A representation of the auxiliary code.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Module.ClearAuxiliaryCode">
            <summary>
                Clears any code added via <see cref="M:Microsoft.ProgramSynthesis.Translation.Module.AppendAuxiliaryCode(System.String,System.String)" /> to this module.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Module.TryGetAuxiliaryCode(System.String,System.String@)">
            <summary>
                Retrieve a previously registered auxiliary code unit. See <see cref="M:Microsoft.ProgramSynthesis.Translation.Module.AppendAuxiliaryCode(System.String,System.String)" />.
            </summary>
            <param name="name">The name used to previously register the code unit using <see cref="M:Microsoft.ProgramSynthesis.Translation.Module.AppendAuxiliaryCode(System.String,System.String)" />.</param>
            <param name="code">An out parameter for the returned code.</param>
            <returns>
                <c>true</c> if the lookup was a success (and the value of <paramref name="code" /> is set to the desired code.
                <c>false</c> otherwise, and <paramref name="code" /> is not guaranteed to be set to anything meaningful.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Module.Unbind(System.String)">
            <summary>
                Unbind <paramref name="fNameToRemove"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Module.GenerateCode(Microsoft.ProgramSynthesis.Translation.OptimizeFor)">
            <summary>
                Generates code for all the functions that have been bound to a name in this module.
            </summary>
            <param name="optimization">The optimization setting to use while generating code.</param>
            <returns>A representation of the code for this module.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Module.GenerateUnisolatedCode(Microsoft.ProgramSynthesis.Translation.OptimizeFor)">
            <summary>
                Generates unisolated code, i.e., code that executes/lives in the global namespace,
                provided subclasses override this method appropriately.
                The default behavior is to call <see cref="M:Microsoft.ProgramSynthesis.Translation.Module.GenerateCode(Microsoft.ProgramSynthesis.Translation.OptimizeFor)" />.
            </summary>
            <param name="optimization">The optimization setting to use while generating code.</param>
            <returns>A representation of the code corresponding to this module.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Module.ResolveType(System.Type)">
            <summary>
                Should be overriden by language translator if they want the mapping from C# type to target language type
            </summary>
            <param name="originalType"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Module.AddImports(System.String[])">
            <summary>
                Add the given external module names to the list of imports in this module.
                The default assumes that all external modules are added once when an instance of this is created.
                Hence, this function does nothing.
            </summary>
            <param name="imports">The module names on which the code in this module depends upon</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Module.SetModuleUsesHeader">
            <summary>
                Set the variable that indicates if the code in this module uses the header
                The default does nothing since the default assumes that header is always used.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Module.Optimize(Microsoft.ProgramSynthesis.Translation.IModuleOptimizer)">
            <summary>
                Apply the interprocedural optimization on this module.
            </summary>
            <param name="optimizer">The optimizer to apply.</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.OpaqueGeneratedFunction">
            <summary>
                A class that represents an opaque generated function.
                Useful when the definition of the function in the target
                language is already known or is easier to generated directly,
                rather than go through the SSA mechanism of <see cref="T:Microsoft.ProgramSynthesis.Translation.SSAGeneratedFunction" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.OpaqueGeneratedFunction.DynamicCode">
            <summary>
                The representation of the code for the function.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.OpaqueGeneratedFunction.#ctor(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Utils.Record{System.String,System.Type}},System.Type,Microsoft.ProgramSynthesis.Utils.CodeBuilder,Microsoft.ProgramSynthesis.Utils.CodeBuilder)">
            <summary>
                Constructor.
            </summary>
            <param name="parameters">The name and types of the parameters to this function.</param>
            <param name="returnType">The return type of this function.</param>
            <param name="staticCode">The static code for this function.</param>
            <param name="dynamicCode">The dynamic code for this function.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.OpaqueGeneratedFunction.#ctor(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Utils.Record{System.String,System.Type}},System.Type,Microsoft.ProgramSynthesis.Utils.CodeBuilder)">
            <summary>
                Constructor.
            </summary>
            <param name="parameters">The name and types of the parameters to this function.</param>
            <param name="returnType">The return type of this function.</param>
            <param name="dynamicCode">The dynamic code for this function.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.OpaqueGeneratedFunction.GenerateCode(System.String,Microsoft.ProgramSynthesis.Translation.OptimizeFor)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.OptimizeFor">
            <summary>
                An enumerated type that describes what to optimize for during translation.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.OptimizeFor.Nothing">
            <summary>
                No optimizations.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.OptimizeFor.Readability">
            <summary>
                Optimize for readability. The translated code may not match c# semantics on inputs that generate null
                in c#. The generated code may throw exceptions in these cases.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.OptimizeFor.Performance">
            <summary>
                Optimize for performance.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.PowerQuery.IEscapePowerQueryM">
            <summary>
                Interface for escaping PowerQuery M identifiers, strings, etc.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.PowerQuery.IEscapePowerQueryM.EscapeIdentifier(System.String)">
            <summary>
                Escapes an identifier (such as step name).
            </summary>
            <param name="identifier">The identifier.</param>
            <returns>The escaped identifier.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.PowerQuery.IEscapePowerQueryM.EscapeFieldIdentifier(System.String)">
            <summary>
                Escapes a field identifier (i.e., column name).
            </summary>
            <param name="fieldIdentifier">The field identifier.</param>
            <returns>The escaped field identifier.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.PowerQuery.IEscapePowerQueryM.EscapeString(System.String)">
            <summary>
                Escapes a string.
            </summary>
            <param name="s">The string.</param>
            <returns>The escaped string.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.PowerQuery.ILocalizedPowerQueryMStrings">
            <summary>
                Interface for communicating the desired variable names for Power Query M translation in order to match the client's
                localization settings. This base type only provides the localized string for the source; each DSL defines a subtype
                with the other strings it needs localized for its M translation.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.PowerQuery.ILocalizedPowerQueryMStrings.Source">
            <summary>
                Step name for the initial source step.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.PowerQuery.MTableFunctionName">
            <summary>
                Constants for names of M functions under Table.* which are used in PROSE.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.PowerQuery.MTextFunctionName">
            <summary>
                Constants for names of M functions under Text.* which are used in PROSE.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.PowerQuery.MTextFunctionName.Invoke(System.Collections.Generic.IReadOnlyList{System.String})">
            <summary>
                Builds an invocation of this function with the specified arguments.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.PowerQuery.MSplitterFunctionName">
            <summary>
                Constants for names of M functions under Splitter.* which are used in PROSE.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.PowerQuery.MListFunctionName">
            <summary>
                Constants for names of M functions under List.* which are used in PROSE.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.PowerQuery.MLinesFunctionName">
            <summary>
                Constants for names of M functions under Lines.* which are used in PROSE.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.PowerQuery.MNumberFunctionName">
            <summary>
                Constants for names of M functions under Number.* which are used in PROSE.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.PowerQuery.MCsvFunctionName">
            <summary>
                Constants for names of M functions under Csv.* which are used in PROSE.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.PowerQuery.MValueFunctionName">
            <summary>
                Constants for names of M functions under Value.* which are used in PROSE.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.PowerQuery.PowerQueryMCodeBuilder">
            <summary>
                Variant of <see cref="T:Microsoft.ProgramSynthesis.Utils.CodeBuilder" /> for building a Power Query M <c>let</c> expression for refining a table from
                a source.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.PowerQuery.PowerQueryMCodeBuilder.#ctor(System.String,Microsoft.ProgramSynthesis.Translation.PowerQuery.ILocalizedPowerQueryMStrings,Microsoft.ProgramSynthesis.Translation.PowerQuery.IEscapePowerQueryM,System.Collections.Generic.IReadOnlyDictionary{Microsoft.ProgramSynthesis.Translation.PowerQuery.MTableFunctionName,System.String},System.Collections.Generic.HashSet{System.String},System.String)">
            <summary>
                Construct a <see cref="T:Microsoft.ProgramSynthesis.Translation.PowerQuery.PowerQueryMCodeBuilder" /> for building the string of a single M <c>let</c> statement. Call
                <see cref="M:Microsoft.ProgramSynthesis.Translation.PowerQuery.PowerQueryMCodeBuilder.AddStep(Microsoft.ProgramSynthesis.Translation.PowerQuery.MTableFunctionName,System.Collections.Generic.IEnumerable{System.String},System.String)" /> zero or more times and then <see cref="M:Microsoft.ProgramSynthesis.Translation.PowerQuery.PowerQueryMCodeBuilder.GetCode" /> to get the generated string.
            </summary>
            <param name="initialTableCode">M code for loading the table from the source.</param>
            <param name="localizedStrings">The localized strings specific to the functions that may be used by this.</param>
            <param name="escape">The interface to escape identifier.</param>
            <param name="stepNames">
                Mapping from <c>Table.</c> functions to the localized variable name to be used for them.
                Usually generated using <paramref name="localizedStrings" />.
            </param>
            <param name="forbiddenStepNames">Step names which should not be used in the query.</param>
            <param name="sourceStepName">
                Step name for the first step. If <c>null</c>, defaults to <see cref="P:Microsoft.ProgramSynthesis.Translation.PowerQuery.ILocalizedPowerQueryMStrings.Source" />.
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.PowerQuery.PowerQueryMCodeBuilder.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},Microsoft.ProgramSynthesis.Translation.PowerQuery.IEscapePowerQueryM,System.Collections.Generic.IReadOnlyDictionary{Microsoft.ProgramSynthesis.Translation.PowerQuery.MTableFunctionName,System.String},System.Collections.Generic.HashSet{System.String})">
            <summary>
                Construct a <see cref="T:Microsoft.ProgramSynthesis.Translation.PowerQuery.PowerQueryMCodeBuilder" /> for building the string of a single M <c>let</c> statement. Call
                <see cref="M:Microsoft.ProgramSynthesis.Translation.PowerQuery.PowerQueryMCodeBuilder.AddStep(Microsoft.ProgramSynthesis.Translation.PowerQuery.MTableFunctionName,System.Collections.Generic.IEnumerable{System.String},System.String)" /> zero or more times and then <see cref="M:Microsoft.ProgramSynthesis.Translation.PowerQuery.PowerQueryMCodeBuilder.GetCode" /> to get the generated string.
            </summary>
            <param name="initialSteps">M code for loading the table from the source.</param>
            <param name="escape">The interface to escape identifier.</param>
            <param name="stepNames">
                Mapping from <c>Table.</c> functions to the localized variable name to be used for them.
                Usually generated using <paramref name="localizedStrings" />.
            </param>
            <param name="forbiddenStepNames">Step names which should not be used in the query.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.PowerQuery.PowerQueryMCodeBuilder.LastStepName">
            <summary>
                The last step name.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.PowerQuery.PowerQueryMCodeBuilder.EscapedLastStepName">
            <summary>
                The M code for accessing the value of the last step.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.PowerQuery.PowerQueryMCodeBuilder.AddStep(Microsoft.ProgramSynthesis.Translation.PowerQuery.MTableFunctionName,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
                Add a call to a <c>Table.</c> function based on the previous value.
            </summary>
            <param name="funcName">The call will be to <c>Table.<paramref name="funcName" />()</c>.</param>
            <param name="arguments">
                The arguments to the function, except for the first argument which is always the value computed
                by the previous step (starting with the source provided to the constructor).
            </param>
            <param name="stepName">
                Optional name of the step to use instead of looking up <paramref name="funcName" /> in the
                dictionary of localized strings provided to the constructor.
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.PowerQuery.PowerQueryMCodeBuilder.AddStep(System.String,System.String,System.Boolean)">
            <summary>
                Adds a step that has <paramref name="stepName" /> and <paramref name="expression" />.
            </summary>
            <param name="expression">The expression (body) of the step.</param>
            <param name="stepName">The step name.</param>
            <param name="helper">If <c>true</c>, this step will be ignored when looking for the last step.</param>
            <returns>
                The name of the new step (will try to use <paramref name="stepName" />, but it might already be used).
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.PowerQuery.PowerQueryMCodeBuilder.AddConvertListStep(Microsoft.ProgramSynthesis.Translation.PowerQuery.MTableFunctionName)">
            <summary>
                Adds a step to convert a list.
            </summary>
            <param name="funcName">The function name.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.PowerQuery.PowerQueryMCodeBuilder.EscapeIdentifier(System.String)">
            <summary>
                Escapes an identifier.
            </summary>
            <param name="identifier">The identifier.</param>
            <returns>The escaped identifier.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.PowerQuery.PowerQueryMCodeBuilder.FormatFieldIdentifier(System.String)">
            <summary>
                Escapes a field identifier and format it.
            </summary>
            <param name="fieldIdentifier">The field identifier.</param>
            <returns>The formatted field identifier.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.PowerQuery.PowerQueryMCodeBuilder.EscapeString(System.String)">
            <summary>
                Escapes a string.
            </summary>
            <param name="s">The string.</param>
            <returns>The escaped string.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.PowerQuery.PowerQueryMCodeBuilder.GetCode">
            <summary>
                Get the generated code based on the given initial code and steps added using <see cref="M:Microsoft.ProgramSynthesis.Translation.PowerQuery.PowerQueryMCodeBuilder.AddStep(Microsoft.ProgramSynthesis.Translation.PowerQuery.MTableFunctionName,System.Collections.Generic.IEnumerable{System.String},System.String)" />.
            </summary>
            <returns>A <c>string</c> of M code that has been built up.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.Python.PythonExpressionUtils">
            <summary>
                A static utility class containing helper functions for creating Python expressions as SSAValues.
                Known issue: Expressions of the form a.b(c) have to created as a.(b(c)) rather than (a.b)(c)
                because SSAFunctionApplication currently needs a string as a function name. Depending on how the 
                terms are used, this is usually a nonissue if only sound and complete expressions are translated.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonExpressionUtils.ListType">
            <summary>
                Each python expression represented as SSAValue is assigned a type.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonExpressionUtils.Regex">
            <summary>
                The three modules that we use in our translation: regex, datetime, decimal
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonExpressionUtils.MkLiteral(System.Decimal)">
            <summary>
                Helpers to create a SSALiteral representing a Python literal.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonExpressionUtils.None">
            <summary>
                Some commonly used constants in Python programs.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonExpressionUtils.MkFunApp(System.Type,System.String,Microsoft.ProgramSynthesis.Translation.SSAValue[])">
            <summary>
                Helper function to make a function application term.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonExpressionUtils.RegexDot(Microsoft.ProgramSynthesis.Translation.SSAValue)">
            <summary>
                Helper function to make expressions that work on regex module.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonExpressionUtils.Next(Microsoft.ProgramSynthesis.Translation.SSAValue)">
            <summary>
                Helper function to make expression that involve iterables/lists.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonExpressionUtils.DDecimal(Microsoft.ProgramSynthesis.Translation.SSAValue)">
            <summary>
                Helper function to make expression that involve decimals.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonExpressionUtils.MathDot(Microsoft.ProgramSynthesis.Translation.SSAValue)">
            <summary>
                Helper function to make expression that involve math.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonExpressionUtils.Strip(Microsoft.ProgramSynthesis.Translation.SSAValue,System.String)">
            <summary>
                Helpers for creating string manipulation expressions.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonExpressionUtils.And(Microsoft.ProgramSynthesis.Translation.SSAValue[])">
            <summary>
                Helpers for creating Boolean expressions.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonExpressionUtils.Abs(Microsoft.ProgramSynthesis.Translation.SSAValue)">
            <summary>
                Helpers for creating Arithmetic expressions.
                Note add is overloaded, and can also used to concatenate strings.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonExpressionUtils.Dot(Microsoft.ProgramSynthesis.Translation.SSAValue[])">
            <summary>
                Helpers to create "polymorphic" expressions.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonExpressionUtils.DatetimeDot(Microsoft.ProgramSynthesis.Translation.SSAValue)">
            <summary>
                Helpers to create datetime expressions.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonExpressionUtils.ToPython(Microsoft.ProgramSynthesis.Translation.SSAValue,System.String,System.Collections.Generic.HashSet{Microsoft.ProgramSynthesis.Translation.SSARegister},System.Boolean)">
            <summary>
                Convert this SSAValue expression to Python.  NOTE: The variable or function names used in the 
                expression are *not* prefixed by self or any module name.
            <param name="className">Class name to prepend to function names if prefixNameWithClass is true</param>
            <param name="useClass">Flag indicating if names should be prefixed with class name/self.</param>
            <param name="constantRegisters">SSARegisters whose names should be prefixed with self (and not className)</param>
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.Python.PythonImports">
            <summary>
                A translation helper class to maintain and generate code for a list of Python imports.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonImports.#ctor">
            <summary>
                Creates a new instance of <see cref="T:Microsoft.ProgramSynthesis.Translation.Python.PythonImports" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonImports.#ctor(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Collections.Generic.IReadOnlyCollection{System.String}}})">
            <summary>
                Creates a new instance of <see cref="T:Microsoft.ProgramSynthesis.Translation.Python.PythonImports" />.
            </summary>
            <param name="imports">The list of imports.</param>
            <param name="fromImports">THe list of from imports.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonImports.AddImport(System.String)">
            <summary>
                Add a new import (i.e., `import <see cref="!:name" />>`).
            </summary>
            <param name="name">The name to import.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonImports.AddImports(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Add new imports (i.e., `import ...`).
            </summary>
            <param name="names">The names to import (each name corresponds to one import statement).</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonImports.AddImports(System.String[])">
            <summary>
                Add new imports (i.e., `import ...`).
            </summary>
            <param name="names">The names to import (each name corresponds to one import statement).</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonImports.Clear">
            <summary>
                Clear all imports.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonImports.AddFromImport(System.String,System.String)">
            <summary>
                Add a new from input (i.e., `from <see cref="!:fromName" /> import <see cref="!:name" />`).
                Note: All names imported from the same "from name" are grouped together.
            </summary>
            <param name="fromName">The name to import from.</param>
            <param name="name">The name to import.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonImports.AddFromImports(System.String,System.String[])">
            <summary>
                Add new from inputs (i.e., `from <see cref="!:fromName" /> import <see cref="!:names" />`).
                Note: All names imported from the same "from name" are grouped together.
            </summary>
            <param name="fromName">The name to import from.</param>
            <param name="names">The name to import.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonImports.AddFromImports(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Add new from inputs (i.e., `from <see cref="!:fromName" /> import <see cref="!:names" />`).
                Note: All names imported from the same "from name" are grouped together.
            </summary>
            <param name="fromName">The name to import from.</param>
            <param name="names">The name to import.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonImports.GetCode(System.Boolean,System.UInt32)">
            <summary>
                Generates Python code from the imports.
            </summary>
            <param name="separateFromImports">Whether to seperate (using a blank line) from imports.</param>
            <param name="ensureTrailingLines">The number of blank lines to ensure after the imports (if there are any).</param>
            <returns>The <see cref="T:Microsoft.ProgramSynthesis.Utils.CodeBuilder" /> with import statements code.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonImports.Merge(Microsoft.ProgramSynthesis.Translation.Python.PythonImports)">
            <summary>
                Merges this imports with another imports and returns the resulting imports.
                (Does not modify this or other imports).
            </summary>
            <param name="other">The other imports to merge.</param>
            <returns>The merged imports.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonImports.MergeWith(Microsoft.ProgramSynthesis.Translation.Python.PythonImports)">
            <summary>
                Merges other imports into this imports (and thus modifies this imports).
            </summary>
            <param name="other">The imports to merge.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.Python.PythonNameUtils.Operators">
            <summary>
                Reserved function names used for outputing operators.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonNameUtils.Operators.Prefix">
            <summary>
                Not an operator; the prefix string of all operator strings.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonNameUtils.Operators.LessThanOrEqualTo">
            <summary>
                <c>a &lt;= b</c>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonNameUtils.Operators.Add">
            <summary>
                <c>a + b</c>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonNameUtils.Operators.And">
            <summary>
                <c>a and b</c>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonNameUtils.Operators.Or">
            <summary>
                <c>a or b</c>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonNameUtils.Operators.IfThenElse">
            <summary>
                <c>b if a else c</c> (note the order is the normal order for if/then/else, not the Python order)
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonNameUtils.Operators.GetItem">
            <summary>
                <c>a[b]</c>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonNameUtils.Operators.Slice">
            <summary>
                <c>a[b:c]</c>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonNameUtils.Operators.SliceStartOnly">
            <summary>
                <c>a[b:]</c>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonNameUtils.Operators.SliceEndOnly">
            <summary>
                <c>a[:b]</c>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonNameUtils.Operators.MakeList">
            <summary>
                <c>[a,b,...]</c>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonNameUtils.Operators.Dot">
            <summary>
                <c>a.b.c.d....</c>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonNameUtils.Operators.ForInIf">
            <summary>
                <c>a for b in c if d</c>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonNameUtils.Operators.Tuple">
            <summary>
                <c>(a,b,...)</c>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonNameUtils.Operators.EqualTo">
            <summary>
                <c>a == b</c>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonNameUtils.Operators.NotEquals">
            <summary>
                <c>a != b</c>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonNameUtils.Operators.Assign">
            <summary>
                <c>a = b</c>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonNameUtils.Operators.Minus">
            <summary>
                <c>a - b</c>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonNameUtils.Operators.Times">
            <summary>
                <c>a * b</c>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonNameUtils.Operators.DivideBy">
            <summary>
                <c>a / b</c>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonNameUtils.Operators.IntDivideBy">
            <summary>
                <c>a // b</c>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonNameUtils.Operators.NotIn">
            <summary>
                <c>a not in b</c>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonNameUtils.Operators.Mod">
            <summary>
                <c>a % b</c>
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonNameUtils.Operators.MaxPrecValue">
            <summary>
                The maximum precedence value that can be assigned to an operator below.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonNameUtils.Operators.OpPrec">
            <summary>
               Operator precedence where lower number indicates lower precedence
               Source: https://docs.python.org/3/reference/expressions.html#operator-precedence
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonNameUtils.Operators.AcLikeOps">
            <summary>
               List of Operators op s.t. if op occurs as an immediate subterm of a term 
               op(... op(...), ...), then the subterm does not need an enclosing parenthesis
               All AC operators are included here, and then some.
               Note that Dot has to be included here because a.b.c is sometimes incorrectly
               generated as a.(b.c) for technical reasons.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonRegexUtils.ConvertToPythonRegEx(Microsoft.ProgramSynthesis.DslLibrary.RegularExpression)">
            <summary>
                Return string representation of each token in the given regular expression <paramref name="regEx"/>
                that is understood by Python regex module.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonRegexUtils.ConvertToPythonRegEx(System.Text.RegularExpressions.Regex)">
            <summary>
                Return string representation of a regex object <paramref name="regEx"/>
                that is understood by Python regex module.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonRegexUtils.ConvertToPythonRegExStr(Microsoft.ProgramSynthesis.DslLibrary.RegularExpression,System.String@)">
            <summary>
                Return string representation of the combined tokens in regular expression <paramref name="regEx"/>
                that is understood by Python regex module.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.Python.PythonSnippet">
            <summary>
                The Python snippet of code that is designed such that two snippets can be easily merged
                into a new snippet, without repeating the import statements or return expression.
                
                The snippets have the following form:
                [IMPORT STATEMENTS]
                
                [CODE BLOCK]
                
                [RETURN VARIABLE]
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonSnippet.#ctor(Microsoft.ProgramSynthesis.Translation.Python.PythonImports,System.String,System.String,System.String)">
            <summary>
                Creates a new Python snippet.
            </summary>
            <param name="imports">The list of imports.</param>
            <param name="body">The code body/block.</param>
            <param name="returnVariable">The return variable.</param>
            <param name="expectPrependReturnVariable">
                The expected return variable of a potential prepended block in case of merging.
            </param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.Python.PythonSnippet.Imports">
            <summary>
                The list of imports.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.Python.PythonSnippet.Body">
            <summary>
                The code body/block.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.Python.PythonSnippet.ReturnVariable">
            <summary>
                The return variable.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.Python.PythonSnippet.ExpectPrependReturnVariable">
            <summary>
                The expected return variable of a potential prepended block in case of merging.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonSnippet.Merge(Microsoft.ProgramSynthesis.Translation.Python.PythonSnippet)">
            <summary>
                Merges this snippet with another snippet and returns the resulting snippet.
                (This and the other snippet remain unmodified).
            </summary>
            <param name="other">The other snippet to merge.</param>
            <returns>The result of merging two snippets.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonSnippet.GetCode(System.Boolean,System.UInt32,System.UInt32)">
            <summary>
                Gets string code from the snippet.
            </summary>
            <param name="separateFromImports">Whether to separate ordinary and from imports.</param>
            <param name="spacesAfterImports">The number of empty-lines after the imports.</param>
            <param name="spacesBeforeReturn">THe number of empty-lines before the return expression.</param>
            <returns>The code string.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonHeaderModule.GenerateCode(Microsoft.ProgramSynthesis.Translation.OptimizeFor)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonHeaderModule.GenerateUnisolatedCode(Microsoft.ProgramSynthesis.Translation.OptimizeFor)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonHeaderModule.AppendAuxiliaryCode(System.String,System.String)">
            <summary>
                Add arbitrary text as auxiliary code. This code will be output before the code for any of the
                generated functions. The default implementation throws an exception. Subclasses need to implement
                this method as required.
            </summary>
            <param name="codeUnitName">The name for this unit of code.</param>
            <param name="auxiliaryCode">A representation of the auxiliary code.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonModule.ClearBindings">
            <summary>
                Reset the imports and the Boolean flag ModuleUsesHeader.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonModule.GenerateCode(Microsoft.ProgramSynthesis.Translation.OptimizeFor)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonModule.GenerateUnisolatedCode(Microsoft.ProgramSynthesis.Translation.OptimizeFor)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonModule.GeneratePysparkImports(System.Collections.Generic.IReadOnlyList{System.String})">
            <summary>
                Generates code for import pyspark modules wrapped inside try-catch
            </summary>
            <param name="pysparkImports"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonModule.AppendAuxiliaryCode(System.String,System.String)">
            <summary>
                Add arbitrary text as auxiliary code. This code will be output before the code for any of the
                generated functions. The default implementation throws an exception. Subclasses need to implement
                this method as required.
            </summary>
            <param name="codeUnitName">The name for this unit of code.</param>
            <param name="auxiliaryCode">A representation of the auxiliary code.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonModule.AddImports(System.String[])">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonModule.SetModuleUsesHeader">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.Python.PythonTarget">
            <summary>
                Target of the translation.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonTarget.Auto">
            <summary>
                Let the translator automatically decide.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonTarget.Library">
            <summary>
                PROSE library.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonTarget.Pandas">
            <summary>
                pandas library.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Python.PythonTarget.PySpark">
            <summary>
                PySpark library.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.Python.PythonGeneratedFunction._useClass">
            <summary> Is this function enclosed by a outer class? </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonGeneratedFunction.GenerateCode(System.String,Microsoft.ProgramSynthesis.Translation.OptimizeFor)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.Python.PythonTranslator`4">
            <summary>
                A base translator for Python code generation. DSL specific translators need to subclass
                <see cref="T:Microsoft.ProgramSynthesis.Translation.Python.PythonTranslator`4" />. Like
                <see cref="T:Microsoft.ProgramSynthesis.Translation.Translator`5" />, this
                class isn't thread safe as well.
            </summary>
            <typeparam name="TPythonModule">The type of <see cref="T:Microsoft.ProgramSynthesis.Translation.Python.PythonModule" /> that this translator generates.</typeparam>
            <typeparam name="TProgram">The type of the program to translate.</typeparam>
            <typeparam name="TProgramInput">The type of the input to <typeparamref name="TProgram" />.</typeparam>
            .
            <typeparam name="TProgramOutput">The type of the output generated by <typeparamref name="TProgram" />.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonTranslator`4.NormalizeVariableName(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonTranslator`4.CreateModule(System.String,System.String,System.String)">
            <summary>
                Creates a new module with the given name.
            </summary>
            <param name="moduleName">The name of the module to create.</param>
            <param name="headerModuleReferenceName">The name of the header module that is references by this module.</param>
            <param name="aliasName">The name of the alias to be used for header module reference name. If passed null, will reuse
            whatever is passed as <paramref name="headerModuleReferenceName"/></param>
            <returns>A new <see cref="T:Microsoft.ProgramSynthesis.Translation.Module"/> named <see cref="!:moduleName" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonTranslator`4.Translate(`1,System.String,System.String,Microsoft.ProgramSynthesis.Translation.OptimizeFor)">
            <summary>
                Generates a representation of the code corresponding to a program <paramref name="root" />. The function will be
                named <paramref name="generatedFunctionName" />, and the generated code will be unisolated.
            </summary>
            <param name="root">The program to translate.</param>
            <param name="generatedFunctionName">
                The identifier for the function generated for the program
                <paramref name="root" />.
            </param>
            <param name="headerModuleName">The name of the header module.</param>
            <param name="optimization">The <see cref="T:Microsoft.ProgramSynthesis.Translation.OptimizeFor" /> option.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonTranslator`4.GenerateHeaderModule(`1,System.String)">
            <summary>
                Generates a module containing the header (if any) for
                the given program <see cref="!:p" />.
                The header can include any definitions required for the generated
                program corresponding to <see cref="!:p" /> to execute.
            </summary>
            <param name="p">A generated program</param>
            <param name="headerModuleName">The name of the header module.</param>
            <returns>
                A <see cref="T:Microsoft.ProgramSynthesis.Translation.Module" /> which contains the definitions that all code generated by this translator can
                implicitly depend on.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonTranslator`4.GenerateLiteralRepresentation(System.Object,System.Type)">
            <summary>
                Generates the representation of the literal in the target language.
            </summary>
            <param name="literalValue">An <see cref="T:System.Object" /> representing the value of the literal.</param>
            <param name="literalType">The type of the literal.</param>
            <returns>
                A representation of <see cref="!:literalValue" /> interpreted as a value
                of the type <see cref="!:literalType" /> in the target language.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonTranslator`4.GenerateFunctionBody(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Utils.Record{System.String,System.Type}},System.Type,Microsoft.ProgramSynthesis.AST.ProgramNode,System.Boolean,Microsoft.ProgramSynthesis.Translation.OptimizeFor)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonTranslator`4.Translate(`1,`0,Microsoft.ProgramSynthesis.Translation.OptimizeFor)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.SSAFunctionApplication">
            <summary>
                An RValue that is represented by a function application.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SSAFunctionApplication.FunctionArguments">
            <summary>
                The arguments to this function application.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SSAFunctionApplication.FunctionName">
            <summary>
                The language specific name of the function being applied.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SSAFunctionApplication.IsFunctionLocal">
            <summary>
                Flag indicating if the function being applied is defined locally in the same enclosing module.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSAFunctionApplication.#ctor(System.Type,System.String,Microsoft.ProgramSynthesis.Translation.SSAValue[])">
            <summary>
                Constructor.
            </summary>
            <param name="valueType">The type of the <see cref="T:Microsoft.ProgramSynthesis.Translation.SSARValue" />.</param>
            <param name="functionName">The language specific name of the function being applied.</param>
            <param name="arguments">
                The <see cref="T:Microsoft.ProgramSynthesis.Translation.SSAValue" />s corresponding to the arguments to
                <paramref name="functionName" />.
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSAFunctionApplication.#ctor(System.Type,System.String,System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Translation.SSAValue},System.Boolean)">
            <summary>
                Constructor.
            </summary>
            <param name="valueType">The type of the <see cref="T:Microsoft.ProgramSynthesis.Translation.SSARValue" />.</param>
            <param name="functionName">The language specific name of the function being applied.</param>
            <param name="arguments">
                The <see cref="T:Microsoft.ProgramSynthesis.Translation.SSAValue" />s corresponding to the arguments to
                <paramref name="functionName" />.
            </param>
            <param name="isFunctionLocal">
                Flag indicating if the function being applied is defined locally in the same enclosing module.
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSAFunctionApplication.Equals(Microsoft.ProgramSynthesis.Translation.SSAFunctionApplication)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
            <returns>true if the specified object  is equal to the current object; otherwise, false.</returns>
            <param name="other">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSAFunctionApplication.Equals(Microsoft.ProgramSynthesis.Translation.SSAValue)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
            <returns>true if the specified object  is equal to the current object; otherwise, false.</returns>
            <param name="other">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSAFunctionApplication.GetHashCode">
            <summary>
                Gets the hash code for this object.
            </summary>
            <returns>The hash code for this object.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSAFunctionApplication.ToString">
            <summary>Returns a string that represents the current object.</summary>
            <returns>A string that represents the current object.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SSAFunctionApplication.AllDependencies">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSAFunctionApplication.SubstituteArgument(Microsoft.ProgramSynthesis.Translation.SSAValue,Microsoft.ProgramSynthesis.Translation.SSAValue)">
            <summary>
                Substitutes an argument in the argument list of this function.
            </summary>
            <param name="argument">The argument to substitute.</param>
            <param name="substitution">The value to substitute in.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSAFunctionApplication.Substitute(Microsoft.ProgramSynthesis.Translation.SSARegister,Microsoft.ProgramSynthesis.Translation.SSAValue)">
            <summary>
                Substitutes all occurences of <paramref name="register" /> with <paramref name="newValue" />.
            </summary>
            <param name="register">The register to substitute.</param>
            <param name="newValue">The new value to substitute in place of the register.</param>
            <returns>
                A new <see cref="T:Microsoft.ProgramSynthesis.Translation.SSARValue" /> which is identical to <c>this</c>, but with all occurences of
                <paramref name="register" /> substituted with <paramref name="newValue" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSAFunctionApplication.SubstituteInPlace(Microsoft.ProgramSynthesis.Translation.SSARegister,Microsoft.ProgramSynthesis.Translation.SSAValue)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.SSAGeneratedFunction">
            <summary>
                A class that contains the generated function as a sequence of SSA steps, which
                can then be translated to the target language.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSAGeneratedFunction.Optimize(Microsoft.ProgramSynthesis.Translation.IOptimizer)">
            <summary>
                Performs any language specific optimizations.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.SSALiteral">
            <summary>
                Represents a literal value in the SSA Graph.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SSALiteral.LiteralString">
            <summary>
                The literal represented as a language specific string.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSALiteral.#ctor(System.Type,System.String)">
            <summary>
                Constructor.
            </summary>
            <param name="valueType">The type of the <see cref="T:Microsoft.ProgramSynthesis.Translation.SSARValue" />.</param>
            <param name="literalString">Any language specific information that is part of this <see cref="T:Microsoft.ProgramSynthesis.Translation.SSARValue" />.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSALiteral.Equals(Microsoft.ProgramSynthesis.Translation.SSALiteral)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
            <returns>true if the specified object  is equal to the current object; otherwise, false.</returns>
            <param name="other">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSALiteral.Equals(Microsoft.ProgramSynthesis.Translation.SSAValue)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
            <returns>true if the specified object  is equal to the current object; otherwise, false.</returns>
            <param name="other">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSALiteral.GetHashCode">
            <summary>
                Gets the hash code for this object.
            </summary>
            <returns>The hash code for this object.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSALiteral.ToString">
            <summary>Returns a string that represents the current object.</summary>
            <returns>A string that represents the current object.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSALiteral.Substitute(Microsoft.ProgramSynthesis.Translation.SSARegister,Microsoft.ProgramSynthesis.Translation.SSAValue)">
            <summary>
                Substitutes all occurences of <paramref name="register" /> with <paramref name="newValue" />.
            </summary>
            <param name="register">The register to substitute.</param>
            <param name="newValue">The new value to substitute in place of the register.</param>
            <returns>
                A new <see cref="T:Microsoft.ProgramSynthesis.Translation.SSARValue" /> which is identical to <c>this</c>, but with all occurences of
                <paramref name="register" /> substituted with <paramref name="newValue" />.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.SSARegister">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Translation.SSARegister" /> represents an LValue in the SSA Graph.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SSARegister.Name">
            <summary>
                The name for this <see cref="T:Microsoft.ProgramSynthesis.Translation.SSARegister" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SSARegister._desiredName">
            <summary>
                The name, if non-null, we wish to be used in code for this <see cref="T:Microsoft.ProgramSynthesis.Translation.SSARegister" />.
                The VariableNameOptimizer simplifies this name while ensuring it does not conflict with any live variable.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSARegister.#ctor(System.Type)">
            <summary>
                Constructor.
                Assigns a unique name for this <see cref="T:Microsoft.ProgramSynthesis.Translation.SSARegister" />.
            </summary>
            <param name="valueType">The type of values that this <see cref="T:Microsoft.ProgramSynthesis.Translation.SSARegister" /> can hold.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSARegister.#ctor(System.String,System.Type,System.String)">
            <summary>
                Constructor.
            </summary>
            <param name="name">The name of this <see cref="T:Microsoft.ProgramSynthesis.Translation.SSARegister" />.</param>
            <param name="type">The type of values that this <see cref="T:Microsoft.ProgramSynthesis.Translation.SSARegister" /> can hold.</param>
            <param name="desiredName">The desired name of this <see cref="T:Microsoft.ProgramSynthesis.Translation.SSARegister" />.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSARegister.CloneWithNewName(System.String)">
            <summary>
            Clones this instance of SSARegister with newName. It retains the property StepWhereDefined but
            recreate ImmediateUpLinks and ImmediateDownLinks list, so the up and down links of cloned object
            won't change if original object's links change. Note that the actual uplinks and downlinks are
            still the same as original object.
            </summary>
            <param name="newName"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSARegister.Equals(Microsoft.ProgramSynthesis.Translation.SSARegister)">
            <summary>Indicates whether the current object is equal to another object of the same type.</summary>
            <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSARegister.Equals(Microsoft.ProgramSynthesis.Translation.SSAValue)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSARegister.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSARegister.GetName">
            <summary>Returns a string that should be used as name of this register in code.</summary>
            <returns>A string that names this register.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSARegister.SetDesiredName(System.String)">
            <summary>Set the _desiredName to the given name.</summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSARegister.HasAGivenName">
            <summary>Returns true if this SSARegister was given a desired (print) name.</summary>
            <returns>A Boolean value indicating if this SSARegister was given a desired (print) name.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSARegister.ToString">
            <summary>Returns a string that represents the current object.</summary>
            <returns>A string that represents the current object.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.SSARValue">
            <summary>
                An abstract base class for RValues in the SSA graph.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSARValue.#ctor(System.Type,System.String)">
            <summary>
                Constructor.
            </summary>
            <param name="valueType">The type of the <see cref="T:Microsoft.ProgramSynthesis.Translation.SSARValue"/>.</param>
            <param name="languageSpecificString">Any language specific information that is part of this <see cref="T:Microsoft.ProgramSynthesis.Translation.SSARValue"/>.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSARValue.Substitute(Microsoft.ProgramSynthesis.Translation.SSARegister,Microsoft.ProgramSynthesis.Translation.SSAValue)">
            <summary>
                Substitutes all occurences of <paramref name="register" /> with <paramref name="newValue" />.
            </summary>
            <param name="register">The register to substitute.</param>
            <param name="newValue">The new value to substitute in place of the register.</param>
            <returns>
                A new <see cref="T:Microsoft.ProgramSynthesis.Translation.SSARValue" /> which is identical to <c>this</c>, but with all occurences of
                <paramref name="register" /> substituted with <paramref name="newValue" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSARValue.SubstituteInPlace(Microsoft.ProgramSynthesis.Translation.SSARegister,Microsoft.ProgramSynthesis.Translation.SSAValue)">
            <summary>
                Same as <see cref="M:Microsoft.ProgramSynthesis.Translation.SSARValue.Substitute(Microsoft.ProgramSynthesis.Translation.SSARegister,Microsoft.ProgramSynthesis.Translation.SSAValue)" />, but does the substitution in place.
                1. Add <paramref name="newValue" /> into this's <see cref="!:ImmediateUpLinks" />.
                2. Add this in <paramref name="newValue" />'s <see cref="!:ImmediateDownLinks" />.
                3. Remove <paramref name="register" /> from this's <see cref="!:ImmediateUpLinks" />.
                4. Remove this from <paramref name="register" />'s <see cref="!:ImmediateDownLinks" />.
            </summary>
            <param name="register">The register to substitute</param>
            <param name="newValue">The new value to use</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSARValue.Delete">
            <summary>
                Delete this term.
                1. Remove this from the <see cref="!:ImmediateDownLinks" /> of 
                   every term in this's <see cref="!:ImmediateUpLinks" />.
                2. Remove this from the <see cref="!:ImmediateUpLinks" /> of 
                   every term in this's <see cref="!:ImmediateDownLinks" />.
                3. Clear this's <see cref="!:ImmediateUpLinks" />.
                4. Clear this's <see cref="!:ImmediateDownLinks" />.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.SSAStep">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Translation.SSAStep" /> represents a definition of an <see cref="T:Microsoft.ProgramSynthesis.Translation.SSARegister" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SSAStep.LValue">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.Translation.SSARegister" /> being defined in this SSA step.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SSAStep.RValue">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.Translation.SSAValue" /> used as the RValue in the definition of <see cref="P:Microsoft.ProgramSynthesis.Translation.SSAStep.LValue" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SSAStep.Comment">
            <summary>
                The string used as the comment for this value.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSAStep.#ctor(Microsoft.ProgramSynthesis.Translation.SSARegister,Microsoft.ProgramSynthesis.Translation.SSARValue,System.String)">
            <summary>
                Constructor
            </summary>
            <param name="lValue">The register that is being defined.</param>
            <param name="rValue">The RValue that <paramref name="lValue" /> is being defined with.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSAStep.ReplaceRValueInPlace(Microsoft.ProgramSynthesis.Translation.SSARValue,Microsoft.ProgramSynthesis.Translation.SSARValue)">
            <summary>
                Replace RValue by the given RValue in this step
            </summary>
            <param name="rValueOld">The current RValue of this step.</param>
            <param name="rValueNew">The new RValue of this step.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSAStep.ToString">
            <summary>Returns a string that represents the current object.</summary>
            <returns>A string that represents the current object.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.SSAValue">
            <summary>
                Represents a value (either an LValue or an RValue) in the SSA graph.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SSAValue.ValueType">
            <summary>
                The <see cref="T:System.Type" /> of this value.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SSAValue.ImmediateDownLinks">
            <summary>
                The set of values that directly depend on this value (not the transitive closure of downward dependencies).
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SSAValue.ImmediateUpLinks">
            <summary>
                The set of values this this value directly depends on (not the transitive closure of upward dependencies).
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SSAValue.AllUsers">
            <summary>
                The set of all <see cref="T:Microsoft.ProgramSynthesis.Translation.SSAValue" />s that depend (directly or via another <see cref="T:Microsoft.ProgramSynthesis.Translation.SSAValue" />) on
                <c>this</c> <see cref="T:Microsoft.ProgramSynthesis.Translation.SSAValue" />
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SSAValue.AllDependencies">
            <summary>
                The set of all <see cref="T:Microsoft.ProgramSynthesis.Translation.SSAValue" />s that <c>this</c> <see cref="T:Microsoft.ProgramSynthesis.Translation.SSAValue" /> depends on (directly or via
                another <see cref="T:Microsoft.ProgramSynthesis.Translation.SSAValue" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SSAValue.StepWhereDefined">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.Translation.SSAStep" /> where this value is defined.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SSAValue.IsPure">
            <summary>
                Currently, SSAValues may not have side-effects, so this is always <c>true</c>.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SSAValue.IsDeadCode">
            <summary>
                Checks if this value actually has any effect on the program result (whether the computation result is used and
                whether it has any side-effects).
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSAValue.Equals(Microsoft.ProgramSynthesis.Translation.SSAValue)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
            <returns>true if the specified object  is equal to the current object; otherwise, false.</returns>
            <param name="other">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSAValue.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
            <returns>true if the specified object  is equal to the current object; otherwise, false.</returns>
            <param name="other">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSAValue.GetHashCode">
            <summary>
                Gets the hash code for this object.
            </summary>
            <returns>The hash code for this object.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSAValue.ToString">
            <summary>Returns a string that represents the current object.</summary>
            <returns>A string that represents the current object.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.SSAVariable">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Translation.SSARValue" /> that is a variable.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SSAVariable.VariableName">
            <summary>
                The name of this variable.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSAVariable.#ctor(System.Type,System.String)">
            <summary>
                Constructor.
            </summary>
            <param name="variableType">The type of the <see cref="T:Microsoft.ProgramSynthesis.Translation.SSARValue" />.</param>
            <param name="variableName">Any language specific information that is part of this <see cref="T:Microsoft.ProgramSynthesis.Translation.SSARValue" />.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSAVariable.Equals(Microsoft.ProgramSynthesis.Translation.SSAVariable)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSAVariable.Equals(Microsoft.ProgramSynthesis.Translation.SSAValue)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSAVariable.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSAVariable.ToString">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSAVariable.Substitute(Microsoft.ProgramSynthesis.Translation.SSARegister,Microsoft.ProgramSynthesis.Translation.SSAValue)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.SubprogramTranslationResult">
            <summary>
                Represents the result of a subprogram translation.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SubprogramTranslationResult.FunctionBindings">
            <summary>
                The list of function bindings to be made in the translation module.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SubprogramTranslationResult.SSASteps">
            <summary>
                The list of <see cref="P:Microsoft.ProgramSynthesis.Translation.SubprogramTranslationResult.SSASteps" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SubprogramTranslationResult.ComputedValue">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.Translation.SSAValue"/> that represents the result of the computation represented by the translation.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SubprogramTranslationResult.Imports">
            <summary>
                The list of external packages used in the code in FunctionBindings, SSASteps, ComputedValue.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.SubprogramTranslator`5">
            <summary>
                An abstract base class providing implementations for the common properties for
                classes that implement <see cref="T:Microsoft.ProgramSynthesis.Translation.ISubprogramTranslator`5" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SubprogramTranslator`5.Translate(Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.Translation.OptimizeFor,Microsoft.ProgramSynthesis.Translation.Translator{`0,`1,`2,`3,`4})">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SubprogramTranslator`5.Name">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.SubstituteValues">
            <summary>
                A compiler pass for applying substitutions to the expressions in an <see cref="T:Microsoft.ProgramSynthesis.Translation.SSAGeneratedFunction" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SubstituteValues.#ctor(System.Collections.Generic.IReadOnlyDictionary{Microsoft.ProgramSynthesis.Translation.SSARValue,Microsoft.ProgramSynthesis.Translation.SSARValue})">
            <summary>
                Constructs a compiler pass that will apply the specified substitutions. The full expression tree (which really just
                means function calls in function arguments) is searched for the source of the substitutions. Once a replacement is
                made, that expression is not searched for further substitutions, and the replacement is done before checking the
                subexpressions to see if they match anything. This means that this operation is not guaranteed to be idempotent.
            </summary>
            <param name="substitutions">
                The substitutions where the keys are the expressions to search for and the values are the
                expressions to replace them with.
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SubstituteValues.Optimize(System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.Translation.SSAStep})">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.TargetLanguage">
            <summary>
                An enumerated type that describes the language to be targeted during translation.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.TargetLanguage.Python">
            <summary>
                The Python3 programming language.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.TargetLanguage.Pandas">
            <summary>
                The Pandas module for Python3.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.TargetLanguage.PySpark">
            <summary>
                The PySpark module for Python3.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.TargetLanguage.R">
            <summary>
                The R programming language.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.TargetLanguage.Java">
            <summary>
                The Java8 programming language.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.TargetLanguage.PowerQueryM">
            <summary>
                The PowerQuery M programming language.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.TargetLanguage.PowerApps">
            <summary>
                The Power Apps formula language.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.TargetLanguage.Excel">
            <summary>
                The Excel formula language.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.TargetLanguage.Sql">
            <summary>
                The SQL formula language.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.TargetLanguage.PowerAutomate">
            <summary>
                The Power Automate formula language.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.TargetLanguage.CSharp">
            <summary>
                The C# language.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.Translator`5">
            <summary>
                An Abstract Base Class for translating generated programs in some DSL
                into some target programming language. This class (and all its descendants)
                is not thread safe.
            </summary>
            <typeparam name="THeaderModule">The type of the header module.</typeparam>
            <typeparam name="TModule">The type of the main program module.</typeparam>
            <typeparam name="TProgram">The type of the typed program.</typeparam>
            <typeparam name="TProgramInput">The type of the input to the program.</typeparam>
            <typeparam name="TProgramOutput">The type of the output that the program generates.</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.Translator`5.TargetLanguage">
            <summary>
                The name of the target language
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.Translator`5.CodeContextStack">
            <summary>
                Intended for subclasses to store a representation the generated code.
                A stack is used to emulate different contexts.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`5.GenerateNewName(System.String,System.String)">
            <summary>
                Generates a fresh name
            </summary>
            <param name="prefix">A string that is to be used as prefix. This defaults to "t_" if <c>null</c> is given.</param>
            <param name="suffix">A string that is to be used as suffix. Defaults to the empty string.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`5.#ctor(Microsoft.ProgramSynthesis.Translation.TargetLanguage,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Constructor
            </summary>
            <param name="targetLanguage">The target language for translation.</param>
            <param name="boundNames">All names that are bound in the context and should not be modified by this translator.</param>
            <returns>An instance of this class.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`5.PushCodeContext">
            <summary>
                Pushes a new "context" for code. Useful for generating blocks of
                code that are to be manipulated atomically.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`5.PopCodeContext">
            <summary>
                Pops a code context. Generally useful for building nested blocks of
                code in combination with <see cref="M:Microsoft.ProgramSynthesis.Translation.Translator`5.PushCodeContext" />.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`5.PeekCodeContext">
            <summary>
                Does what the label says.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`5.AddStep(Microsoft.ProgramSynthesis.Translation.SSAStep)">
            <summary>
                Adds a step of computation (as an <see cref="T:Microsoft.ProgramSynthesis.Translation.SSAStep" />) to the current code context.
            </summary>
            <param name="step">The <see cref="T:Microsoft.ProgramSynthesis.Translation.SSAStep" /> to add.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`5.NormalizeVariableName(System.String)">
            <summary>
                Normalizes <paramref name="originalVariableName" /> based on language specific style.
            </summary>
            <param name="originalVariableName"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.Translator`5.OperatorMapping">
            <summary>
                Provides a mapping from names of DSL operators to functions/operators
                in the target language.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`5.GenerateHeaderModule(`2,System.String)">
            <summary>
                Generates a module containing the header (if any) for
                the given program <see cref="!:p" />.
                The header can include any definitions required for the generated
                program corresponding to <see cref="!:p" /> to execute.
            </summary>
            <param name="p">A generated program.</param>
            <param name="headerModuleName">The name of the header module.</param>
            <returns>
                A <typeparamref name="THeaderModule" /> which contains the definitions that all code
                generated by this translator can implicitly depend on.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`5.GenerateHeaderModule(System.String)">
            <summary>
                Generate a (possibly suboptimal) header that would work for all programs that
                may be translated using this translator.
            </summary>
            <param name="headerModuleName">The name of the header module.</param>
            <returns>
                A <typeparamref name="THeaderModule" /> which contains the definitions that all code
                generated by this translator can implicitly depend on.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`5.GenerateHeader(`2,System.String,Microsoft.ProgramSynthesis.Translation.OptimizeFor)">
            <summary>
                Generates a representation of the header directly.
            </summary>
            <param name="p">The program to generate the header for.</param>
            <param name="headerModuleName">The name of the header module.</param>
            <param name="optimization">The optimization setting to use while generating code.</param>
            <returns>A representation of the header code.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`5.GenerateUnisolatedHeader(`2,Microsoft.ProgramSynthesis.Translation.OptimizeFor)">
            <summary>
                Generates a representation of the header directly.
                The generated header code is not isolated.
            </summary>
            <param name="p">The program to generate the header for.</param>
            <param name="optimization">The optimization setting to use while generating code.</param>
            <returns>A representation of the unisolated header code.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`5.GenerateHeader(System.String,Microsoft.ProgramSynthesis.Translation.OptimizeFor)">
            <summary>
                Generates a representation of the header directly. The generated header is independent of the program, and is
                guaranteed to be sufficient for any program generated in the DSL.
            </summary>
            <param name="headerModuleName">The name of module in which the code is to be inserted.</param>
            <param name="optimization">The optimization setting to use while generating code.</param>
            <returns>A representation of the header code.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`5.GenerateUnisolatedHeader(Microsoft.ProgramSynthesis.Translation.OptimizeFor)">
            <summary>
                Generates a representation of the header directly. The generated header is independent of the program, and is
                guaranteed to be sufficient for any program generated in the DSL. The generated header is also not isolated.
            </summary>
            <param name="optimization">The optimization setting to use while generating code.</param>
            <returns>A representation of the header code.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`5.GenerateLiteralRepresentation(System.Object,System.Type)">
            <summary>
                Generates the representation of the literal in the target language.
            </summary>
            <param name="literalValue">An <see cref="T:System.Object" /> representing the value of the literal.</param>
            <param name="literalType">The type of the literal.</param>
            <returns>
                A representation of <see cref="!:literalValue" /> interpreted as a value
                of the type <see cref="!:literalType" /> in the target language.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`5.GenerateFunctionBody(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Utils.Record{System.String,System.Type}},System.Type,Microsoft.ProgramSynthesis.AST.ProgramNode,System.Boolean,Microsoft.ProgramSynthesis.Translation.OptimizeFor)">
            <summary>
                Generates an implementation for a function.
            </summary>
            <param name="formalParameters">The formal parameters to the function: A mapping from names to types.</param>
            <param name="returnType">The return type of the function.</param>
            <param name="functionBody">The program node corresponding to the body of the function.</param>
            <param name="isLambda">The flag indicating that the function is a lambda.</param>
            <param name="optimization">The optimization mode.</param>
            <returns>
                A representation of the function as a value, that can be used to call the function.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`5.PushBindingScope(System.Collections.Generic.IDictionary{System.String,Microsoft.ProgramSynthesis.Translation.SSAValue})">
            <summary>
                Pushes a new variable resolution scope and adds any new bindings to the scope.
            </summary>
            <param name="newBindings">An optional set of bindings to be added to the new scope.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`5.PopBindingScope">
            <summary>
                Pops the most recently pushed variable resolution scope.
            </summary>
            <returns>
                The popped set of bindings.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`5.ResolveVariable(System.String)">
            <summary>
                Resolves a variable to its binding, according to lexical scoping rules.
            </summary>
            <param name="variableName">The name of the variable whose binding is sought.</param>
            <returns>A representation of the value that the variable <see cref="!:variableName" /> is bound to.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`5.BindVariable(System.String,Microsoft.ProgramSynthesis.Translation.SSAValue,System.Boolean)">
            <summary>
                Bind a variable named <see cref="!:variableName" /> to a value represented by <see cref="!:binding" />.
            </summary>
            <param name="variableName">The name of the variable to be bound.</param>
            <param name="binding">
                A representation of the value that the variable <see cref="!:variableName" />
                is to be bound to.
            </param>
            <param name="ignoreIfAlreadyBoundInScope">
                Do not replace the binding if the variable <see cref="!:variableName" /> is
                already bound in this scope.
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`5.Translate(`2,`1,Microsoft.ProgramSynthesis.Translation.OptimizeFor)">
            <summary>
                Translates a program <paramref name="root" /> into a representation of a function corresponding to the
                program <paramref name="root" />.
            </summary>
            <param name="root">The program to be translated.</param>
            <param name="translationModule">The module into which all lambdas in the program will be placed.</param>
            <param name="optimization">The <see cref="T:Microsoft.ProgramSynthesis.Translation.OptimizeFor" /> option.</param>
            <returns>
                A <see cref="T:Microsoft.ProgramSynthesis.Translation.GeneratedFunction" /> which represents the translation of the program
                <paramref name="root" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`5.GetSubprogramTranslatorFor(Microsoft.ProgramSynthesis.Translation.OptimizeFor)">
            <summary>
                Return a subprogram translator for a given optimization mode.
                The default implementation is to return <c>null</c>.
                Subclasses can override this to return specific subprogram transformers in response to various
                optimization modes.
            </summary>
            <param name="optimization">The optimization mode.</param>
            <returns>A <see cref="!:ISubprogramTranslator" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`5.ApplyStandardOptimizations(Microsoft.ProgramSynthesis.Translation.IGeneratedFunction,Microsoft.ProgramSynthesis.Translation.OptimizeFor)">
            <summary>
                Applies standard optimizations for a given <see cref="T:Microsoft.ProgramSynthesis.Translation.OptimizeFor" /> option.
            </summary>
            <param name="function">The <see cref="T:Microsoft.ProgramSynthesis.Translation.IGeneratedFunction" /> to optimize.</param>
            <param name="optimization">The <see cref="T:Microsoft.ProgramSynthesis.Translation.OptimizeFor" /> option.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.Uninliner">
            <summary>
                Unfolds any inlined function applications so the later passes can work properly.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.ValueProp">
            <summary>
                Perform Value propagation for Constants (Constant propagation), Variables (Copy propagation) and Expressions (CSE).
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.ValueProp.Instance">
            <summary>
                The singleton instance of <see cref="T:Microsoft.ProgramSynthesis.Translation.ValueProp" />
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.ValueProp.InnerValueProp.TryOptimize(System.Collections.Generic.LinkedListNode{Microsoft.ProgramSynthesis.Translation.SSAStep})">
            <summary>
                Try to optimize current step in following order:
                1. Constant
                2. Variable
                3. Expression
            </summary>
            <param name="stepNode"></param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.ValueProp.InnerValueProp.PopulateCSETable(Microsoft.ProgramSynthesis.Translation.SSARegister,Microsoft.ProgramSynthesis.Translation.SSARValue)">
            <summary>
                Records redundant expression inside cseLookupTable. Note the expression are stored
                as keys in string representation so updating the register name in other passes still
                does the right lookup because we won't compare the hashcode of SSARegister.
            </summary>
            <param name="lValue"></param>
            <param name="rValue"></param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.ValueProp.InnerValueProp.TryConstantProp(Microsoft.ProgramSynthesis.Translation.SSARegister,Microsoft.ProgramSynthesis.Translation.SSARValue)">
            <summary>
                Try Constant propagation optimization if enabled.
            </summary>
            <param name="lValue"></param>
            <param name="rValue"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.ValueProp.InnerValueProp.TryCopyProp(Microsoft.ProgramSynthesis.Translation.SSARegister,Microsoft.ProgramSynthesis.Translation.SSARValue)">
            <summary>
                Try Copy propagation optimization if enabled.
            </summary>
            <param name="lValue"></param>
            <param name="rValue"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.ValueProp.InnerValueProp.TryCSE(Microsoft.ProgramSynthesis.Translation.SSARegister,Microsoft.ProgramSynthesis.Translation.SSARValue)">
            <summary>
                Try CSE optimization if enabled.
            </summary>
            <param name="lValue"></param>
            <param name="rValue"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.ValueProp.InnerValueProp.SubstituteValue(Microsoft.ProgramSynthesis.Translation.SSARegister,Microsoft.ProgramSynthesis.Translation.SSARValue)">
            <summary>
                Replace <paramref name="lValue" /> in all downlinks with <paramref name="newValue" />
            </summary>
            <param name="lValue"></param>
            <param name="newValue"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.ValueProp.InnerValueProp.SubstituteRegister(Microsoft.ProgramSynthesis.Translation.SSARegister,Microsoft.ProgramSynthesis.Translation.SSARegister)">
            <summary>
                Replace <paramref name="lValue" /> in all downlinks with <paramref name="newRegister" />.
                Also adds the downlinks of original <paramref name="lValue" /> in that of <paramref name="newRegister" />.
            </summary>
            <param name="lValue"></param>
            <param name="newRegister"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.ValueProp.InnerValueProp.ShouldConstantProp(Microsoft.ProgramSynthesis.Translation.SSARValue)">
            <summary>
                If rValue is one of the primitive, then marks it as constant prop candidate.
            </summary>
            <param name="rValue"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.VariableNameOptimizer">
            <summary>
                Assign print names to SSARegisters so that they are as close to their
                original print name as possible, while not clashing with any existing live variable.
                This optimization should be the last one to be performed before generating code.
                It conservatively assumes that all previously defined variables are live.
                In future, this can potentially be improved by doing liveness analysis and
                computing the precise life span of each SSARegister appearing in the code.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.VariableNameOptimizer.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Constructor for <see cref="T:Microsoft.ProgramSynthesis.Translation.VariableNameOptimizer" />
            </summary>
            <param name="boundNames">The names that are live/bound in the context and the optimizer is prohibited from using.</param>
            <returns>A <see cref="T:Microsoft.ProgramSynthesis.Translation.VariableNameOptimizer" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.VariableNameOptimizer.Optimize(System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.Translation.SSAStep})">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.VariableNamesNormalizer">
            <summary>
                Shortens the variable names by removing unnecessary zeros from id and re-assigning
                names in new sequence. The new ids are assigned starting with minimum id present in
                SSASteps. E.g. if SSAStep contains register with id _0008, the ids will start from 8.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.VariableNamesNormalizer.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Constructor for <see cref="T:Microsoft.ProgramSynthesis.Translation.VariableNamesNormalizer" />
            </summary>
            <param name="boundNames">The names that are live/bound in the context and the normalizer is prohibited from using.</param>
            <returns>A <see cref="T:Microsoft.ProgramSynthesis.Translation.VariableNamesNormalizer" />.</returns>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.VariableNamesNormalizer.regex">
            <summary>
                Matches name of variable and numeric id starting from 1st non-zero number
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.DirectProgramSet.Sample(System.Random,Microsoft.ProgramSynthesis.Learning.ProgramSamplingStrategy)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.DirectProgramSet.AcceptVisitor``1(Microsoft.ProgramSynthesis.VersionSpace.ProgramSetVisitor{``0})">
            <summary>
                Returns the value computed by the hierarchical application of the <paramref name="visitor" /> instance.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet.Sample(System.Random,Microsoft.ProgramSynthesis.Learning.ProgramSamplingStrategy)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet.AcceptVisitor``1(Microsoft.ProgramSynthesis.VersionSpace.ProgramSetVisitor{``0})">
            <summary>
                Returns the value computed by the hierarchical application of the <paramref name="visitor" /> instance.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSetBuilder`1">
            <summary>
                Wraps a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet"/> corresponding to the symbol <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">
                The type, usually automatically generated by <c>dslc</c>, of the wrapped
                <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet"/>.
            </typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSetBuilder`1.#ctor(Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet)">
            <summary>
                Construct a typed program set from an untyped one.  Note that no type check is performed.
            </summary>
            <param name="set">The <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet"/> that will be wrapped with a type.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSetBuilder`1.CreateUnsafe(Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet)">
            <summary>
                Construct a typed program set from an untyped one.  Note that no type check is performed.
                This is a building block from which <c>dslc</c> generates type-safe wrappers for a grammar.
            </summary>
            <param name="set">The <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet"/> that will be wrapped with a type.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSetBuilder`1.Set">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet"/> that is wrapped by this <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSetBuilder`1"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.NamespaceDoc">
            <summary>
                <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> and subclasses for compactly representing a set of <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/>.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.LeafSetSize">
            <summary>
                The minimum size of a program set that will be represented as a version space algebra.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.Intersect(Microsoft.ProgramSynthesis.VersionSpace.ProgramSet)">
            <summary>
                Intersects this program set with another program set <paramref name="other" />, producing a concise
                representation of the program set that consists of all programs in both this program set
                and the <paramref name="other" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.FindSetDepthFirst(System.Predicate{Microsoft.ProgramSynthesis.VersionSpace.ProgramSet},System.Predicate{Microsoft.ProgramSynthesis.VersionSpace.ProgramSet})">
            <summary>
                Starting at this program set, traverse the tree of program sets among the first children
                for which the predicate is true.
                Returns the last program set for which the predicate is true but false for all of its children.
            </summary>
            <param name="predicate">A function telling if the program set is the one we are looking for</param>
            <param name="traverseChildren">Optional: A function telling if we should traverse the set's children</param>
            <returns>The last program set for which the predicate is true but false for all of its children</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.Sample(System.Random,Microsoft.ProgramSynthesis.Learning.ProgramSamplingStrategy)">
            <summary>
                Draw a single program from this program set at random.
            </summary>
            <param name="random"></param>
            <param name="programSamplingStrategy">The <see cref="T:Microsoft.ProgramSynthesis.Learning.ProgramSamplingStrategy" /> to use.</param>
            <returns>
                A single program from this program set, chosen at random, according to
                <paramref name="programSamplingStrategy" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.Shatter(Microsoft.ProgramSynthesis.VersionSpace.ProgramSetUtils.ShatteringContext)">
            <summary>
                Partition this program set into subspaces where every program in the set hashes to the same value
                under a universal hash function defined over the program structure.
                <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetUtils.ShatteringContext" />
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.Filter(Microsoft.ProgramSynthesis.Specifications.Spec)">
            <summary>
                Filters this <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet" /> down only to a programs that are consistent with a given
                <paramref name="spec" />.
            </summary>
            <param name="spec">A spec to satisfy.</param>
            <returns>
                A <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet" /> representing a subset of the programs contained in the current instance that
                satisfy <paramref name="spec" />.
            </returns>
            <remarks>
                When possible, use the extension method <c>Filter(Spec, SynthesisEngine)</c>
                from <c>Microsoft.ProgramSynthesis.Learning.ProgramSetExtensions</c> instead.
                It has vastly superior performance but may not handle all <see cref="T:Microsoft.ProgramSynthesis.Specifications.Spec"/> instances completely.
                If it fails, fall back to this implementation.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.PartitionByValidity(Microsoft.ProgramSynthesis.Specifications.Spec,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet@,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet@)">
            <summary>
                Partitions this space of programs into two parts: those that satisfy a spec and those that do not.
            </summary>
            <param name="spec">A <see cref="T:Microsoft.ProgramSynthesis.Specifications.Spec" /> defining the space of valid programs</param>
            <param name="validSet">programs for which the spec holds</param>
            <param name="invalidSet">programs for which the spec does not hold</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.FindChildSet(Microsoft.ProgramSynthesis.AST.ProgramNode,System.Int32)">
            <summary>
                Returns the ProgramSet corresponding to the child; given that this ProgramSet can represent the parent.
            </summary>
            <param name="node">The parent (member of this ProgramSet)</param>
            <param name="indexInParent">The index of child in the parent's children</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.Contains(Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Returns true iff this <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet" /> instance contains the given program as a set.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.AcceptVisitor``1(Microsoft.ProgramSynthesis.VersionSpace.ProgramSetVisitor{``0})">
            <summary>
                Returns the value computed by the hierarchical application of the <paramref name="visitor" /> instance.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.StructuralEquals(Microsoft.ProgramSynthesis.VersionSpace.ProgramSet)">
            <summary>
                Checks if <c>this</c> <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> is structurally equivalent to
                <paramref name="other"/>. Note that this is a stricter check than set equality
                (which is much harder to do correctly).
            </summary>
            <param name="other">The other <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/>.</param>
            <returns><c>true</c> iff <c>this</c> is structurally equivalent to <paramref name="other"/>.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.SerializeToXMLString(System.Boolean)">
            <summary>
                Serializes this <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> into a <see cref="T:System.String"/> which represents an XML object. This string can then
                be deserialized using the <see cref="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.DeserializeFromXMLString(System.String,Microsoft.ProgramSynthesis.Grammar)"/> method.
            </summary>
            <param name="indent">Should the result be indented? Defaults to <c>false</c>.</param>
            <returns>An <see cref="T:System.String"/> that represents the serialization of this <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.SerializeToXML">
            <summary>
                Serializes this <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> into an <see cref="T:System.Xml.Linq.XElement"/>, which can then
                be deserialized using the <see cref="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.DeserializeFromXML(System.Xml.Linq.XElement,Microsoft.ProgramSynthesis.Grammar)"/> method.
            </summary>
            <returns>An <see cref="T:System.Xml.Linq.XElement"/> that represents the serialization of this <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.DeserializeFromXMLString(System.String,Microsoft.ProgramSynthesis.Grammar)">
            <summary>
                Deserializes a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> previously serialized using <see cref="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.SerializeToXMLString(System.Boolean)"/>.
            </summary>
            <param name="xmlString">The <see cref="T:System.String"/> produced by a previous call to <see cref="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.SerializeToXMLString(System.Boolean)"/>.</param>
            <param name="grammar">The <see cref="T:Microsoft.ProgramSynthesis.Grammar"/> from which the serialized <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> was produced.</param>
            <returns>A deserialized <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/>.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.DeserializeFromXML(System.Xml.Linq.XElement,Microsoft.ProgramSynthesis.Grammar)">
            <summary>
                Deserializes a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> previously serialized using <see cref="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.SerializeToXML"/>.
            </summary>
            <param name="node">The <see cref="T:System.Xml.Linq.XElement"/> produced by a previous call to <see cref="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.SerializeToXML"/>.</param>
            <param name="grammar">The <see cref="T:Microsoft.ProgramSynthesis.Grammar"/> from which the serialized <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> was produced.</param>
            <returns>A deserialized <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/>.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetBuilder">
            <summary>
                Wraps a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/>.  A base class from which <c>dslc</c> will derive
                classes for types constructors for <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/>s.  Also contains
                static utilities for constructing typed <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/>s.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetBuilder.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetBuilder.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetBuilder.Set">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> that is wrapped by this <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetBuilder"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetBuilder.Empty``1(Microsoft.ProgramSynthesis.Symbol)">
            <summary>
                Construct a typed empty program set.
            </summary>
            <param name="symbol">The symbol corresponding to <typeparamref name="T"/>.</param>
            <returns>A typed empty program set.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetBuilder.List``1(Microsoft.ProgramSynthesis.Symbol,``0[])">
            <summary>
                Construct a typed program set corresponding to a list of programs.
            </summary>
            <param name="symbol">The symbol corresponding to <typeparamref name="T"/>.</param>
            <param name="nodes">The programs from which the list should be formed.</param>
            <returns>A typed program set representing a list of the given programs.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetBuilder.List``1(Microsoft.ProgramSynthesis.Symbol,System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Construct a typed program set corresponding to a list of programs.
            </summary>
            <param name="symbol">The symbol corresponding to <typeparamref name="T"/>.</param>
            <param name="nodes">The programs from which the list should be formed.</param>
            <returns>A typed program set representing a list of the given programs.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetBuilder.List``1(``0[])">
            <summary>
                Construct a typed program set corresponding to a list of programs.
            </summary>
            <param name="nodes">The programs from which the list should be formed.  May not be empty.</param>
            <returns>A typed program set formed from the list of programs.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetBuilder.NormalizedUnion``1(Microsoft.ProgramSynthesis.VersionSpace.ProgramSetBuilder{``0}[])">
            <summary>
                Construct a typed program set corresponding to a union of program sets.
            </summary>
            <param name="builders">The program sets that will form the union</param>
            <returns>A typed program set representing a union of the given program sets.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetBuilder.Unsafe``1(Microsoft.ProgramSynthesis.VersionSpace.ProgramSet)">
            <summary>
                Construct a typed program set by assuming that the given set has the correct type.
            </summary>
            <param name="set">The program set that will be wrapped in a typed wrapper.</param>
            <returns>A typed program set representing the given program set.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetBuilder`1">
            <summary>
                Wraps a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> corresponding to the symbol <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">
                The type, usually automatically generated by <c>dslc</c>, of the wrapped
                <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/>.
            </typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetBuilder`1.#ctor(Microsoft.ProgramSynthesis.VersionSpace.ProgramSet)">
            <summary>
                Construct a typed program set from an untyped one.  Note that no type check is performed.
            </summary>
            <param name="set">The <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> that will be wrapped with a type.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetBuilder`1.CreateUnsafe(Microsoft.ProgramSynthesis.VersionSpace.ProgramSet)">
            <summary>
                Construct a typed program set from an untyped one.  Note that no type check is performed.
                This is a building block from which <c>dslc</c> generates type-safe wrappers for a grammar.
            </summary>
            <param name="set">The <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> that will be wrapped with a type.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetBuilderEx.ToProgramSet``1(``0)">
            <summary>
                Construct a typed program set corresponding to a typed program node.
            </summary>
            <param name="builder">The program node that will be the only element of the set.</param>
            <returns>A typed program set representing the set of join a single program node.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetBuilderEx.NormalizedUnion``1(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.VersionSpace.ProgramSetBuilder{``0}})">
            <summary>
                Construct a typed program set corresponding to a union of program sets.
            </summary>
            <param name="builders">The program sets that will form the union</param>
            <returns>A typed program set representing a union of the given program sets.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetBuilderEx.Intersect``1(Microsoft.ProgramSynthesis.VersionSpace.ProgramSetBuilder{``0},Microsoft.ProgramSynthesis.VersionSpace.ProgramSetBuilder{``0})">
            <summary>
                Intersect two typed program sets.
            </summary>
            <typeparam name="T">The type of the wrapped program sets.</typeparam>
            <param name="set1">The first program set to intersect.</param>
            <param name="set2">The second program set to intersect.</param>
            <returns>A typed wrapper containing the intersection of the given program sets.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.RewriteRule">
            <summary>
                A rule that <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter"/> will use to rewrite programs
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.RewriteRule.#ctor(Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Constructs a rewrite rule that <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter"/> will use to rewrite
                <paramref name="source" /> to <paramref name="target" /> where the <see cref="T:Microsoft.ProgramSynthesis.AST.Hole" />s which are
                reference equal in the two are filled in with the corresponding values.
            </summary>
            <param name="source">Pattern to match.</param>
            <param name="target">Pattern to rewrite to.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.FuncRewriteRule`2">
            <summary>
                A rule that <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter" /> will use to rewrite programs
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.FuncRewriteRule`2.#ctor(`0,System.Func{`0,System.Collections.Generic.IReadOnlyDictionary{Microsoft.ProgramSynthesis.AST.Hole,Microsoft.ProgramSynthesis.AST.ProgramNode},`0},System.Func{`1,Microsoft.ProgramSynthesis.AST.ProgramNode,System.Nullable{`0}},`1)">
            <summary>
                Constructs a rewrite rule that <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter"/> will use to rewrite
                <paramref name="source" /> to <paramref name="target" /> where the <see cref="T:Microsoft.ProgramSynthesis.AST.Hole" />s which are
                reference equal in the two are filled in with the corresponding values.
            </summary>
            <param name="source">Pattern to match.</param>
            <param name="target">Pattern to rewrite to.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter">
            <summary>
                Algorithm for rewriting one pattern of <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/> to another.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.Rewrite(Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.VersionSpace.RewriteRule)">
            <summary>
                Rewrite a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> by replacing occurrences of a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/>
                pattern with another one.  The pattern may contain <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/>s which are copied
                as-is to the result.
            </summary>
            <remarks>
                The source and target patterns may not contain a particular <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/> more than
                once.  This is not checked.
            </remarks>
            <param name="input">The <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> to rewrite.</param>
            <param name="rewriteRule">
                The rewrite rule that consists of a source to be found in <paramref name="input"/> and a target
                to replace it with.
            </param>
            <returns>
                The rewritten <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> with all occurrences of <paramref name="rewriteRule"/>'s source
                replaced by <paramref name="rewriteRule"/>'s target.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.Rewrite(Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.VersionSpace.RewriteRule)">
            <summary>
                Rewrite a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> by replacing occurrences of a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" />
                pattern with another one.  The pattern may contain <see cref="T:Microsoft.ProgramSynthesis.AST.Hole" />s which are copied
                as-is to the result.
            </summary>
            <remarks>
                The source and target patterns may not contain a particular <see cref="T:Microsoft.ProgramSynthesis.AST.Hole" /> more than
                once.  This is not checked.
            </remarks>
            <param name="input">The <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> to rewrite.</param>
            <param name="rewriteRule">
                The rewrite rule that consists of a source to be found in <paramref name="input" /> and a target
                to replace it with.
            </param>
            <returns>
                The rewritten <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> with all occurrences of <paramref name="rewriteRule" />'s source
                replaced by <paramref name="rewriteRule" />'s target.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.Rewrite(Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Rewrite a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/> by replacing occurrences of a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/>
                pattern with another one.  The pattern may contain <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/>s which are copied
                as-is to the result.
            </summary>
            <remarks>
                The source and target patterns may not contain a particular <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/> more than
                once.  This is not checked.
            </remarks>
            <param name="input">The <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/> to rewrite.</param>
            <param name="source">The pattern to find in <paramref name="input"/>.</param>
            <param name="target">
                The pattern that will replace <paramref name="source"/> in <paramref name="input"/>.
            </param>
            <returns>
                The rewritten <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/> with all occurrences of
                <paramref name="source"/> replaced by <paramref name="target"/>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.Rewrite(Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode,System.Func{Microsoft.ProgramSynthesis.AST.ProgramNode,System.Collections.Generic.IReadOnlyDictionary{Microsoft.ProgramSynthesis.AST.Hole,Microsoft.ProgramSynthesis.AST.ProgramNode},Microsoft.ProgramSynthesis.AST.ProgramNode})">
            <summary>
                Rewrite a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> by replacing occurrences of a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" />
                pattern by evaluating a function on it. The pattern may contain <see cref="T:Microsoft.ProgramSynthesis.AST.Hole" />s which are
                passed to the function.
            </summary>
            <remarks>
                The source patterns may not contain a particular <see cref="T:Microsoft.ProgramSynthesis.AST.Hole" /> more than
                once. This is not checked.
            </remarks>
            <param name="input">The <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> to rewrite.</param>
            <param name="source">The pattern to find in <paramref name="input" />.</param>
            <param name="computeTarget">
                The function to compute the replacement for <paramref name="source" /> in <paramref name="input" />. The first
                argument will be the concrete match for the <paramref name="source" /> pattern and the second argument is a map
                from <see cref="T:Microsoft.ProgramSynthesis.AST.Hole" />s to the matches for those holes.
            </param>
            <returns>
                The rewritten <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> with all occurrences of
                <paramref name="source" /> replaced by the result of <paramref name="computeTarget" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.Rewrite(Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.VersionSpace.IFuncRewriteRule)">
            <summary>
                Rewrite a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> by replacing occurrences of a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" />
                pattern by evaluating a function on it. The pattern may contain <see cref="T:Microsoft.ProgramSynthesis.AST.Hole" />s which are
                passed to the function.
            </summary>
            <remarks>
                The source patterns may not contain a particular <see cref="T:Microsoft.ProgramSynthesis.AST.Hole" /> more than
                once. This is not checked.
            </remarks>
            <param name="input">The <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> to rewrite.</param>
            <param name="rewriteRule">The rewrite rule to apply.</param>
            <returns>
                The rewritten <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> with all occurrences of
                <see cref="P:Microsoft.ProgramSynthesis.VersionSpace.IFuncRewriteRule.Source"/> replaced by the result of <see cref="P:Microsoft.ProgramSynthesis.VersionSpace.IFuncRewriteRule.Target"/>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.TopRewrite(Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.VersionSpace.RewriteRule)">
            <summary>
                Rewrite a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> only at the top position.
            </summary>
            <param name="input">The <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> to rewrite at the top position.</param>
            <param name="rewriteRule">The rewrite rule to use to perform the rewrite.</param>
            <returns>
                If <see cref="P:Microsoft.ProgramSynthesis.VersionSpace.RewriteRule.Source"/> of the rule <paramref name="rule"/> matches
                <paramref name="input"/> at the top position, then returns the <see cref="P:Microsoft.ProgramSynthesis.VersionSpace.RewriteRule.Target"/>
                of the rule <paramref name="rewriteRule"/> with holes instantiated using the matching substitution. 
                Returns null otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.FoldConstants(Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Fold all constant-valued expressions to literals where the grammar allows. As this evaluates all constant-values
                expressions in <paramref name="input" />, it will throw an exception if any such expression throws an exception.
            </summary>
            <param name="input">A <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> which may have constant-value expressions to fold.</param>
            <returns>A program equivalent to <paramref name="input" /> with its constants folded where possible.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.Extract(Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet@,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet@)">
            <summary>
                Splits a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> into programs that match a pattern and those that don't.
            </summary>
            <remarks>
                Implements the <c>Extract</c> algorithm from the OneNote page.
            </remarks>
            <param name="input">The program set to split.</param>
            <param name="pattern">The pattern to split <paramref name="input"/> on</param>
            <param name="matched">The programs in <paramref name="input"/>that match <paramref name="pattern"/>.</param>
            <param name="unmatched">The programs in <paramref name="input"/>that don't match <paramref name="pattern"/>.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.Matches(Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Checks if any program in a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> matches a pattern.
            </summary>
            <param name="input">The program set to match.</param>
            <param name="pattern">The pattern to match <paramref name="input"/> on.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.ContainsSubProgram(Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Checks if any program in a program set or any of their descendants are equal to <paramref name="needle" />. Note
                that this operation does <em>not</em> treat holes specially; <paramref name="needle" /> is treated as an AST, not a
                pattern. Equivalent to checking <see cref="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.ContainsSubProgram(Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode)" /> on every program in
                <see cref="P:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.RealizedPrograms" />, except that operation is usually too expensive to compute directly in
                practice.
            </summary>
            <param name="input"><see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet" /> to look for <paramref name="needle" /> in.</param>
            <param name="needle"><see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> to search for. (Not a pattern.)</param>
            <returns>
                <c>true</c> if any sub-tree of any <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> in <paramref name="input" /> is equal to
                <paramref name="needle" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.ContainsSubProgram(Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Checks if a program or any of its descendants are equal to <paramref name="needle" />. Note that this operation
                does <em>not</em> treat holes specially; <paramref name="needle" /> is treated as an AST, not a pattern.
            </summary>
            <param name="input"><see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> to look for <paramref name="needle" /> in.</param>
            <param name="needle"><see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> to search for. (Not a pattern.)</param>
            <returns><c>true</c> if any sub-tree of <paramref name="input" /> is equal to <paramref name="needle" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.CreateUnmatchedCartesianProduct(Microsoft.ProgramSynthesis.Rules.NonterminalRule,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet[],Microsoft.ProgramSynthesis.VersionSpace.ProgramSet[],Microsoft.ProgramSynthesis.VersionSpace.ProgramSet[])">
            <summary>
                Create the set of programs that correspond to <paramref name="rule"/> applied to arguments
                in <paramref name="matchedParameters"/> and <paramref name="unmatchedParameters"/>.  Each
                program must include at least one non-empty instance from <paramref name="unmatchedParameters"/>.
            </summary>
            <remarks>
                <paramref name="originalParameters"/> is the original union of <paramref name="matchedParameters"/>
                and <paramref name="unmatchedParameters"/>.  It is provided to avoid reconstructing its members.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.TransformNode(Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet)">
             <summary>
                 Produce a new <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> from <paramref name="target"/> by performing a unification
                 on values in <paramref name="input"/> and <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/>s in <paramref name="source"/> and
                 substituting them in it.
             </summary>
             <remarks>
                 Implements the <c>TransformNode</c> algorithm from the OneNote page.
            
                 Precondition: <paramref name="input"/> matches <paramref name="source"/>.
             </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.TransformSet(Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode)">
             <summary>
                 Produce a new <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> from <paramref name="target"/> by performing a unification
                 on values in <paramref name="input"/> and <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/>s in <paramref name="source"/> and
                 substituting them in it.
             </summary>
             <remarks>
                 Implements the <c>TransformSet</c> algorithm from the OneNote page.
            
                 Precondition: All programs in <paramref name="input"/> match <paramref name="source"/>.
             </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.Matches(Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Determine if <paramref name="input"/> unifies with <paramref name="pattern"/>.
                Unification allows syntactic matching as well as arbitrary nodes to correspond to
                <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/>s.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.ExtractMappings(Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Given a <paramref name="pattern" /> that matches <paramref name="input" />, extract the <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" />s
                in <paramref name="input" /> match the <see cref="T:Microsoft.ProgramSynthesis.AST.Hole" /> <paramref name="pattern" />. <paramref name="pattern"/>
                may not include any <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/> more than once (according to the standard equality check).
            </summary>
            <param name="input"><see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> to match pattern to.</param>
            <param name="pattern">Pattern with <see cref="T:Microsoft.ProgramSynthesis.AST.Hole" />s to match.</param>
            <returns>
                <c>null</c> if <paramref name="input" /> matches <paramref name="pattern" /> or a dictionary of the holes in
                <paramref name="pattern" /> matched to the matches in <paramref name="input" />.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.NodeInSetHoleFiller">
            <summary>
                Substitute a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/> for a <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/> in a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.NodeInNodeHoleFiller">
            <summary>
                Substitute a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/> for a <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/> in a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.SetInSetHoleFiller">
            <summary>
                Substitute a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> for a <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/> in a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/>.
                This may promote <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/>s with that <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/> to
                <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/>s.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.SetInNodeHoleFiller">
            <summary>
                Substitute a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> for a <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/> in a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/>.
                This may promote <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/>s with that <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/> to
                <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/>s.
            </summary>
            <remarks>
                If the value is a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.DirectProgramSet"/> with a single program, then the substitution
                extracts that program and the result remains a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/>.
            </remarks>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.TransformMinimalProgramSet">
            <summary>
                Identify the minimal sub-<see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> (or <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/>) that
                contains any of the given set of <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/>s and transform it given a provided
                transformation method.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.TransformMinimalProgramSet.#ctor(System.Collections.Immutable.IImmutableSet{Microsoft.ProgramSynthesis.AST.Hole},System.Func{Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet},System.Func{Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet},Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Create a visitor that will find the minimal <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> to transform and
                call the supplied transformer on it.
            </summary>
            <remarks>
                <paramref name="transformSet"/> and <paramref name="transformNode"/> are passed in rather
                than directly called to allow the test code to mock them.
            </remarks>
            <param name="filter">The <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/>s of interest.</param>
            <param name="transformSet">Method to transform the minimal <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/>.</param>
            <param name="transformNode">Method to transform the minimal <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/>.</param>
            <param name="input">
                The original input that led to the need for this minimal transformation.  It must be a
                <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.UnionProgramSet"/> or <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.DirectProgramSet"/>.
            </param>
            <param name="source">The original pattern that matched <paramref name="input"/>.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.TransformMinimalProgramSet.TransformMinimalHelper(System.Func{Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet},System.Func{Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet},Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet)">
            <summary>
                Helper method for <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.TransformMinimalProgramSet"/> and
                <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.TransformMinimalProgramNode"/> to do the actual transformation.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.UniqueHoleCollector">
            <summary>
                Gather the <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/>s in a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/>, possibly restricting them
                to a filter.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.TransformMinimalProgramNode">
            <summary>
                Identify the minimal sub-<see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/> that contains any of the given set of
                <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/>s and transform it given a provided transformation method.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.TransformMinimalProgramNode.#ctor(System.Collections.Immutable.IImmutableSet{Microsoft.ProgramSynthesis.AST.Hole},System.Func{Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet},System.Func{Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet},Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Create a visitor that will find the minimal <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/> to transform and
                call the supplied transformer on it.
            </summary>
            <remarks>
                <paramref name="transformSet"/> and <paramref name="transformNode"/> are passed in rather
                than directly called to allow the test code to mock them.
            </remarks>
            <param name="filter">The <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/>s of interest.</param>
            <param name="transformSet">Method to transform the minimal <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/>.</param>
            <param name="transformNode">Method to transform the minimal <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/>.</param>
            <param name="input">
                The original input that led to the need for this minimal transformation.  It must be a
                <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.UnionProgramSet"/> or <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.DirectProgramSet"/>.
            </param>
            <param name="source">The original pattern that matched <paramref name="input"/>.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.NodeOrSet">
            <summary>
                Union over <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/> and <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/>.
            </summary>
            <remarks>
                If a <c>null</c> set or node is used, then both <see cref="P:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.NodeOrSet.IsSet"/> and
                <see cref="P:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.NodeOrSet.IsNode"/> will return <c>false</c>.
            </remarks>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.RewriteSetVisitor._accessibleSymbols">
            <summary>
                Symbols <see cref="F:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.RewriteSetVisitor._source"/>'s symbol is accessible from.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.RewriteSetToSetVisitor._accessibleSymbols">
            <summary>
                Symbols <see cref="F:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.RewriteSetToSetVisitor._source"/>'s symbol is accessible from.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.NodeContainsSubProgramVisitor._accessibleSymbols">
            <summary>
                Symbols <see cref="F:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.NodeContainsSubProgramVisitor._needle"/>'s symbol is accessible from.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.SetContainsSubProgramVisitor._accessibleSymbols">
            <summary>
                Symbols <see cref="F:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.SetContainsSubProgramVisitor._needle"/>'s symbol is accessible from.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetUtils.AddConversionRules(Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.Symbol)">
            <summary>
                Build a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet" /> of symbol <paramref name="symbol" /> which contains just
                <paramref name="body" /> and conversions on top of it.
            </summary>
            <param name="body"><see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet" /> to wrap in conversions.</param>
            <param name="symbol">Output symbol.</param>
            <returns><see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet" /> of <paramref name="body" /> and conversions to <paramref name="symbol" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetUtils.AddConversionRules(Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet,Microsoft.ProgramSynthesis.Symbol)">
            <summary>
                Build a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet" /> of symbol <paramref name="symbol" /> which contains just
                <paramref name="body" /> and conversions on top of it.
            </summary>
            <param name="body"><see cref="T:Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet" /> to wrap in conversions.</param>
            <param name="symbol">Output symbol.</param>
            <returns><see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet" /> of <paramref name="body" /> and conversions to <paramref name="symbol" />.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetUtils.ShatteringContext">
            <summary>
                A class that organizes how a program set will be shattered using a hash
                function drawn from a universal hash function family. A program will be
                assigned the same hash bucket whether it was represented explicitly or
                implicitly in a VSA.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetUtils.GetAttributeCalculators(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Features.IFeature},System.Collections.Generic.Dictionary{System.Object,System.Int32})">
            <summary>
                Returns a sequence of functions that compute a feature value, given a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/>, for each
                of the <paramref name="featureCalculators"/>. Used in XML serialization of <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/>s.
            </summary>
            <param name="featureCalculators">The feature calculators for which the feature computation functions are required.</param>
            <param name="identityCache">The identity cache for XML serialization.</param>
            <returns>See summary.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetVisitor`1">
            <summary>
                A visitor for a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet" /> to pass to <see cref="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.AcceptVisitor``1(Microsoft.ProgramSynthesis.VersionSpace.ProgramSetVisitor{``0})" />.
            </summary>
            <typeparam name="T">The return type of this visitor.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.PrunedProgramSet.Empty(Microsoft.ProgramSynthesis.Symbol)">
            <summary>
                Constructs an empty <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.PrunedProgramSet" />.
            </summary>
            <param name="symbol">The <see cref="T:Microsoft.ProgramSynthesis.Symbol" /> for the empty <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet" /> that will be returned.</param>
            <returns>An empty <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.PrunedProgramSet" />, rooted on <paramref name="symbol" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.UnionProgramSet.Sample(System.Random,Microsoft.ProgramSynthesis.Learning.ProgramSamplingStrategy)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.UnionProgramSet.AcceptVisitor``1(Microsoft.ProgramSynthesis.VersionSpace.ProgramSetVisitor{``0})">
            <summary>
                Returns the value computed by the hierarchical application of the <paramref name="visitor" /> instance.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Text.Autocompletion.CompletionResultWithIndex">
            <summary>
                Represents a set of completion results along with an index into the prefix from where the completion was derived.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Text.Autocompletion.CompletionResultWithIndex.Key">
            <summary>
                The key associated with <see cref="P:Microsoft.ProgramSynthesis.Transformation.Text.Autocompletion.CompletionResultWithIndex.Value" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Text.Autocompletion.CompletionResultWithIndex.Value">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.CompletionInfo" /> associated with the <see cref="P:Microsoft.ProgramSynthesis.Transformation.Text.Autocompletion.CompletionResultWithIndex.Key" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Text.Autocompletion.CompletionResultWithIndex.Index">
            <summary>
                The index from the prefix from where these completion results were derived.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Text.Autocompletion.CompletionResultWithIndex.FullPrefix">
            <summary>
                The full prefix for the query. Note that <see cref="P:Microsoft.ProgramSynthesis.Transformation.Text.Autocompletion.CompletionResultWithIndex.Value" /> is derived from
                <c>FullPrefix.Substring(<see cref="P:Microsoft.ProgramSynthesis.Transformation.Text.Autocompletion.CompletionResultWithIndex.Index" />)</c>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Text.Autocompletion.CompletionResultWithIndex.#ctor(System.String,Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.CompletionInfo,System.Int32,System.String)">
            <summary>
                Constructor.
            </summary>
            <param name="key">The key for the result. See <see cref="P:Microsoft.ProgramSynthesis.Transformation.Text.Autocompletion.CompletionResultWithIndex.Key" />.</param>
            <param name="value">
                The value returned for lookup on the tree for <paramref name="key" />.
                See <see cref="P:Microsoft.ProgramSynthesis.Transformation.Text.Autocompletion.CompletionResultWithIndex.Value" />.
            </param>
            <param name="index">The index into <paramref name="fullPrefix" />, see <see cref="P:Microsoft.ProgramSynthesis.Transformation.Text.Autocompletion.CompletionResultWithIndex.Index" />.</param>
            <param name="fullPrefix">The full prefix used in the query. See <see cref="P:Microsoft.ProgramSynthesis.Transformation.Text.Autocompletion.CompletionResultWithIndex.FullPrefix" />.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.CompressedTrieSearchTree">
            <summary>
                An implementation of an <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleteSearchTree" /> that uses a
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.CompressedTrie`4" />
                as the <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.PrefixSearchTree`6" /> data structure.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.CompressedTrieSearchTree.#ctor(System.Boolean)">
            <summary>
                Constructor.
            </summary>
            <param name="caseInsensitiveLookups">If <c>true</c> then lookups will be performed in a case insensitive manner.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.CompressedTrieSearchTree.CaseInsensitiveLookups">
            <summary>
                Indicates whether lookups on the search tree are case insensitive.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.CompressedTrieSearchTree.Add(System.String,Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.CompletionInfo)">
            <summary>
                Add a new mapping to the tree.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="value">The value that <paramref name="key" /> is to be mapped to.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleter">
            <summary>
                An interface for autocompleters.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleter.Logger">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Logging.ILogger" /> object for logging telemetry data.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleter.Ranker">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IRanker" /> object for ranking suggestions.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleter.SuggestAsync(System.String,System.Int32,System.Int32)">
            <summary>
                Returns a task that when complete yields a list of <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.ISuggestion" />s.
            </summary>
            <param name="prefix">The prefix that any returned <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.ISuggestion" /> must start with.</param>
            <param name="minimumSuggestionCount">The minimum number of suggestions to return.</param>
            <param name="maximumSuggestionCount">The maximum number of suggestions to return.</param>
            <returns>
                A task that produces an ordered list of suggestions, with the most highly ranked suggestions at the beginning
                of the list.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleter.ConfirmSuggestion(System.String,System.Int32)">
            <summary>
                Provide feedback to the <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleter" /> that a particular suggestion offered by it in the most recent
                call to <see cref="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleter.SuggestAsync(System.String,System.Int32,System.Int32)" /> is the preferred one.
            </summary>
            <param name="suggestionEventId">The <see cref="T:System.Int32" /> ID for a list of suggestions</param>
            <param name="suggestionIndex">The <see cref="T:System.Int32" /> index into the list of suggestions associated with the suggestionEventId</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleteSearchTree">
            <summary>
                An interface for <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTree`4" />s that can be used
                for autocompletion.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleteSearchTree.Add(System.String,Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.CompletionInfo)">
            <summary>
                Add a new mapping to the tree.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="value">The value that <paramref name="key" /> is to be mapped to.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IRanker">
            <summary>
                An interface for a ranker that ranks a list of autocomplete suggestions.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IRanker.Rank(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Transformation.Text.Autocompletion.CompletionResultWithIndex})">
            <summary>
                Ranks a list of
                <see cref="T:Microsoft.ProgramSynthesis.Transformation.Text.Autocompletion.CompletionResultWithIndex" />s which
                represent autocompletion suggestions.
            </summary>
            <param name="completionResults">
                The sequence of
                <see cref="T:Microsoft.ProgramSynthesis.Transformation.Text.Autocompletion.CompletionResultWithIndex" />s.
            </param>
            <returns>
                A ranked list of
                <see cref="T:Microsoft.ProgramSynthesis.Transformation.Text.Autocompletion.CompletionResultWithIndex" />s.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.ISuggestion">
            <summary>
                An interface for suggestions made by <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleter" />s.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.ISuggestion.SuggestEventId">
            <summary>
                The ID for the suggestion list this suggestion appears in.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.ISuggestion.Source">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleter" /> object that produced this suggestion.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.ISuggestion.PrefixString">
            <summary>
                The prefix string that this suggestion was generated for.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.ISuggestion.MatchOffset">
            <summary>
                The offset into <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.ISuggestion.PrefixString" />, such that <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.ISuggestion.CompletionSuffix" /> starts with the suffix of
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.ISuggestion.PrefixString" /> which begins at <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.ISuggestion.MatchOffset" />.
                For example: Suppose <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.ISuggestion.PrefixString" /> is "foo bar", and <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.ISuggestion.CompletionSuffix" /> is "barrage",
                then the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.ISuggestion.MatchOffset" /> will be the value <c>4</c>.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.ISuggestion.CompletionSuffix">
            <summary>
                The completion suffix. See <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.ISuggestion.MatchOffset" /> for a description of how <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.ISuggestion.PrefixString" />,
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.ISuggestion.MatchOffset" /> and <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.ISuggestion.CompletionSuffix" /> work together.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.ISuggestion.Metadata">
            <summary>
                A property map for any metadata associated with this completion.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.ISuggestion.CompleteValue">
            <summary>
                The complete value. This is guaranteed to be an extension of <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.ISuggestion.PrefixString" /> and can be thought of as
                the "final value" that the user supplied prefix can be replaced with.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.CompressedTrie`4">
            <summary>
                A generic class that implements an <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTree`4" />
                using a trie where the edges are "compressed", i.e., long chains of tree nodes with only one child are compressed
                into a single edge, which may match a sequence of more than one character.
            </summary>
            <typeparam name="TSequenceable">The type of the sequenceable objects. e.g. <see cref="T:System.Char" /></typeparam>
            <typeparam name="TSequence">The type of the sequence objects. e.g. <see cref="T:System.String" /></typeparam>
            <typeparam name="TSubSequence">
                The type of the objects used to represent sub-sequences. e.g.<see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence" />
            </typeparam>
            <typeparam name="TValue">The type of the values that are mapped by this tree.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.CompressedTrie`4.GetEdgeLabels">
            <summary>
                Retrieves all the edge labels in this tree.
            </summary>
            <returns>A sequence of sequence of edges that correspond to a breadth-first traversal of the tree.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.CompressedTrieSplitNode`4">
            <summary>
                A generic class implementing a decision node in
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.CompressedTrie`4" />
            </summary>
            <typeparam name="TSequenceable">The type of the sequenceable objects. e.g. <see cref="T:System.Char" /></typeparam>
            <typeparam name="TSequence">The type of the sequence objects. e.g. <see cref="T:System.String" /></typeparam>
            <typeparam name="TSubSequence">
                The type of the objects used to represent sub-sequences. e.g.<see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence" />
            </typeparam>
            <typeparam name="TValue">The type of the values that are mapped by this tree.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.CompressedTrieSplitNode`4.#ctor(Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieEdge{`0,`1,`2,`3})">
            <summary>
                Constructor.
            </summary>
            <param name="edgeToParent">The edge to the parent of this node in the tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.CompressedTrieSplitNode`4.AddEntry(`2,`3,`2)">
            <summary>
                Add the specified mapping to the tree, recursing if necessary.
            </summary>
            <param name="suffix">The unmatched suffix of the entire <paramref name="key" />.</param>
            <param name="key">The key of the mapping.</param>
            <param name="value">The mapped value.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.CompressedTrieSplitNode`4.Lookup(`2,`3@)">
            <summary>
                TryGetValue the specified key in the tree.
            </summary>
            <param name="key">The key.</param>
            <param name="result">Set to the value mapped to the key if a mapping exists, <c>default(TLookupResult)</c> otherwise.</param>
            <returns><c>true</c> if a mapping for <paramref name="key" /> exists, <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTree`4">
            <summary>
                A generic interface for a prefix search tree.
            </summary>
            <typeparam name="TSequenceable">The sequenceable type, e.g. <see cref="T:System.Char" />.</typeparam>
            <typeparam name="TSequence">The type of the sequenceable, e.g. <see cref="T:System.String" />.</typeparam>
            <typeparam name="TSubSequence">The subsequence type, e.g. <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence" />.</typeparam>
            <typeparam name="TValue">The type of the values mapped.</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTree`4.Items">
            <summary>
                Retrieves all the mappings present in this set.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTree`4.Add(`1,`3)">
            <summary>
                Add a new key to value mapping.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="value">The value that <paramref name="key" /> maps to.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTree`4.TryGetValue(`1,`3@)">
            <summary>
                Lookup the mapping for a given key.
            </summary>
            <param name="key">The key for which the mapped value is to be retrieved.</param>
            <param name="result">
                Set to the mapping for <paramref name="key" /> if one exists, <c>default(TLookupResult)</c>
                otherwise.
            </param>
            <returns><c>true</c> if there exists a mapping for <paramref name="key" />, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTree`4.GetOrCreate(`1,System.Func{`3})">
            <summary>
                Get or create the value for a key.
            </summary>
            <param name="key">The key.</param>
            <param name="factory">
                A function that creates a new value to map <paramref name="key" /> to.
            </param>
            <returns>The value mapped to <paramref name="key" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTree`4.PrefixLookup(`1)">
            <summary>
                Retrieves all mappings where a prefix matches the key.
            </summary>
            <param name="prefix">The prefix to be matched.</param>
            <returns>
                A sequence of results, where <paramref name="prefix" /> is the prefix of the key for each returned result. If
                no results exist, then an empty sequence is returned.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTree`4.Clear">
            <summary>
                Clears all the mappings.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTreeEdge`6">
            <summary>
                A generic interface representing an edge in a prefix search tree.
            </summary>
            <typeparam name="TSequenceable">The sequenceable type.</typeparam>
            <typeparam name="TSequence">The sequence type.</typeparam>
            <typeparam name="TSubSequence">The subsequence type.</typeparam>
            <typeparam name="TValue">The value type of the mappings in the tree.</typeparam>
            <typeparam name="TNode">The type of the nodes constituting the tree.</typeparam>
            <typeparam name="TEdge">The type of the edges in the tree.</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTreeEdge`6.MatchedPrefix">
            <summary>
                The subsequence of the entire sequence that matches this edge.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTreeEdge`6.Parent">
            <summary>
                The parent node of this edge.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTreeEdge`6.Child">
            <summary>
                The child node of this edge.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTreeNode`6">
            <summary>
                A generic interface for prefix search tree nodes.
            </summary>
            <typeparam name="TSequenceable">The sequenceable type.</typeparam>
            <typeparam name="TSequence">The sequence type.</typeparam>
            <typeparam name="TSubSequence">The subsequence type.</typeparam>
            <typeparam name="TValue">The value type of the mappings in the tree.</typeparam>
            <typeparam name="TNode">The type of nodes that constitute the tree.</typeparam>
            <typeparam name="TEdge">The type of the tree edges.</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTreeNode`6.EdgeToParent">
            <summary>
                The edge to the parent of this node.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTreeNode`6.ChildFor(`2)">
            <summary>
                Return the edge corresponding to <paramref name="prefix" />.
            </summary>
            <param name="prefix">The prefix to match.</param>
            <returns>The edge corresponding to the prefix, if one exists, <c>default(TEdge)</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTreeNode`6.AddEntry(`2,`5,`2)">
            <summary>
                Add the specified mapping to the tree, recursing if necessary.
            </summary>
            <param name="suffix">The unmatched suffix of the entire <paramref name="key" />.</param>
            <param name="value">The mapped value.</param>
            <param name="key">The key of the mapping.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTreeNode`6.Lookup(`2,`5@)">
            <summary>
                TryGetValue the specified key in the tree.
            </summary>
            <param name="key">The key.</param>
            <param name="result">Set to the value mapped to the key if a mapping exists, <c>default(TLookupResult)</c> otherwise.</param>
            <returns><c>true</c> if a mapping for <paramref name="key" /> exists, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTreeNode`6.LookupOrCreate(`2,`2,System.Func{`5})">
            <summary>
                Lookup a key, or create a mapping for the key.
            </summary>
            <param name="key">The key.</param>
            <param name="suffix">The suffix of the key yet to be matched.</param>
            <param name="factory">A function that computes a value, to be mapped for <paramref name="key" />.</param>
            <returns>The updated value mapped to <paramref name="key" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTreeNode`6.LookupAll(`2)">
            <summary>
                Retrieves all results that are mapped to some extension of <paramref name="prefix" />.
            </summary>
            <param name="prefix">The prefix.</param>
            <returns>
                A sequence of <see cref="T:System.Collections.Generic.KeyValuePair`2" />s such that the <c>Key</c> field of each lookup
                result is
                an extension of <see cref="!:prefix" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTreeNode`6.GetEdges">
            <summary>
                Retrieves all the edges from this node.
            </summary>
            <returns>A collection of edges from this node.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTreeNode`6.Accept``1(Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTreeVisitor{`0,`1,`2,`5,`3,`4,``0})">
            <summary>
                Accepts a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTreeVisitor`7" />.
            </summary>
            <typeparam name="TResult">The result returned by the <paramref name="visitor" />.</typeparam>
            <param name="visitor">The visitor object.</param>
            <returns>The result returned by the <paramref name="visitor" />.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTreeVisitor`7">
            <summary>
                An interface for visitors that can traverse
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTree`4" /> objects.
            </summary>
            <typeparam name="TSequenceable">The sequenceable type, e.g. <see cref="T:System.Char" /></typeparam>
            <typeparam name="TSequence">The sequence type e.g. <see cref="T:System.String" /></typeparam>
            <typeparam name="TSubSequence">The subsequence type e.g. <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence" /></typeparam>
            <typeparam name="TValue">
                The value stored in the
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTree`4" />.
            </typeparam>
            <typeparam name="TNode">The node type of the tree.</typeparam>
            <typeparam name="TEdge">The edge type of the tree.</typeparam>
            <typeparam name="TResult">The result produced by the visitor instantiation.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTreeVisitor`7.Visit(`4)">
            <summary>
                Visits (and possibly traverses) the tree rooted at this node.
            </summary>
            <param name="node">The node to visit.</param>
            <returns>A result based on the traversal of <paramref name="node" />.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3">
            <summary>
                A common interface for representing subsequences for use in a prefix
                search tree.
            </summary>
            <typeparam name="TSequenceable">
                The type of objects in the sequence, these will be "peeled" as the prefix search tree
                is traversed.
            </typeparam>
            <typeparam name="TSequence">The concrete type of sequence of objects.</typeparam>
            <typeparam name="TSubSequence">
                The concrete type of the subsequence that implements this interface. The "recurring
                generic argument" pattern here serves to strongly type the Slice methods
            </typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.FullSequence">
            <summary>
                A reference to the entire sequence.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.Start">
            <summary>
                The starting index of this subsequence in <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.FullSequence" />
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.End">
            <summary>
                The ending index (exclusive) of this subsequence in <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.FullSequence" />
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.Length">
            <summary>
                The length of this subsequence.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.FullLength">
            <summary>
                The length of the full sequence that this sequence derives from.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.Value">
            <summary>
                The value of this subsequence, represented as a <typeparamref name="TSequence" />
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.Item(System.Int32)">
            <summary>
                Returns the <typeparamref name="TSequenceable" /> object at <paramref name="position" /> in <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.Value" />.
            </summary>
            <param name="position">The relative index into this sequence, at which the object to be retrieved resides.</param>
            <returns>The <typeparamref name="TSequenceable" /> at <paramref name="position" /> in <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.Value" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.AbsoluteSlice(System.UInt32,System.UInt32)">
            <summary>
                Returns an absolute slice of this subsequence
            </summary>
            <param name="start">The start index of the absolute slice, i.e., relative to <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.FullSequence" />.</param>
            <param name="end">The end index (exclusive) of the absolute slice, i.e., relateive to <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.FullSequence" />.</param>
            <returns>A <typeparamref name="TSubSequence" /> that represents the absolute slice.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.StartsWith(`1)">
            <summary>
                Checks if this sequence starts with the provided prefix
            </summary>
            <param name="prefix">The prefix to check.</param>
            <returns>true if this subsequence begins with <see cref="!:prefix" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.StartsWith(`2)">
            <summary>
                Checks if this sequence starts with the provided prefix
            </summary>
            <param name="prefix">The prefix to check.</param>
            <returns>true if this subsequence begins with <see cref="!:prefix" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.FindFirstMismatchingIndex(`1)">
            <summary>
                Finds the first position in this sequence, at which the value does not agree with the value in the same position in
                <paramref name="prefix" />.
            </summary>
            <param name="prefix">The prefix to check.</param>
            <returns>
                The index of the first position in <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.Value" /> such that the value at the same position in
                <paramref name="prefix" /> does not equal the value at the position in <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.Value" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.FindFirstMismatchingIndex(`2)">
            <summary>
                Finds the first position in this sequence, at which the value does not agree with the value in the same position in
                <paramref name="prefix" />.
            </summary>
            <param name="prefix">The prefix to check.</param>
            <returns>
                The index of the first position in <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.Value" /> such that the value at the same position in
                <paramref name="prefix" /> does not equal the value at the position in <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.Value" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.Concat(`2)">
            <summary>
                Create a new subsequence which is the concatenation of this subsequence with <paramref name="other" />.
            </summary>
            <param name="other">The subsequence to concatenate at the end of this.</param>
            <returns>A new subsequence which represents this subsequence concentenated with <paramref name="other" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.Concat(`1)">
            <summary>
                Create a new subsequence which is the concatenation of this subsequence with <paramref name="other" />.
            </summary>
            <param name="other">The sequence to concatenate at the end of this.</param>
            <returns>A new subsequence which represents this subsequence concentenated with <paramref name="other" />.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.PrefixSearchTree`6">
            <summary>
                A convenient, generic, abstract class that provides default implementations
                required by all classes implementing <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTree`4" />.
            </summary>
            <typeparam name="TSequenceable">The type of sequenceable objects. e.g. <see cref="T:System.Char" />.</typeparam>
            <typeparam name="TSequence">The type of the sequence objects. e.g. <see cref="T:System.String" /></typeparam>
            <typeparam name="TSubSequence">The type of the subsequence objects e.g. <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence" /></typeparam>
            <typeparam name="TValue">The type of the values that are mapped.</typeparam>
            <typeparam name="TNode">
                The concrete type of the
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTreeNode`6" />s used in this tree.
            </typeparam>
            <typeparam name="TEdge">
                The concrete type of the
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTreeEdge`6" />s used in this tree.
            </typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.PrefixSearchTree`6.Add(`1,`3)">
            <summary>
                Add a new key to value mapping.
            </summary>
            <param name="key">The key for the mapping.</param>
            <param name="value">The value that <paramref name="key" /> maps to.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.PrefixSearchTree`6.TryGetValue(`1,`3@)">
            <summary>
                TryGetValue the mapping for a given key.
            </summary>
            <param name="key">The key for which the mapped value is to be retrieved.</param>
            <param name="result">
                Set to the mapping for <paramref name="key" /> if one exists, <c>default(TLookupResult)</c>
                otherwise.
            </param>
            <returns><c>true</c> if there exists a mapping for <paramref name="key" />, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.PrefixSearchTree`6.GetOrCreate(`1,System.Func{`3})">
            <summary>
                Get or create the value for a key.
            </summary>
            <param name="key">The key.</param>
            <param name="factory">
                A function that creates a new value to map <paramref name="key" /> to.
            </param>
            <returns>The value mapped to <paramref name="key" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.PrefixSearchTree`6.PrefixLookup(`1)">
            <summary>
                Retrieves all mappings where a prefix matches the key.
            </summary>
            <param name="prefix">The prefix to be matched.</param>
            <returns>A sequence of results, where <paramref name="prefix" /> is the prefix of the key for each returned result.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.PrefixSearchTree`6.Clear">
            <summary>
                Clears all the mappings.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.PrefixSearchTree`6.Items">
            <summary>
                Retrieves all the mappings present in this set.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.PrefixSearchTree`6.Add(`2,`2,`3)">
            <summary>
                Add a new key to value mapping.
            </summary>
            <param name="traversalKey">The key to use while traversing the tree.</param>
            <param name="key">The key for the mapping.</param>
            <param name="value">The value that <paramref name="key" /> maps to.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.PrefixSearchTree`6.Lookup(`2,`3@)">
            <summary>
                Lookup the mapping for a given key.
            </summary>
            <param name="key">The key for which the mapped value is to be retrieved.</param>
            <param name="result">
                Set to the mapping for <paramref name="key" /> if one exists, <c>default(TLookupResult)</c>
                otherwise.
            </param>
            <returns><c>true</c> if there exists a mapping for <paramref name="key" />, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.PrefixSearchTree`6.PrefixLookup(`2)">
            <summary>
                Retrieves all mappings where a prefix matches the key.
            </summary>
            <param name="prefix">The prefix to be matched.</param>
            <returns>A sequence of results, where <paramref name="prefix" /> is the prefix of the key for each returned result.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.PrefixSearchTree`6.Accept``1(Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTreeVisitor{`0,`1,`2,`3,`4,`5,``0})">
            <summary>
                Accepts a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTreeVisitor`7" />
                that can traverse the tree.
            </summary>
            <typeparam name="TResult">The result produced by the visitor object.</typeparam>
            <param name="visitor">The visitor object.</param>
            <returns>The result produced by the visitor object.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.PrefixSearchTreeVisitor`7">
            <summary>
                A helper class that handles the traversal of a
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.PrefixSearchTree`6" />.
            </summary>
            <typeparam name="TSequenceable">The type of sequenceable objects e.g. <see cref="T:System.Char" />.</typeparam>
            <typeparam name="TSequence">The type of sequence objects e.g. <see cref="T:System.String" />.</typeparam>
            <typeparam name="TSubSequence">The type of sub-sequence objects e.g. <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence" />.</typeparam>
            <typeparam name="TValue">
                The value stored in the
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.PrefixSearchTree`6" />.
            </typeparam>
            <typeparam name="TNode">
                The node type of
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.PrefixSearchTree`6" />
            </typeparam>
            <typeparam name="TEdge">
                The edge type of
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.PrefixSearchTree`6" />
            </typeparam>
            <typeparam name="TResult">The result type returned by the visitor.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.PrefixSearchTreeVisitor`7.Visit(`4)">
            <summary>
                Visits (and possibly traverses) the tree rooted at this node.
            </summary>
            <param name="node">The node to visit.</param>
            <returns>A result based on the traversal of <paramref name="node" />.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.SuffixTree`3">
            <summary>
                A generic suffix tree.
            </summary>
            <typeparam name="TSequenceable">The type of sequenceable objects e.g. <see cref="T:System.Char" />.</typeparam>
            <typeparam name="TSequence">The type of the sequence objects e.g. <see cref="T:System.String" />.</typeparam>
            <typeparam name="TSubSequence">The type of sub sequence object e.g. <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence" />.</typeparam>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.SuffixTree`3.Converter">
            <summary>
                A delegate type for <typeparamref name="TSequenceable" /> transformers.
            </summary>
            <param name="c">The <typeparamref name="TSequenceable" /> instance to transform.</param>
            <returns>The transformed value of <paramref name="c" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.SuffixTree`3.FindTarget(System.Int32,Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.SuffixTree{`0,`1,`2}.ActivePoint)">
            <summary>
                Finds the target for the current insertion.
            </summary>
            <param name="index">The current index into the string.</param>
            <param name="activePoint">
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.SuffixTree`3.ActivePoint" /> object indicating the active node to insert at, the active
                index and the active length of suffixes left to insert into the tree.
            </param>
            <returns>A <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.SuffixTree`3.TargetStatus" /> value that indicates how the current suffix is to be handled.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.SuffixTree`3._Add(System.Int32,System.Int32)">
            <summary>
                This is an implementation of Ukkonen's algorithm.
                see: https://www.cs.helsinki.fi/u/ukkonen/SuffixT1withFigs.pdf
                for all the gory details. The highlights are:
                1. This is pretty much a compressed trie that stores all suffixes of a string.
                2. The difference is the use of "Suffix Links" which are cross-edges in the tree (not necessarily connecting nodes
                at the same "level"), which
                allow for constant time navigation between a branch of the tree that represents the "foo" suffix after "abc", i.e.,
                the suffix "abcfoo" and the
                branch of the tree that represents the suffix "foo" after "bc", i.e., the suffix "bcfoo". The suffix links allow us
                to traverse from the first node
                to the second, without having to re-traverse the trie from the root with the string "bcfoo".
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.SuffixTree`3.FindCommonSubSequences(System.Double,System.Double)">
            <summary>
                Finds the longest commmon contiguous subsequences, from among the input sequences contained in this
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.SuffixTree`3" />.
            </summary>
            <param name="minFraction">
                The minimum fraction of input sequences that the subsequence must occur in, must be in the
                range [0,1]
            </param>
            <param name="maxFraction">
                The maximum fraction of input sequences that the subsequence must occur in, must be in the
                range [0,1]
            </param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.SuffixTree`3.LookupPrefix(`1,System.Double,System.Double,Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.SuffixTree{`0,`1,`2}.Converter)">
            <summary>
                Returns the suffixes beginning with <paramref name="prefix" />, such that they are suffixes of at least
                <paramref name="minFraction" /> of sequences stored in this suffix tree and at most <paramref name="maxFraction" />
                of sequences stored in this suffix tree.
            </summary>
            <param name="prefix">The prefix that all returned sequences must begin with.</param>
            <param name="minFraction">The minimum fraction of sequences that any returned value is a suffix of.</param>
            <param name="maxFraction">The maximum fraction of sequences that any returned value is a suffix of.</param>
            <param name="caseInverter">
                A function that flips the case of <typeparamref name="TSequenceable" /> objects, if
                applicable.
            </param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.Trie`4">
            <summary>
                An implementation of an <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTree`4" />
                tree using a simple trie data structure.
            </summary>
            <typeparam name="TSequenceable">The type of the sequenceable objects. e.g. <see cref="T:System.Char" /></typeparam>
            <typeparam name="TSequence">The type of the sequence objects. e.g. <see cref="T:System.String" /></typeparam>
            <typeparam name="TSubSequence">
                The type of the objects used to represent sub-sequences. e.g.<see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence" />
            </typeparam>
            <typeparam name="TValue">The type of the values that are mapped by this tree.</typeparam>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieEdge`4">
            <summary>
                A generic class that implements an edge in <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.Trie`4" />
            </summary>
            <typeparam name="TSequenceable">The type of the sequenceable objects. e.g. <see cref="T:System.Char" /></typeparam>
            <typeparam name="TSequence">The type of the sequence objects. e.g. <see cref="T:System.String" /></typeparam>
            <typeparam name="TSubSequence">
                The type of the objects used to represent sub-sequences. e.g.<see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence" />
            </typeparam>
            <typeparam name="TValue">The type of the values that are mapped by this tree.</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieEdge`4.MatchedPrefix">
            <summary>
                The subsequence of the entire sequence that matches this edge.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieEdge`4.Parent">
            <summary>
                The EdgeToParent node of this edge.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieEdge`4.Child">
            <summary>
                The child node of this edge.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieEdge`4.ToString">
            <summary>Returns a string that represents the current object.</summary>
            <returns>A string that represents the current object.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieLeafNode`4">
            <summary>
                A generic class representing a leaf node in a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.Trie`4" />.
            </summary>
            <typeparam name="TSequenceable">The type of the sequenceable objects. e.g. <see cref="T:System.Char" /></typeparam>
            <typeparam name="TSequence">The type of the sequence objects. e.g. <see cref="T:System.String" /></typeparam>
            <typeparam name="TSubSequence">
                The type of the objects used to represent sub-sequences. e.g.<see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence" />
            </typeparam>
            <typeparam name="TValue">The type of the values that are mapped by this tree.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieLeafNode`4.#ctor(`2,`3,Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieEdge{`0,`1,`2,`3})">
            <summary>
                Constructor.
            </summary>
            <param name="key">The key held by this leaf node.</param>
            <param name="value">The value held by this leaf node.</param>
            <param name="edgeToParent">The edge to the parent.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieLeafNode`4.ChildFor(`2)">
            <summary>
                Return the edge corresponding to <paramref name="suffix" />.
            </summary>
            <param name="suffix">The prefix to match.</param>
            <returns>The edge corresponding to the prefix, if one exists, <c>default(TEdge)</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieLeafNode`4.AddEntry(`2,`3,`2)">
            <summary>
                Add the specified mapping to the tree, recursing if necessary.
            </summary>
            <param name="suffix">The unmatched suffix of the entire <paramref name="key" />.</param>
            <param name="value">The mapped value.</param>
            <param name="key">The key of the mapping.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieLeafNode`4.Lookup(`2,`3@)">
            <summary>
                TryGetValue the specified key in the tree.
            </summary>
            <param name="key">The key.</param>
            <param name="result">Set to the value mapped to the key if a mapping exists, <c>default(TLookupResult)</c> otherwise.</param>
            <returns><c>true</c> if a mapping for <paramref name="key" /> exists, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieLeafNode`4.LookupOrCreate(`2,`2,System.Func{`3})">
            <summary>
                Lookup a key, or update the old value mapped to the key.
            </summary>
            <param name="key">The key.</param>
            <param name="suffix">The suffix of the key yet to be matched.</param>
            <param name="factory">A function that computes a value, to be mapped for <paramref name="key" />.</param>
            <returns>The updated value mapped to <paramref name="key" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieLeafNode`4.LookupAll(`2)">
            <summary>
                Retrieves all results that are mapped to some extension of <paramref name="prefix" />.
            </summary>
            <param name="prefix">The prefix.</param>
            <returns>
                A sequence of <see cref="T:System.Collections.Generic.KeyValuePair`2" />s such that the <c>Key</c> field of each lookup
                result is
                an extension of <see cref="!:prefix" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieLeafNode`4.GetAllDescendants">
            <summary>
                Retrieve all the descendants of this node in the tree.
            </summary>
            <returns>A sequence of all descendants of this node in the tree.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieLeafNode`4.GetAllLeaves">
            <summary>
                Retrieves all the leaf nodes reachable from this node.
            </summary>
            <returns>A sequence of leaf nodes that are reachable from this node.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieLeafNode`4.GetEdges">
            <summary>
                Retrieves all the edges reachable from this node.
            </summary>
            <returns>A sequence of edges reachable from this node.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieNode`4">
            <summary>
                An abstract class that implements an
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.IPrefixSearchTreeNode`6" />
                for use with the <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.Trie`4" /> class.
            </summary>
            <typeparam name="TSequenceable">The type of the sequenceable objects. e.g. <see cref="T:System.Char" /></typeparam>
            <typeparam name="TSequence">The type of the sequence objects. e.g. <see cref="T:System.String" /></typeparam>
            <typeparam name="TSubSequence">
                The type of the objects used to represent sub-sequences. e.g.<see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence" />
            </typeparam>
            <typeparam name="TValue">The type of the values that are mapped by this tree.</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieNode`4.EdgeToParent">
            <summary>
                The edge to the parent of this node.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieNode`4.ChildFor(`2)">
            <summary>
                The child of this node corresponding to a given suffix.
            </summary>
            <param name="suffix">The suffix to match.</param>
            <returns>The child corresponding to the <paramref name="suffix" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieNode`4.AddEntry(`2,`3,`2)">
            <summary>
                Add the specified mapping to the tree, recursing if necessary.
            </summary>
            <param name="suffix">The unmatched suffix of the entire <paramref name="key" />.</param>
            <param name="value">The mapped value.</param>
            <param name="key">The key of the mapping.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieNode`4.Lookup(`2,`3@)">
            <summary>
                TryGetValue the specified key in the tree.
            </summary>
            <param name="key">The key.</param>
            <param name="result">Set to the value mapped to the key if a mapping exists, <c>default(TLookupResult)</c> otherwise.</param>
            <returns><c>true</c> if a mapping for <paramref name="key" /> exists, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieNode`4.LookupOrCreate(`2,`2,System.Func{`3})">
            <summary>
                Lookup a key, or update the old value mapped to the key.
            </summary>
            <param name="key">The key.</param>
            <param name="suffix">The suffix of the key yet to be matched.</param>
            <param name="factory">A function that computes a value, to be mapped for <paramref name="key" />.</param>
            <returns>The updated value mapped to <paramref name="key" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieNode`4.LookupAll(`2)">
            <summary>
                Retrieves all results that are mapped to some extension of <paramref name="prefix" />.
            </summary>
            <param name="prefix">The prefix.</param>
            <returns>
                A sequence of <see cref="T:System.Collections.Generic.KeyValuePair`2" />s such that the <c>Key</c> field of each lookup
                result is
                an extension of <see cref="!:prefix" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieNode`4.GetEdges">
            <summary>
                Retrieves all the edges reachable from this node.
            </summary>
            <returns>A sequence of edges reachable from this node.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieNode`4.GetAllDescendants">
            <summary>
                Retrieve all the descendants of this node in the tree.
            </summary>
            <returns>A sequence of all descendants of this node in the tree.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieNode`4.GetAllLeaves">
            <summary>
                Retrieves all the leaf nodes reachable from this node.
            </summary>
            <returns>A sequence of leaf nodes that are reachable from this node.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieSplitNode`4">
            <summary>
                A generic tree node class that implements a decision node in
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.Trie`4" />.
            </summary>
            <typeparam name="TSequenceable">The type of the sequenceable objects. e.g. <see cref="T:System.Char" /></typeparam>
            <typeparam name="TSequence">The type of the sequence objects. e.g. <see cref="T:System.String" /></typeparam>
            <typeparam name="TSubSequence">
                The type of the objects used to represent sub-sequences. e.g.<see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence" />
            </typeparam>
            <typeparam name="TValue">The type of the values that are mapped by this tree.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieSplitNode`4.#ctor(Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieEdge{`0,`1,`2,`3})">
            <summary>
                Constructor.
            </summary>
            <param name="edgeToParent">The edge to the parent of this node.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieSplitNode`4.ChildFor(`2)">
            <summary>
                The child of this node corresponding to a given suffix.
            </summary>
            <param name="suffix">The suffix to match.</param>
            <returns>The child corresponding to the <paramref name="suffix" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieSplitNode`4.AddEntry(`2,`3,`2)">
            <summary>
                Add the specified mapping to the tree, recursing if necessary.
            </summary>
            <param name="suffix">The unmatched suffix of the entire <paramref name="key" />.</param>
            <param name="key">The key of the mapping.</param>
            <param name="value">The mapped value.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieSplitNode`4.Lookup(`2,`3@)">
            <summary>
                TryGetValue the specified key in the tree.
            </summary>
            <param name="key">The key.</param>
            <param name="result">Set to the value mapped to the key if a mapping exists, <c>default(TLookupResult)</c> otherwise.</param>
            <returns><c>true</c> if a mapping for <paramref name="key" /> exists, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieSplitNode`4.LookupOrCreate(`2,`2,System.Func{`3})">
            <summary>
                Lookup a key, or create a mapping for the key.
            </summary>
            <param name="key">The key.</param>
            <param name="suffix">The suffix of the key yet to be matched.</param>
            <param name="factory">A function that computes a value, to be mapped for <paramref name="key" />.</param>
            <returns>The updated value mapped to <paramref name="key" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieSplitNode`4.LookupAll(`2)">
            <summary>
                Retrieves all results that are mapped to some extension of <paramref name="prefix" />.
            </summary>
            <param name="prefix">The prefix.</param>
            <returns>
                A sequence of <see cref="T:System.Collections.Generic.KeyValuePair`2" />s such that the <c>Key</c> field of each lookup
                result is
                an extension of <see cref="!:prefix" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieSplitNode`4.GetAllDescendants">
            <summary>
                Retrieve all the descendants of this node in the tree.
            </summary>
            <returns>A sequence of all descendants of this node in the tree.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieSplitNode`4.GetAllLeaves">
            <summary>
                Retrieves all the leaf nodes reachable from this node.
            </summary>
            <returns>A sequence of leaf nodes that are reachable from this node.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.TrieSplitNode`4.GetEdges">
            <summary>
                Retrieves all the edges reachable from this node.
            </summary>
            <returns>A sequence of edges reachable from this node.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.Suggestion">
            <summary>
                Represents an autocompletion suggestion
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.Suggestion.#ctor(Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleter,System.String,System.UInt32,System.String,System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object},System.String)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleter" /> that produced <c>this</c> <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.Suggestion" />.</param>
            <param name="prefixString">The full prefix used to generate this suggestion.</param>
            <param name="matchOffset">The index of the prefix from which the suggestions are an extension.</param>
            <param name="completionSuffix">The actual suggestion.</param>
            <param name="metadata">A property map containing any metadata associated with this suggestion.</param>
            /// <param name="suggestEventId">The ID for the suggestion list this suggestion appears in.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.Suggestion.SuggestEventId">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.Suggestion.Source">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.Suggestion.PrefixString">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.Suggestion.MatchOffset">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.Suggestion.CompletionSuffix">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.Suggestion.Metadata">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.Suggestion.CompleteValue">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.Suggestion.Equals(Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.ISuggestion)">
            <summary>
                Equality comparison
            </summary>
            <param name="other">The other <see cref="T:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.Suggestion" /> object.</param>
            <returns><c>true</c> if <c>this</c> is equal to <paramref name="other" />, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.Suggestion.Equals(System.Object)">
            <summary>
                Equality comparison
            </summary>
            <param name="other">The other object.</param>
            <returns><c>true</c> if <c>this</c> is equal to <paramref name="other" />, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.Suggestion.GetHashCode">
            <summary>
                Retrieves the hash code for this object.
            </summary>
            <returns>The hash code for this object.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.CompoundExtractionProgram`1">
            <summary>
                A compound program that returns a tree/table of multiple fields/columns.
            </summary>
            <typeparam name="TRegion">The region of the field.</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.CompoundExtractionProgram`1.Schema">
            <summary>
                The schema of this compound program.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.CompoundExtractionProgram`1.Run(System.String)">
            <summary>
                Parses <paramref name="inputText"/> into <typeparamref name="TRegion"/> and executes the program to obtain the tree output.
            </summary>
            <param name="inputText">The input document text.</param>
            <returns>The output tree.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.CompoundExtractionProgram`1.RunTable(`0,Microsoft.ProgramSynthesis.Wrangling.Schema.TreeToTableSemantics)">
            <summary>
                Executes the program on the <paramref name="input" /> to obtain the table output.
            </summary>
            <param name="input">The input token.</param>
            <param name="semantics">The semantics of generating the table. See <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Schema.TreeToTableSemantics" />.</param>
            <returns>The output table.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.CompoundExtractionProgram`1.RunTable(System.String,Microsoft.ProgramSynthesis.Wrangling.Schema.TreeToTableSemantics)">
            <summary>
                Parses <paramref name="inputText"/> into <typeparamref name="TRegion"/> and executes the program to obtain the table output.
            </summary>
            <param name="inputText">The input document text.</param>
            <param name="semantics">The semantics of generating the table. See <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Schema.TreeToTableSemantics" />.</param>
            <returns>The output table.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint`2">
            <summary>
                A constraint on a program's behavior. Applies to programs of type <see cref="T:Microsoft.ProgramSynthesis.Program`2" />. Use the
                <see cref="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint`2.Valid(Microsoft.ProgramSynthesis.Program{`0,`1})" /> or <see cref="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint`2.Valid(Microsoft.ProgramSynthesis.Program{`0,`1},System.Collections.Generic.IEnumerable{`0})" />
                method to validate a program according to a constraint.
            </summary>
            <typeparam name="TInput">Input type of programs this constraint applies to.</typeparam>
            <typeparam name="TOutput">Output type of programs this contraint applies to.</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint`2.IsSoft">
            <summary>
                If true, this constraint is not required to be satisfied.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint`2.Equals(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`0,`1})">
            <summary>Indicates whether the current constraint is equal to another constraint.</summary>
            <param name="other">A constraint to compare with this constraint.</param>
            <returns>true if the current constraint is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint`2.ConflictsWith(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`0,`1})">
            <summary>
                Checks if these constraints are obviously not valid together. That is, just by considering this and
                <paramref name="other" /> it is easy to tell that no program could possibly satisfy both of them. For instance, the
                two constraints could be examples that give different outputs.
            </summary>
            <param name="other">The constraint to check for conflicts.</param>
            <returns>
                True if the conjunction of the specifications of this constraint and <paramref name="other" /> is
                <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint`2.Valid(Microsoft.ProgramSynthesis.Program{`0,`1})">
            <summary>
                Validate a program against this constraint.
            </summary>
            <param name="program">The program that needs to validate.</param>
            <returns>The validation result.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint`2.Valid(Microsoft.ProgramSynthesis.Program{`0,`1},System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Validate a program against this constraint given <paramref name="inputs" /> as valid inputs to the program. Used
                for constraints that need an input to run the program but do not contain enough information to construct one.
            </summary>
            <param name="program">The program that needs to validate.</param>
            <param name="inputs">The inputs to use for validating the program.</param>
            <returns>The validation result.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint`2.Valid(Microsoft.ProgramSynthesis.Program{`0,`1},System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IReadOnlyCollection{Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`0,`1}})">
            <summary>
                Validate a program against this constraint given <paramref name="inputs" /> as valid inputs to the program. Used
                for constraints that need an input to run the program but do not contain enough information to construct one.
            </summary>
            <param name="program">The program that needs to validate.</param>
            <param name="inputs">The inputs to use for validating the program.</param>
            <param name="allConstraints">
                All constraints used to learn the program. Used by constraint whose meaning may be modified by other constraints.
            </param>
            <returns>The validation result.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint`2.op_Equality(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`0,`1},Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`0,`1})">
            <summary>
                Checks if two constraints are equal.
            </summary>
            <param name="left">The first constraint.</param>
            <param name="right">The second constraint.</param>
            <returns>
                True if <paramref name="left" /> and <paramref name="right" /> represent the same constraint on program
                behavior.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint`2.op_Inequality(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`0,`1},Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`0,`1})">
            <summary>
                Checks if two constraints are not equal.
            </summary>
            <param name="left">The first constraint.</param>
            <param name="right">The second constraint.</param>
            <returns>
                False if <paramref name="left" /> and <paramref name="right" /> represent the same constraint on program
                behavior.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint`2.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
            <returns>true if the specified object  is equal to the current object; otherwise, false.</returns>
            <param name="other">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint`2.GetHashCode">
            <summary>Serves as the default hash function. </summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint`2.PossibleInput">
            <summary>
                A value which might be a valid input. Used to get an input out of
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2" /> without needing to be able express the generic type
                argument <c>TInputMember</c>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInput`2">
            <summary>
                Supertype for constraints that have an explicit input value.
            </summary>
            <typeparam name="TInput">Input type of programs this constraint applies to.</typeparam>
            <typeparam name="TOutput">Output type of programs this constraint applies to.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInput`2.#ctor(`0,System.Boolean)">
            <summary>
                Constructs constraint on an input.
            </summary>
            <param name="input">Program input this constraint applies to.</param>
            <param name="isSoft">If true, this is a soft (optional) constraint.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInput`2.Input">
            <summary>
                Input this constraint applies to.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInput`2.IsSoft">
            <summary>
                If true, this constraint is not required to be satisfied.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInput`2.Equals(Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInput{`0,`1})">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInput`2.Equals(System.Object)">
            <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="other">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInput`2.GetHashCode">
            <summary>
                Serves as the default hash function.
            </summary>
            <returns>
                A hash code for the current object.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2">
            <summary>
                Supertype for constraints that reference an element of the input <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            </summary>
            <typeparam name="TInputMember">Member type of input type of programs this constraint applies to.</typeparam>
            <typeparam name="TOutput">Output type of programs this constraint applies to.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.#ctor(`0,System.Boolean)">
            <summary>
                Constructs constraint on an input member.
            </summary>
            <param name="inputMember">This constraint applies to all inputs that contain this value.</param>
            <param name="isSoft">If true, this is a soft (optional) constraint.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember">
            <summary>
                Member of program input this constraint applies to. This constraint applies to any input collection that contains
                this member.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.PossibleInput">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.IsSoft">
            <summary>
                If true, this constraint is not required to be satisfied.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.Equals(Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember{`0,`1})">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.Valid(Microsoft.ProgramSynthesis.Program{System.Collections.Generic.IEnumerable{`0},`1})">
            <summary>
                Validate a program against this constraint.
            </summary>
            <param name="program">The program that needs to validate.</param>
            <returns>The validation result.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.Valid(Microsoft.ProgramSynthesis.Program{System.Collections.Generic.IEnumerable{`0},`1},System.Collections.Generic.IReadOnlyList{`0},`1)">
            <summary>
                Validate a program against this constraint for the given input and corresponding output.
            </summary>
            <param name="program">The program that needs to validate.</param>
            <param name="input">The input given to the program.</param>
            <param name="output">The output of <paramref name="program" /> on <paramref name="input" />.</param>
            <returns>The validation result.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.Valid(Microsoft.ProgramSynthesis.Program{System.Collections.Generic.IEnumerable{`0},`1},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`0}})">
            <summary>
                Validate a program against this constraint given <paramref name="inputs" /> as valid inputs to the program. Used
                for constraints that need an input to run the program but do not contain enough information to construct one.
            </summary>
            <param name="program">The program that needs to validate.</param>
            <param name="inputs">The inputs to use for validating the program.</param>
            <returns>The validation result.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.Equals(System.Object)">
            <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="other">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.GetHashCode">
            <summary>
                Serves as the default hash function.
            </summary>
            <returns>
                A hash code for the current object.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintUtil">
            <summary>
                Utility methods for working with constraints.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintUtil.SelectOutputSubmembers``2(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``1}}}})">
            <summary>
                Selects all of the output submembers referenced in <paramref name="xs" />. The constraints are over programs whose
                outputs are a list of lists of output submembers, and may include information on an entire output, one of the
                output lists, or just a single output submember. This method handles all of those cases and collects all of the
                output submembers.
            </summary>
            <typeparam name="TInputMember">Member type of inputs to the programs these constraints are over.</typeparam>
            <typeparam name="TOutputSubmember">Submember type of outputs of the programs these constraints are over.</typeparam>
            <param name="xs">Constraints to extract output submembers from.</param>
            <returns>All of the output submembers in <paramref name="xs" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintUtil.SelectOutputMembers``2(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{``0,System.Collections.Generic.IEnumerable{``1}}})">
            <summary>
                Selects all of the output members referenced in <paramref name="xs" />. The constraints are over programs whose
                outputs are a list of output members, and may include information on an entire output or just a single output
                member. This method handles all of those cases and collects all of the output members.
            </summary>
            <typeparam name="TInput">Type of inputs to the programs these constraints are over.</typeparam>
            <typeparam name="TOutputMember">Member type of outputs of the programs these constraints are over.</typeparam>
            <param name="xs">Constraints to extract output members from.</param>
            <returns>All of the output members in <paramref name="xs" />.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.CorrespondingMemberDoesNotEqual`2">
            <summary>
                Constraint that checks that the output member corresponding to a given input member is not a specific value.
            </summary>
            <typeparam name="TInputMember">Member type of collections of the input type of programs this constraint applies to.</typeparam>
            <typeparam name="TOutputMember">Member type of collections of the output type of programs this constraint applies to.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.CorrespondingMemberDoesNotEqual`2.#ctor(`0,`1,System.Boolean)">
            <summary>
                Constructs a constraint that checks that a program run on an input containing <paramref name="inputMember" /> does
                not output <paramref name="outputMember" /> in the corresponding place in the output. For example, if the fourth
                element of the input to the program is <paramref name="inputMember" />, the fourth element of the output must not
                be <paramref name="outputMember" />.
            </summary>
            <param name="inputMember">The input member this constraint is on.</param>
            <param name="outputMember">
                Disallowed corresponding output member of the program when run on
                <paramref name="inputMember" />.
            </param>
            <param name="isSoft">If true, this is a soft (optional) constraint.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.CorrespondingMemberDoesNotEqual`2.Valid(Microsoft.ProgramSynthesis.Program{System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1}},`1)">
            <summary>
                Validate a program against this constraint for the given output member corresponding to
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" />.
            </summary>
            <param name="program">The program that needs to validate.</param>
            <param name="programOutputMember">
                The output member of the program when run on a sequence containing
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" /> that appears at the corresponding position
                in the output.
            </param>
            <returns>
                False if <paramref name="programOutputMember" /> equals
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToMemberConstraint`2.OutputMember" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.CorrespondingMemberDoesNotEqual`2.ConflictsWith(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1}})">
            <summary>
                Checks if these constraints are obviously not valid together. That is, just by considering this and
                <paramref name="other" /> it is easy to tell that no program could possibly satisfy both of them. For instance, the
                two constraints could be examples that give different outputs.
            </summary>
            <param name="other">The constraint to check for conflicts.</param>
            <returns>
                True if the conjunction of the specifications of this constraint and <paramref name="other" /> is
                <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.CorrespondingMemberDoesNotEqual`2.ToString">
            <summary>
                Returns a string that shows the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" /> and
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToMemberConstraint`2.OutputMember" /> regions.
            </summary>
            <returns>
                A string that represents this constraint.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.CorrespondingMemberDoesNotIntersect`1">
            <summary>
                Constraint that checks that the output member corresponding to a given input member does not intersect a specific
                region.
            </summary>
            <typeparam name="TRegion">
                Member type of collections of the input and output types of programs this constraint applies
                to.
            </typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.CorrespondingMemberDoesNotIntersect`1.#ctor(`0,`0,System.Boolean)">
            <summary>
                Constructs a constraint that checks that a program run on an input containing <paramref name="inputMember" /> does
                not output a region intersecting <paramref name="outputMember" /> in the corresponding place in the output. For
                example, if the fourth element of the input to the program is <paramref name="inputMember" />, the fourth element
                of the output must not intersect <paramref name="outputMember" />.
            </summary>
            <param name="inputMember">The input member this constraint is on.</param>
            <param name="outputMember">Region the output of the program on <paramref name="inputMember" /> must not intersect.</param>
            <param name="isSoft">If true, this is a soft (optional) constraint.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.CorrespondingMemberDoesNotIntersect`1.Valid(Microsoft.ProgramSynthesis.Program{System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0}},`0)">
            <summary>
                Validate a program against this constraint for the given output member corresponding to
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" />.
            </summary>
            <param name="program">The program that needs to validate.</param>
            <param name="programOutputMember">
                The output member of the program when run on a sequence containing
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" /> that appears at the corresponding position
                in the output.
            </param>
            <returns>
                False if <paramref name="programOutputMember" /> intersects
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToMemberConstraint`2.OutputMember" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.CorrespondingMemberDoesNotIntersect`1.ConflictsWith(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0}})">
            <summary>
                Checks if these constraints are obviously not valid together. That is, just by considering this and
                <paramref name="other" /> it is easy to tell that no program could possibly satisfy both of them. For instance, the
                two constraints could be examples that give different outputs.
            </summary>
            <param name="other">The constraint to check for conflicts.</param>
            <returns>
                True if the conjunction of the specifications of this constraint and <paramref name="other" /> is
                <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.CorrespondingMemberDoesNotIntersect`1.ToString">
            <summary>
                Returns a string that shows the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" /> and
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToMemberConstraint`2.OutputMember" /> regions.
            </summary>
            <returns>
                A string that represents this example.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.CorrespondingMemberEquals`2">
            <summary>
                Constraint that checks that the output member corresponding to a given input member is of the expected value.
            </summary>
            <typeparam name="TInputMember">Member type of collections of the input type of programs this constraint applies to.</typeparam>
            <typeparam name="TOutputMember">Member type of collections of the output type of programs this constraint applies to.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.CorrespondingMemberEquals`2.#ctor(`0,`1,System.Boolean)">
            <summary>
                Constructs a constraint that checks that a program run on an input containing <paramref name="inputMember" />
                outputs <paramref name="outputMember" /> in the corresponding place in the output. For example, if the fourth
                element of the input to the program is <paramref name="inputMember" />, the fourth element of the output should be
                <paramref name="outputMember" />.
            </summary>
            <param name="inputMember">The input member this constraint is on.</param>
            <param name="outputMember">Output member of the program when run on <paramref name="inputMember" />.</param>
            <param name="isSoft">If true, this is a soft (optional) constraint.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.CorrespondingMemberEquals`2.Valid(Microsoft.ProgramSynthesis.Program{System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1}},`1)">
            <summary>
                Validate a program against this constraint for the given output member corresponding to
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" />.
            </summary>
            <param name="program">The program that needs to validate.</param>
            <param name="programOutputMember">
                The output member of the program when run on a sequence containing
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" /> that appears at the corresponding position
                in the output.
            </param>
            <returns>
                True if <paramref name="programOutputMember" /> equals
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToMemberConstraint`2.OutputMember" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.CorrespondingMemberEquals`2.ConflictsWith(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1}})">
            <summary>
                Checks if these constraints are obviously not valid together. That is, just by considering this and
                <paramref name="other" /> it is easy to tell that no program could possibly satisfy both of them. For instance, the
                two constraints could be examples that give different outputs.
            </summary>
            <param name="other">The constraint to check for conflicts.</param>
            <returns>
                True if the conjunction of the specifications of this constraint and <paramref name="other" /> is
                <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.CorrespondingMemberEquals`2.ToString">
            <summary>
                Returns a string that shows the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" /> and
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToMemberConstraint`2.OutputMember" /> regions.
            </summary>
            <returns>
                A string that represents this constraint.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.DoesNotEqual`2">
            <summary>
                Specifies an invalid output for a specific input.
            </summary>
            <typeparam name="TInput">Input type of programs this constraint applies to.</typeparam>
            <typeparam name="TOutput">Output type of programs this constraint applies to.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.DoesNotEqual`2.#ctor(`0,`1,System.Boolean)">
            <summary>
                Construct a constraint requiring that the output of a program on <paramref name="input" /> is not
                <paramref name="output" />.
            </summary>
            <param name="input">Program input this constraint applies to.</param>
            <param name="output">Invalid program output for <paramref name="input" />.</param>
            <param name="isSoft">If true, this is a soft (optional) constraint.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.DoesNotEqual`2.Valid(Microsoft.ProgramSynthesis.Program{`0,`1})">
            <summary>
                Validate a program against this constraint.
            </summary>
            <param name="program">The program that needs to validate.</param>
            <returns>The validation result.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.DoesNotEqual`2.ConflictsWith(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`0,`1})">
            <summary>
                Checks if these constraints are obviously not valid together. That is, just by considering this and
                <paramref name="other" /> it is easy to tell that no program could possibly satisfy both of them. For instance, the
                two constraints could be examples that give different outputs.
            </summary>
            <param name="other">The constraint to check for conflicts.</param>
            <returns>
                True if the conjunction of the specifications of this constraint and <paramref name="other" /> is
                <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.DoesNotEqual`2.ToString">
            <summary>
                Returns a string that shows the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInput`2.Input" /> and
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToValueConstraint`2.Output" /> regions.
            </summary>
            <returns>
                A string that represents this example.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.DoesNotIntersect`1">
            <summary>
                When run on the specified input, the program does not output a region intersecting the given region.
            </summary>
            <typeparam name="TRegion">Region type of programs this constraint applies to.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.DoesNotIntersect`1.#ctor(`0,`0,System.Boolean)">
            <summary>
                Constructs a constraint requiring the when run on <paramref name="input" />, the program does not output a region
                intersecting <paramref name="output" />.
            </summary>
            <param name="input">Program input this constraint applies to.</param>
            <param name="output">Region the output on <paramref name="input" /> may not intersect.</param>
            <param name="isSoft">If true, this is a soft (optional) constraint.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.DoesNotIntersect`1.Valid(Microsoft.ProgramSynthesis.Program{`0,`0})">
            <summary>
                Validate a program against this constraint.
            </summary>
            <param name="program">The program that needs to validate.</param>
            <returns>
                False if running <paramref name="program" /> on <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInput`2.Input" /> results in a
                region which intersects with <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToValueConstraint`2.Output" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.DoesNotIntersect`1.ConflictsWith(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`0,`0})">
            <summary>
                Checks if these constraints are obviously not valid together. That is, just by considering this and
                <paramref name="other" /> it is easy to tell that no program could possibly satisfy both of them. For instance, the
                two constraints could be examples that give different outputs.
            </summary>
            <param name="other">The constraint to check for conflicts.</param>
            <returns>
                True if the conjunction of the specifications of this constraint and <paramref name="other" /> is
                <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.DoesNotIntersect`1.ToString">
            <summary>
                Returns a string that shows the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInput`2.Input" /> and
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToValueConstraint`2.Output" /> regions.
            </summary>
            <returns>
                A string that represents this example.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.DoesNotIntersectSequence`1">
            <summary>
                Constraint that no element of the output sequence for a specific input may intersect a specific region.
            </summary>
            <typeparam name="TRegion">Region type of programs this constraint applies to.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.DoesNotIntersectSequence`1.#ctor(`0,`0,System.Boolean)">
            <summary>
                Constructs a constraint requiring the when run on <paramref name="input" />, the program does not output any
                regions intersecting <paramref name="output" />.
            </summary>
            <param name="input">Program input this constraint applies to.</param>
            <param name="output">Region the output on <paramref name="input" /> may not intersect.</param>
            <param name="isSoft">If true, this is a soft (optional) constraint.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.DoesNotIntersectSequence`1.Valid(Microsoft.ProgramSynthesis.Program{`0,System.Collections.Generic.IEnumerable{`0}})">
            <summary>
                Validate a program against this constraint.
            </summary>
            <param name="program">The program that needs to validate.</param>
            <returns>
                False if <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToMemberConstraint`2.OutputMember" /> intersects any of the
                outputs when <paramref name="program" /> is run on <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInput`2.Input" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.DoesNotIntersectSequence`1.ConflictsWith(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`0,System.Collections.Generic.IEnumerable{`0}})">
            <summary>
                Checks if these constraints are obviously not valid together. That is, just by considering this and
                <paramref name="other" /> it is easy to tell that no program could possibly satisfy both of them. For instance, the
                two constraints could be examples that give different outputs.
            </summary>
            <param name="other">The constraint to check for conflicts.</param>
            <returns>
                True if the conjunction of the specifications of this constraint and <paramref name="other" /> is
                <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.DoesNotIntersectSequence`1.ToString">
            <summary>
                Returns a string that shows the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInput`2.Input" /> and
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToMemberConstraint`2.OutputMember" /> regions.
            </summary>
            <returns>
                A string that represents this constraint.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.DoesNotIntersectSequenceMember`1">
            <summary>
                Constraint that no element of the output sequence corresponding to specific input member may intersect a specific
                region.
            </summary>
            <typeparam name="TRegion">Region type of programs this constraint applies to.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.DoesNotIntersectSequenceMember`1.#ctor(`0,`0,System.Boolean)">
            <summary>
                Constructs a constraint requiring the when run on <paramref name="inputMember" />, the program does not output any
                regions intersecting <paramref name="outputSubmember" />.
            </summary>
            <param name="inputMember">Program input member this constraint applies to.</param>
            <param name="outputSubmember">Region the output on <paramref name="inputMember" /> may not intersect.</param>
            <param name="isSoft">If true, this is a soft (optional) constraint.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.DoesNotIntersectSequenceMember`1.Valid(Microsoft.ProgramSynthesis.Program{System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`0}}},System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Validate a program against this constraint for the given output member corresponding to
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" />.
            </summary>
            <param name="program">The program that needs to validate.</param>
            <param name="outputMember">
                The output member of the program when run on a sequence containing
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" /> that appears at the corresponding position
                in the output. This has some relation (defined by the subclass) to
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToSubmemberConstraint`2.OutputSubmember" />.
            </param>
            <returns>
                False if <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToSubmemberConstraint`2.OutputSubmember" /> intersects any of the
                outputs when <paramref name="program" /> is run on
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.DoesNotIntersectSequenceMember`1.ConflictsWith(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`0}}})">
            <summary>
                Checks if these constraints are obviously not valid together. That is, just by considering this and
                <paramref name="other" /> it is easy to tell that no program could possibly satisfy both of them. For instance, the
                two constraints could be examples that give different outputs.
            </summary>
            <param name="other">The constraint to check for conflicts.</param>
            <returns>
                True if the conjunction of the specifications of this constraint and <paramref name="other" /> is
                <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.DoesNotIntersectSequenceMember`1.ToString">
            <summary>
                Returns a string that shows the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" /> and
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToSubmemberConstraint`2.OutputSubmember" /> regions.
            </summary>
            <returns>
                A string that represents this constraint.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.EntityDetectorsMapConstraint`2">
            <summary>
                EntityDetectors Constraint that helps in setting up the EntityDetectorMap option for involved witnesses.
            </summary>
            <typeparam name="TInput">Input type of programs this constraint applies to.</typeparam>
            <typeparam name="TOutput">Output type of programs this constraint applies to.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.EntityDetectorsMapConstraint`2.Equals(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.EntityDetectorsMapConstraint`2.ConflictsWith(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.EntityDetectorsMapConstraint`2.Valid(Microsoft.ProgramSynthesis.Program{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.EntityDetectorsMapConstraint`2.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.Example`2">
            <summary>
                Equality constraint on the output of a program for a given input.
            </summary>
            <typeparam name="TInput">Input type of programs this constraint applies to.</typeparam>
            <typeparam name="TOutput">Output type of programs this constraint applies to.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.Example`2.#ctor(`0,`1,System.Boolean)">
            <summary>
                Constructs an input/output example.
            </summary>
            <param name="input">Program input this constraint applies to.</param>
            <param name="output">Value program must output when run on <paramref name="input" />.</param>
            <param name="isSoft">If true, this is a soft (optional) constraint.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.Example`2.Valid(Microsoft.ProgramSynthesis.Program{`0,`1})">
            <summary>
                Validate a program against this constraint.
            </summary>
            <param name="program">The program that needs to validate.</param>
            <returns>The validation result.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.Example`2.ConflictsWith(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`0,`1})">
            <summary>
                Checks if these constraints are obviously not valid together. That is, just by considering this and
                <paramref name="other" /> it is easy to tell that no program could possibly satisfy both of them. For instance, the
                two constraints could be examples that give different outputs.
            </summary>
            <param name="other">The constraint to check for conflicts.</param>
            <returns>
                True if the conjunction of the specifications of this constraint and <paramref name="other" /> is
                <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.Example`2.ToString">
            <summary>
                Returns a string that shows the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInput`2.Input" /> and
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToValueConstraint`2.Output" />.
            </summary>
            <returns>
                A string that represents this example.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.IConstraint">
            <summary>
                A constraint on a program's behavior.
            </summary>
            <seealso cref="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint`2" />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.IConstraint.IsSoft">
            <summary>
                If true, this constraint is not required to be satisfied.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.DSLOptions">
            <summary>
                Abstract base class containing options common to all DSLs.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.DSLOptions.SynthesisLogFilenamePrefix">
            <summary>
                If <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" />, don't enable synthesis log; otherwise, log to a filename starting with this
                string (may be <c>null</c> to just enable logging without specifying a filename).
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.DSLOptions.LogInfo">
            <summary>
                If <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.DSLOptions.SynthesisLogFilenamePrefix" /> is not <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" />, then the
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.DSLOptions.LogInfo" /> level to log.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.DSLOptions.UseDynamicSoundnessCheck">
            <summary>
                Sets <see cref="P:Microsoft.ProgramSynthesis.Learning.SynthesisEngine.Config.UseDynamicSoundnessCheck" /> for debugging.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.DSLOptions.EntityDetectorsMap">
            <summary>
                If <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" />, don't initialize entity detector map.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.IOptionConstraint`1">
            <summary>
                Marker interface for constraints that write their information to an <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.DSLOptions" /> object.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.IOptionConstraint`1.SetOptions(`0)">
            <summary>
                Set the options defined by this constraint in <paramref name="options" />.
            </summary>
            <param name="options">The <typeparamref name="TOptions" /> object to mutate.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.KnownProgram`2">
            <summary>
                Provides a <see cref="T:Microsoft.ProgramSynthesis.Program`2" /> that is known to be a good program for a similar synthesis task.
                The resulting program should be similar to this known program as much as possible.
            </summary>
            <typeparam name="TInput">Input type of the program.</typeparam>
            <typeparam name="TOutput">Output type of the program.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.KnownProgram`2.#ctor(Microsoft.ProgramSynthesis.Program{`0,`1})">
            <summary>
                Constructs a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.KnownProgram`2" /> constraint wrapping <paramref name="program" />.
            </summary>
            <param name="program">
                A <see cref="T:Microsoft.ProgramSynthesis.Program`2" /> that the learned program should be similar to if
                possible.
            </param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.KnownProgram`2.Program">
            <summary>
                A <see cref="T:Microsoft.ProgramSynthesis.Program`2" /> that the learned program should be similar to if possible.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.KnownProgram`2.Equals(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`0,`1})">
            <summary>Indicates whether the current constraint is equal to another constraint.</summary>
            <param name="other">A constraint to compare with this constraint.</param>
            <returns>true if the current constraint is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.KnownProgram`2.ConflictsWith(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`0,`1})">
            <summary>
                Checks if these constraints are obviously not valid together. That is, just by considering this and
                <paramref name="other" /> it is easy to tell that no program could possibly satisfy both of them. For instance, the
                two constraints could be examples that give different outputs.
            </summary>
            <param name="other">The constraint to check for conflicts.</param>
            <returns>
                True if the conjunction of the specifications of this constraint and <paramref name="other" /> is
                <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.KnownProgram`2.Valid(Microsoft.ProgramSynthesis.Program{`0,`1})">
            <summary>
                Validate a program against this constraint.
            </summary>
            <param name="program">The program that needs to validate.</param>
            <returns>The validation result.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.KnownProgram`2.GetHashCode">
            <summary>Serves as the default hash function. </summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberPrefix`2">
            <summary>
                Constraint that corresponding output member <see cref="T:System.Collections.Generic.IEnumerable`1" /> must begin with a given prefix.
            </summary>
            <typeparam name="TInputMember">Member type of collections of the input type of programs this constraint applies to.</typeparam>
            <typeparam name="TOutputSubmember">
                Member type of element type of collections of the output type of programs this constraint
                applies to.
            </typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberPrefix`2.#ctor(`0,System.Collections.Generic.IEnumerable{`1},System.Boolean)">
            <summary>
                Constructs a constraint requiring the when run on <paramref name="inputMember" />, the corresponding program output
                member begins with <paramref name="outputMember" />.
            </summary>
            <param name="inputMember">Program input member this constraint applies to.</param>
            <param name="outputMember">Required prefix for the corresponding output.</param>
            <param name="isSoft">If true, this is a soft (optional) constraint.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberPrefix`2.Valid(Microsoft.ProgramSynthesis.Program{System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`1}}},System.Collections.Generic.IEnumerable{`1})">
            <summary>
                Validate a program against this constraint for the given output member corresponding to
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" />.
            </summary>
            <param name="program">The program that needs to validate.</param>
            <param name="programOutputMember">
                The output member of the program when run on a sequence containing
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" />
                that appears at the corresponding position in the output.
            </param>
            <returns>
                True if <paramref name="programOutputMember" /> begins with
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToMemberConstraint`2.OutputMember" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberPrefix`2.ConflictsWith(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`1}}})">
            <summary>
                Checks if these constraints are obviously not valid together. That is, just by considering this and
                <paramref name="other" /> it is easy to tell that no program could possibly satisfy both of them. For instance, the
                two constraints could be examples that give different outputs.
            </summary>
            <param name="other">The constraint to check for conflicts.</param>
            <returns>
                True if the conjunction of the specifications of this constraint and <paramref name="other" /> is
                <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberPrefix`2.ToString">
            <summary>
                Returns a string that shows the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" /> and
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToMemberConstraint`2.OutputMember" /> regions.
            </summary>
            <returns>
                A string that represents this prefix constraint.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberSubset`2">
            <summary>
                Constraint that corresponding output member <see cref="T:System.Collections.Generic.IEnumerable`1" /> must contain the given subset.
            </summary>
            <typeparam name="TInputMember">Member type of collections of the input type of programs this constraint applies to.</typeparam>
            <typeparam name="TOutputSubmember">
                Member type of element type of collections of the output type of programs this constraint
                applies to.
            </typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberSubset`2.#ctor(`0,System.Collections.Generic.IEnumerable{`1},System.Boolean)">
            <summary>
                Constructs a constraint requiring the when run on <paramref name="inputMember" />, the corresponding program output
                member is a superset of <paramref name="outputMember" />.
            </summary>
            <param name="inputMember">Program input member this constraint applies to.</param>
            <param name="outputMember">Required subset of the corresponding output.</param>
            <param name="isSoft">If true, this is a soft (optional) constraint.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberSubset`2.Valid(Microsoft.ProgramSynthesis.Program{System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`1}}},System.Collections.Generic.IEnumerable{`1})">
            <summary>
                Validate a program against this constraint for the given output member corresponding to
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" />.
            </summary>
            <param name="program">The program that needs to validate.</param>
            <param name="programOutputMember">
                The output member of the program when run on a sequence containing
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" /> that appears at the corresponding position
                in the output.
            </param>
            <returns>
                True if <paramref name="programOutputMember" /> is a superset of
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToMemberConstraint`2.OutputMember" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberSubset`2.ConflictsWith(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`1}}})">
            <summary>
                Checks if these constraints are obviously not valid together. That is, just by considering this and
                <paramref name="other" /> it is easy to tell that no program could possibly satisfy both of them. For instance, the
                two constraints could be examples that give different outputs.
            </summary>
            <param name="other">The constraint to check for conflicts.</param>
            <returns>
                True if the conjunction of the specifications of this constraint and <paramref name="other" /> is
                <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberSubset`2.ToString">
            <summary>
                Returns a string that shows the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" /> and
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToMemberConstraint`2.OutputMember" /> regions.
            </summary>
            <returns>
                A string that represents this subset constraint.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToMemberConstraint`2">
            <summary>
                Supertype for constraints that have an element of an input collection and an element of an output collection.
            </summary>
            <typeparam name="TInputMember">Member type of collections of the input type of programs this constraint applies to.</typeparam>
            <typeparam name="TOutputMember">Member type of collections of the output type of programs this constraint applies to.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToMemberConstraint`2.#ctor(`0,`1,System.Boolean)">
            <summary>
                Constructs a constraint on an input member and its corresponding output member. This only makes sense for programs
                that perform something like a map operation; this is, the input is a list and the program generates a list of
                outputs that correspond to the inputs.
            </summary>
            <param name="inputMember">The input member this constraint is on.</param>
            <param name="outputMember">The corresponding output this constraint references.</param>
            <param name="isSoft">If true, this is a soft (optional) constraint.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToMemberConstraint`2.OutputMember">
            <summary>
                Member of program output this constraint references. This has some relation (defined by the subclass) to the output
                of the program corresponding to <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToMemberConstraint`2.Equals(Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToMemberConstraint{`0,`1})">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToMemberConstraint`2.Valid(Microsoft.ProgramSynthesis.Program{System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1}},`1)">
            <summary>
                Validate a program against this constraint for the given output member corresponding to
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" />.
            </summary>
            <param name="program">The program that needs to validate.</param>
            <param name="programOutputMember">
                The output member of the program when run on a sequence containing
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" /> that appears at the corresponding position
                in the output.
            </param>
            <returns>The validation result.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToMemberConstraint`2.Valid(Microsoft.ProgramSynthesis.Program{System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1}},System.Collections.Generic.IReadOnlyList{`0},System.Collections.Generic.IEnumerable{`1})">
            <summary>
                Validate a program against this constraint for the given input and corresponding output.
            </summary>
            <param name="program">The program that needs to validate.</param>
            <param name="input">The input given to the program.</param>
            <param name="output">The output of <paramref name="program" /> on <paramref name="input" />.</param>
            <returns>The validation result.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToMemberConstraint`2.Equals(System.Object)">
            <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="other">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToMemberConstraint`2.Equals(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1}})">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToMemberConstraint`2.GetHashCode">
            <summary>
                Serves as the default hash function.
            </summary>
            <returns>
                A hash code for the current object.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToSubmemberConstraint`2">
            <summary>
                Supertype for constraints that have an element of an input collection and an element of an element of an output
                collection.
            </summary>
            <typeparam name="TInputMember">Member type of collections of the input type of programs this constraint applies to.</typeparam>
            <typeparam name="TOutputSubmember">
                Member type of element type of collections of the output type of programs this constraint
                applies to.
            </typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToSubmemberConstraint`2.#ctor(`0,`1,System.Boolean)">
            <summary>
                Constructs a constraint on an input member and a member of its corresponding output member. This only makes sense
                for programs that perform something like a map operation; this is, the input is a list and the program generates a
                list of outputs that correspond to the inputs.
            </summary>
            <param name="inputMember">The input member this constraint is on.</param>
            <param name="outputSubmember">
                The output submember this constraint references; has to do with the output member
                corresponding to <paramref name="inputMember" />.
            </param>
            <param name="isSoft">If true, this is a soft (optional) constraint.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToSubmemberConstraint`2.OutputSubmember">
            <summary>
                Submember of program output this constraint references. This has some relation (defined by the subclass) to the
                output of the program corresponding to <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToSubmemberConstraint`2.Equals(Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToSubmemberConstraint{`0,`1})">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToSubmemberConstraint`2.Valid(Microsoft.ProgramSynthesis.Program{System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`1}}},System.Collections.Generic.IEnumerable{`1})">
            <summary>
                Validate a program against this constraint for the given output member corresponding to
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" />.
            </summary>
            <param name="program">The program that needs to validate.</param>
            <param name="outputMember">
                The output member of the program when run on a sequence containing
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" /> that appears at the corresponding position
                in the output. This has some relation (defined by the subclass) to <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToSubmemberConstraint`2.OutputSubmember" />.
            </param>
            <returns>The validation result.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToSubmemberConstraint`2.Valid(Microsoft.ProgramSynthesis.Program{System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`1}}},System.Collections.Generic.IReadOnlyList{`0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`1}})">
            <summary>
                Validate a program against this constraint for the given input and corresponding output.
            </summary>
            <param name="program">The program that needs to validate.</param>
            <param name="input">The input given to the program.</param>
            <param name="output">The output of <paramref name="program" /> on <paramref name="input" />.</param>
            <returns>The validation result.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToSubmemberConstraint`2.Equals(System.Object)">
            <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="other">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToSubmemberConstraint`2.Equals(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`1}}})">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToSubmemberConstraint`2.GetHashCode">
            <summary>
                Serves as the default hash function.
            </summary>
            <returns>
                A hash code for the current object.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.NegativeMemberSubset`2">
            <summary>
                Constraint that corresponding output member <see cref="T:System.Collections.Generic.IEnumerable`1" /> must not contain any of the given
                elements.
            </summary>
            <typeparam name="TInputMember">Member type of collections of the input type of programs this constraint applies to.</typeparam>
            <typeparam name="TOutputSubmember">
                Member type of element type of collections of the output type of programs this constraint
                applies to.
            </typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.NegativeMemberSubset`2.#ctor(`0,System.Collections.Generic.IEnumerable{`1},System.Boolean)">
            <summary>
                Constructs a constraint requiring the when run on <paramref name="inputMember" />, the corresponding program output
                member does not contain any of <paramref name="outputMember" />.
            </summary>
            <param name="inputMember">Program input member this constraint applies to.</param>
            <param name="outputMember">Forbidden elements of the corresponding output.</param>
            <param name="isSoft">If true, this is a soft (optional) constraint.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.NegativeMemberSubset`2.Valid(Microsoft.ProgramSynthesis.Program{System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`1}}},System.Collections.Generic.IEnumerable{`1})">
            <summary>
                Validate a program against this constraint for the given output member corresponding to
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" />.
            </summary>
            <param name="program">The program that needs to validate.</param>
            <param name="programOutputMember">
                The output member of the program when run on a sequence containing
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" /> that appears at the corresponding position
                in the output.
            </param>
            <returns>
                False if <paramref name="programOutputMember" /> contains any elements of
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToMemberConstraint`2.OutputMember" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.NegativeMemberSubset`2.ConflictsWith(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`1}}})">
            <summary>
                Checks if these constraints are obviously not valid together. That is, just by considering this and
                <paramref name="other" /> it is easy to tell that no program could possibly satisfy both of them. For instance, the
                two constraints could be examples that give different outputs.
            </summary>
            <param name="other">The constraint to check for conflicts.</param>
            <returns>
                True if the conjunction of the specifications of this constraint and <paramref name="other" /> is
                <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.NegativeMemberSubset`2.ToString">
            <summary>
                Returns a string that shows the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInputMember`2.InputMember" /> and
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.MemberToMemberConstraint`2.OutputMember" /> values.
            </summary>
            <returns>
                A string that represents this <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.NegativeMemberSubset`2" /> constraint.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.NegativeSubset`2">
            <summary>
                Constraint on that output <see cref="T:System.Collections.Generic.IEnumerable`1" /> must not contain any elements of a given subset.
            </summary>
            <typeparam name="TInput">Input type of programs this constraint applies to.</typeparam>
            <typeparam name="TOutputMember">Member type of collections of the output type of programs this constraint applies to.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.NegativeSubset`2.#ctor(`0,System.Collections.Generic.IEnumerable{`1},System.Boolean)">
            <summary>
                Constructs a constraint that when run on <paramref name="input" />, the program's output may not contain any
                elements of <paramref name="output" />.
            </summary>
            <param name="input">Program input this constraint applies to.</param>
            <param name="output">Elements which may not appear in output of program on <paramref name="input" />.</param>
            <param name="isSoft">If true, this is a soft (optional) constraint.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.NegativeSubset`2.Valid(Microsoft.ProgramSynthesis.Program{`0,System.Collections.Generic.IEnumerable{`1}})">
            <summary>
                Validate a program against this constraint.
            </summary>
            <param name="program">The program that needs to validate.</param>
            <returns>
                False if <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToValueConstraint`2.Output" /> intersects the output of
                <paramref name="program" /> when run on <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInput`2.Input" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.NegativeSubset`2.ConflictsWith(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`0,System.Collections.Generic.IEnumerable{`1}})">
            <summary>
                Checks if these constraints are obviously not valid together. That is, just by considering this and
                <paramref name="other" /> it is easy to tell that no program could possibly satisfy both of them. For instance, the
                two constraints could be examples that give different outputs.
            </summary>
            <param name="other">The constraint to check for conflicts.</param>
            <returns>
                True if the conjunction of the specifications of this constraint and <paramref name="other" /> is
                <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.NegativeSubset`2.ToString">
            <summary>
                Returns a string that shows the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInput`2.Input" /> and
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToValueConstraint`2.Output" /> regions.
            </summary>
            <returns>
                A string that represents this negative subset constraint.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.OutputIs`2">
            <summary>
                Constraint that the output is assignable to a specified type.
            
                NOTE: To use this, your output type must implement ITypedValue.  We don't use a generic type constraint to
                      enforce this requirement so that the JsonSerializerSettings for the base session type can include
                      this object in its set of known types without requiring the generic type constraint to be placed
                      on all program output types.  Instead we enforce the type expectation at runtime in the Valid method
                      below.
            </summary>
            <typeparam name="TInput">Input type of programs this constraint applies to.</typeparam>
            <typeparam name="TOutput">Output type of programs this constraint applies to.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.OutputIs`2.#ctor(Microsoft.ProgramSynthesis.Wrangling.IType)">
            <summary>
                Constructs a constraint which requires outputs to be assignable to <paramref name="type" />.
            </summary>
            <param name="type">Type required of outputs.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.OutputIs`2.Type">
            <summary>
                Type outputs must be assignable to.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.OutputIs`2.Equals(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`0,`1})">
            <summary>Indicates whether the current object is equal to another object of the same type.</summary>
            <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.OutputIs`2.ConflictsWith(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`0,`1})">
            <summary>
                Checks if these constraints are obviously not valid together. That is, just by considering this and
                <paramref name="other" /> it is easy to tell that no program could possibly satisfy both of them. For instance, the
                two constraints could be examples that give different outputs.
            </summary>
            <param name="other">The constraint to check for conflicts.</param>
            <returns>
                True if the conjunction of the specifications of this constraint and <paramref name="other" /> is
                <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.OutputIs`2.Valid(Microsoft.ProgramSynthesis.Program{`0,`1})">
            <summary>
                Validate a program against this constraint.
            </summary>
            <param name="program">The program that needs to validate.</param>
            <returns>The validation result.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.OutputIs`2.Valid(Microsoft.ProgramSynthesis.Program{`0,`1},System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Validate a program against this constraint given <paramref name="inputs" /> as valid inputs to the program. Used
                for constraints that need an input to run the program but do not contain enough information to construct one.
            </summary>
            <param name="program">The program that needs to validate.</param>
            <param name="inputs">The inputs to use for validating the program.</param>
            <returns>The validation result.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.OutputIs`2.GetHashCode">
            <summary>Serves as the default hash function. </summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.OutputIs`2.ToString">
            <summary>Returns a string that represents the current object.</summary>
            <returns>A string that represents the current object.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.Prefix`2">
            <summary>
                Constraint that output <see cref="T:System.Collections.Generic.IEnumerable`1" /> must begin with a given prefix.
            </summary>
            <typeparam name="TInput">Input type of programs this constraint applies to.</typeparam>
            <typeparam name="TOutputMember">Member type of collections of the output type of programs this constraint applies to.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.Prefix`2.#ctor(`0,System.Collections.Generic.IEnumerable{`1},System.Boolean)">
            <summary>
                Constructs a constraint that when run on <paramref name="input" />, the program's output must begin with
                <paramref name="output" />.
            </summary>
            <param name="input">Program input this constraint applies to.</param>
            <param name="output">Prefix of output of program on <paramref name="input" />.</param>
            <param name="isSoft">If true, this is a soft (optional) constraint.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.Prefix`2.Valid(Microsoft.ProgramSynthesis.Program{`0,System.Collections.Generic.IEnumerable{`1}})">
            <summary>
                Validate a program against this constraint.
            </summary>
            <param name="program">The program that needs to validate.</param>
            <returns>
                True if the output of <paramref name="program" /> on <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInput`2.Input" /> is
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToValueConstraint`2.Output" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.Prefix`2.ConflictsWith(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`0,System.Collections.Generic.IEnumerable{`1}})">
            <summary>
                Checks if these constraints are obviously not valid together. That is, just by considering this and
                <paramref name="other" /> it is easy to tell that no program could possibly satisfy both of them. For instance, the
                two constraints could be examples that give different outputs.
            </summary>
            <param name="other">The constraint to check for conflicts.</param>
            <returns>
                True if the conjunction of the specifications of this constraint and <paramref name="other" /> is
                <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.Prefix`2.ToString">
            <summary>
                Returns a string that shows the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInput`2.Input" /> and
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToValueConstraint`2.Output" /> regions.
            </summary>
            <returns>
                A string that represents this prefix constraint.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.Subset`2">
            <summary>
                Constraint on that output <see cref="T:System.Collections.Generic.IEnumerable`1" /> must contain a given subset.
            </summary>
            <typeparam name="TInput">Input type of programs this constraint applies to.</typeparam>
            <typeparam name="TOutputMember">Member type of collections of the output type of programs this constraint applies to.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.Subset`2.#ctor(`0,System.Collections.Generic.IEnumerable{`1},System.Boolean)">
            <summary>
                Constructs a constraint that when run on <paramref name="input" />, the program's output must be a superset of
                <paramref name="output" />.
            </summary>
            <param name="input">Program input this constraint applies to.</param>
            <param name="output">Subset of output of program on <paramref name="input" />.</param>
            <param name="isSoft">If true, this is a soft (optional) constraint.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.Subset`2.Valid(Microsoft.ProgramSynthesis.Program{`0,System.Collections.Generic.IEnumerable{`1}})">
            <summary>
                Validate a program against this constraint.
            </summary>
            <param name="program">The program that needs to validate.</param>
            <returns>
                True if the output of the program on <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInput`2.Input" /> is a superset of
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToValueConstraint`2.Output" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.Subset`2.ConflictsWith(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`0,System.Collections.Generic.IEnumerable{`1}})">
            <summary>
                Checks if these constraints are obviously not valid together. That is, just by considering this and
                <paramref name="other" /> it is easy to tell that no program could possibly satisfy both of them. For instance, the
                two constraints could be examples that give different outputs.
            </summary>
            <param name="other">The constraint to check for conflicts.</param>
            <returns>
                True if the conjunction of the specifications of this constraint and <paramref name="other" /> is
                <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.Subset`2.ToString">
            <summary>
                Returns a string that shows the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInput`2.Input" /> and
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToValueConstraint`2.Output" /> regions.
            </summary>
            <returns>
                A string that represents this subset constraint.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToMemberConstraint`2">
            <summary>
                Supertype for constraints that have an explicit input value and an element of an output collection.
            </summary>
            <typeparam name="TInput">Input type of programs this constraint applies to.</typeparam>
            <typeparam name="TOutputMember">Member type of collections of the output type of programs this constraint applies to.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToMemberConstraint`2.#ctor(`0,`1,System.Boolean)">
            <summary>
                Constructs a constraint on an input and a member of its corresponding output.
            </summary>
            <param name="input">The input this constraint is on.</param>
            <param name="outputMember">The output member this constraint references.</param>
            <param name="isSoft">If true, this is a soft (optional) constraint.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToMemberConstraint`2.OutputMember">
            <summary>
                Member of program output this constraint references. This has some relation (defined by the subclass) to the output
                of the program when run on <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInput`2.Input" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToMemberConstraint`2.Equals(Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToMemberConstraint{`0,`1})">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToMemberConstraint`2.Equals(System.Object)">
            <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="other">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToMemberConstraint`2.Equals(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`0,System.Collections.Generic.IEnumerable{`1}})">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToMemberConstraint`2.GetHashCode">
            <summary>
                Serves as the default hash function.
            </summary>
            <returns>
                A hash code for the current object.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToValueConstraint`2">
            <summary>
                Supertype for constraints that have an explicit input and output value.
            </summary>
            <typeparam name="TInput">Input type of programs this constraint applies to.</typeparam>
            <typeparam name="TOutput">Output type of programs this constraint applies to.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToValueConstraint`2.#ctor(`0,`1,System.Boolean)">
            <summary>
                Constructs constraint on an input that references an output.
            </summary>
            <param name="input">Program input this constraint applies to.</param>
            <param name="output">Program output this constraint references.</param>
            <param name="isSoft">If true, this is a soft (optional) constraint.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToValueConstraint`2.Output">
            <summary>
                Output value this constraint references.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToValueConstraint`2.Equals(Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToValueConstraint{`0,`1})">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToValueConstraint`2.Equals(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`0,`1})">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToValueConstraint`2.Equals(System.Object)">
            <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="other">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToValueConstraint`2.GetHashCode">
            <summary>
                Serves as the default hash function.
            </summary>
            <returns>
                A hash code for the current object.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.DocumentSpecInterface">
            <summary>
            Represents the specification for the whole document.
            Used for schema learning.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.DocumentSpecInterface.PositiveContainsKey(System.String)">
            <summary>
            Check if the positive examples contains such field.
            </summary>
            <param name="name">The field name.</param>
            <returns>True if the field has positive examples, false otherwise.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.DocumentSpec`1">
            <summary>
            Represents the specification for the whole document.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.DocumentSpec`1.Document">
            <summary>
            The region of the entire document.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.DocumentSpec`1.PositiveExamples">
            <summary>
            The positive examples.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.DocumentSpec`1.NegativeExamples">
            <summary>
            The negative examples.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.DocumentSpec`1.#ctor(`0,System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IEnumerable{`0}},System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IEnumerable{`0}})">
            <summary>
            Construct the specification from its element.
            </summary>
            <param name="input"></param>
            <param name="examples"></param>
            <param name="negatives"></param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.DocumentSpec`1.PositiveContainsKey(System.String)">
            <summary>
            Check if the positive examples contains such field.
            </summary>
            <param name="name">The field name.</param>
            <returns>True if the field has positive examples, false otherwise.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.AlphaNumericToken">
            <summary>
                Represents an AlphaNumeric token.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.AlphaNumericToken.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.AlphaNumericToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.AlphaNumericToken.EntityName">
            <summary>
                The name of this entity.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.AlphaNumericToken.MakeSearchTreeEntries(Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleteSearchTree,System.Boolean)">
            <summary>
                Makes the entries corresponding this to this entity in a search tree for autocompletion.
            </summary>
            <param name="tree">The search tree to be used for autocompletion.</param>
            <param name="includeNonExtensionCompletions">
                If true, then the search tree will include completions that are _not_
                extensions of the user input. e.g. "day" -> "Monday", etc.
            </param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.AlphaNumericTokenizer">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer" /> that yields <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.AlphaNumericToken" />s.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.AlphaToken">
            <summary>
                A token that consists of letters.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.AlphaToken.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.AlphaToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.AlphaToken.EntityName">
            <summary>
                The name of this entity.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.AlphaToken.MakeSearchTreeEntries(Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleteSearchTree,System.Boolean)">
            <summary>
                Makes the entries corresponding this to this entity in a search tree for autocompletion.
            </summary>
            <param name="tree">The search tree to be used for autocompletion.</param>
            <param name="includeNonExtensionCompletions">
                If true, then the search tree will include completions that are _not_
                extensions of the user input. e.g. "day" -> "Monday", etc.
            </param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.AlphaTokenizer">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer" /> that yields <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.AlphaToken" />s.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.CharCategoryBasedToken">
            <summary>
                A generic string token.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.CharCategoryBasedToken.#ctor(System.String,System.Int32,System.Int32,System.Globalization.UnicodeCategory)">
            <summary>
                Constructor.
            </summary>
            <param name="sourceAsString">The source string of the token.</param>
            <param name="start">The start index of this token in <paramref name="sourceAsString" />.</param>
            <param name="end">The end index (exclusive) of this token in <paramref name="sourceAsString" />.</param>
            <param name="charCategory">
                The <see cref="T:System.Globalization.UnicodeCategory" /> of the characters in <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.StringToken.Value" />.
            </param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.CharCategoryBasedToken.CharCategory">
            <summary>
                The <see cref="T:System.Globalization.UnicodeCategory" /> of the characters in <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.StringToken.Value" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.CharCategoryBasedToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.CharCategoryBasedToken.EntityName">
            <summary>
                The name of this entity.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.CharCategoryBasedToken.MakeSearchTreeEntries(Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleteSearchTree,System.Boolean)">
            <summary>
                Makes the entries corresponding this to this entity in a search tree for autocompletion.
            </summary>
            <param name="tree">The search tree to be used for autocompletion.</param>
            <param name="includeNonExtensionCompletions">
                If true, then the search tree will include completions that are _not_
                extensions of the user input. e.g. "day" -> "Monday", etc.
            </param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.CharCategoryBasedTokenizer">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer" /> that yields <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.CharCategoryBasedToken" />s
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.CharCategoryBasedTokenizer.Tokenize(System.String)">
            <summary>
                Tokenizes a sequence.
            </summary>
            <param name="sequence">The sequence of things to tokenize.</param>
            <returns>A tokenization of <paramref name="sequence" /></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.CharCategoryBasedTokenizer.Tokenize(System.String,System.Int32,System.Int32)">
            <summary>
                Tokenizes the part of the <paramref name="sequence" /> that lie within <paramref name="start" /> and
                <see cref="!:end" />, exclusive.
            </summary>
            <param name="sequence">The sequence to be tokenize.</param>
            <param name="start">
                The starting position of the region in <paramref name="sequence" /> within which the tokens
                returned are expected to lie.
            </param>
            <param name="end">
                The ending position (exclusive) of the region in <paramref name="sequence" /> within which the tokens
                returned are expected to lie.
            </param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.CreditCardNumberToken">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that represents a credit card number.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.CreditCardNumberToken.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The source from which this token was extracted.</param>
            <param name="start">The start index of this token in <paramref name="source" />.</param>
            <param name="end">The end index (exclusive) of this token in <paramref name="source" />.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.CreditCardNumberToken.EntityName">
            <summary>
                The name of this entity.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.CreditCardNumberToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.CurrencyToken">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that represents a currency value.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.CurrencyToken.#ctor(System.String,System.Int32,System.Int32,System.Double,System.String)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
            <param name="numericValue">The numeric value associated with this token</param>
            <param name="currencySymbol">The currency symbol.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.CurrencyToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.CurrencyToken.EntityName">
            <summary>
                The name of this entity.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.CurrencyToken.MakeSearchTreeEntries(Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleteSearchTree,System.Boolean)">
            <summary>
                Makes the entries corresponding this to this entity in a search tree for autocompletion.
            </summary>
            <param name="tree">The search tree to be used for autocompletion.</param>
            <param name="includeNonExtensionCompletions">
                If true, then the search tree will include completions that are _not_
                extensions of the user input. e.g. "day" -> "Monday", etc.
            </param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.CurrencyTokenizer">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer" /> that yields <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.CurrencyToken" />s.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.CurrencyTokenizer.#ctor">
            <summary>
                Constructor.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DashedNumbersToken">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that represents sequences of digits, possibly separated by dashes, dots, etc.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DashedNumbersToken.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DashedNumbersToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DashedNumbersToken.EntityName">
            <summary>
                The name of this entity.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DashedNumbersToken.MakeSearchTreeEntries(Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleteSearchTree,System.Boolean)">
            <summary>
                Makes the entries corresponding this to this entity in a search tree for autocompletion.
            </summary>
            <param name="tree">The search tree to be used for autocompletion.</param>
            <param name="includeNonExtensionCompletions">
                If true, then the search tree will include completions that are _not_
                extensions of the user input. e.g. "day" -> "Monday", etc.
            </param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DashedNumbersTokenizer">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer" /> that yields <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DashedNumbersToken" />s
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DashedNumbersTokenizer.#ctor">
            <summary>
                Constructor.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DateToken">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that represents dates.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DateToken.#ctor(System.String,System.Int32,System.Int32,System.DateTime)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
            <param name="dateTime">The <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DateToken.DateTime" /> object corresponding to the detected date entity.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DateToken.DateTime">
            <summary>
                The <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DateToken.DateTime" /> object associated with this token.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DateToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DateToken.EntityName">
            <summary>
                The name of this entity.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DateToken.MakeSearchTreeEntries(Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleteSearchTree,System.Boolean)">
            <summary>
                Makes the entries corresponding this to this entity in a search tree for autocompletion.
            </summary>
            <param name="tree">The search tree to be used for autocompletion.</param>
            <param name="includeNonExtensionCompletions">
                If true, then the search tree will include completions that are _not_
                extensions of the user input. e.g. "day" -> "Monday", etc.
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DateToken.ValueBasedEquality(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken)">
            <summary>
                Value based equality (as opposed to position based equality).
            </summary>
            <param name="other">The other <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> to check for equality with.</param>
            <returns>
                <c>true</c> if and only if the type of <paramref name="other" /> is the same as the type of this token, and the
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DateToken.DateTime" /> properties of <paramref name="other" /> and <c>this</c> are equal.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DateToken.ValueBasedHashCode">
            <summary>
                Returns a value based hash code that satisfies the constraint of <see cref="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken.ValueBasedEquality(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken)" />.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DateTokenizer">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer" /> that yields <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DateToken" />s
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DateTokenizer.#ctor">
            <summary>
                Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DomainNameToken.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DomainNameToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DomainNameToken.EntityName">
            <summary>
                The name of this entity.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DomainNameToken.MakeSearchTreeEntries(Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleteSearchTree,System.Boolean)">
            <summary>
                Makes the entries corresponding this to this entity in a search tree for autocompletion.
            </summary>
            <param name="tree">The search tree to be used for autocompletion.</param>
            <param name="includeNonExtensionCompletions">
                If true, then the search tree will include completions that are _not_
                extensions of the user input. e.g. "day" -> "Monday", etc.
            </param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DomainNameTokenizer">
            <summary>
                A <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.RegexBasedTokenizer" /> that extracts domain names.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.DomainNameTokenizer.#ctor">
            <summary>
                Constructor.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EmailToken">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that represents an email address.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EmailToken.#ctor(System.String,System.Int32,System.Int32,System.String,System.String)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
            <param name="userName">The user name component of the email address.</param>
            <param name="domainName">The domain name component of the email address.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EmailToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EmailToken.EntityName">
            <summary>
                The name of this entity.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EmailToken.MakeSearchTreeEntries(Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleteSearchTree,System.Boolean)">
            <summary>
                Makes the entries corresponding this to this entity in a search tree for autocompletion.
            </summary>
            <param name="tree">The search tree to be used for autocompletion.</param>
            <param name="includeNonExtensionCompletions">
                If true, then the search tree will include completions that are _not_
                extensions of the user input. e.g. "day" -> "Monday", etc.
            </param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EmailTokenizer">
            <summary>
                A <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.RegexBasedTokenizer" /> that extracts email addresses and yields <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EmailToken" />s.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EmailTokenizer.#ctor">
            <summary>
                Constructor.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EnclosedRegionToken">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that represents regions enclosed by '()', '{}', etc.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EnclosedRegionToken.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EnclosedRegionToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EnclosedRegionToken.EntityName">
            <summary>
                The name of this entity.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EnclosedRegionToken.MakeSearchTreeEntries(Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleteSearchTree,System.Boolean)">
            <summary>
                Makes the entries corresponding this to this entity in a search tree for autocompletion.
            </summary>
            <param name="tree">The search tree to be used for autocompletion.</param>
            <param name="includeNonExtensionCompletions">
                If true, then the search tree will include completions that are _not_
                extensions of the user input. e.g. "day" -> "Monday", etc.
            </param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EnclosedRegionTokenizer">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer" /> that yields <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EnclosedRegionToken" />s.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EnclosedRegionTokenizer.Tokenize(System.String)">
            <summary>
                Tokenizes a sequence.
            </summary>
            <param name="sequence">The sequence of things to tokenize.</param>
            <returns>A tokenization of <paramref name="sequence" /></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer">
            <summary>
                An abstract class that represents a tokenizer capable of extracting
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" />s from a sequence.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer.KnownSubTypes">
            <summary>
                The set of all known (supported) subtypes of this type.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer.KnownSubTypeNames">
            <summary>
                The assembly qualified names of all known (supported) subtypes.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer.Equals(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer)">
            <summary>Indicates whether the current object is equal to another object of the same type.</summary>
            <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer.RenderHumanReadable">
            <summary>
                Render this as a human-readable string representation. This should be parseable by the corresponding
                <see cref="P:Microsoft.ProgramSynthesis.Utils.ParseableAttribute.ParseHumanReadableString" /> method.
            </summary>
            <returns>A compact string representation of this object that is easy for a human to understand.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer.RenderXML">
            <summary>
                Render this as XML. This should be parseable by the corresponding <see cref="P:Microsoft.ProgramSynthesis.Utils.ParseableAttribute.ParseXML" />
                method.
            </summary>
            <returns>An XML representation of this object.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer.TryParseXML(System.Xml.Linq.XElement,Microsoft.ProgramSynthesis.AST.DeserializationContext)">
            <summary>
                Parse the serialized XML representation of an object of this type.
            </summary>
            <param name="literal">
                The XML tree corresponding to the serialization of an object of type
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer" />.
            </param>
            <param name="context">A context to pass through to all deserialization methods.</param>
            <returns>
                An object of type <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer" /> that corresponds to the serialized object represented by
                <paramref name="literal" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer.TryParseHumanReadable(System.String,Microsoft.ProgramSynthesis.AST.DeserializationContext)">
            <summary>
                Parse the serialized human-readable representation of an object of this type.
            </summary>
            <param name="literal">
                The string corresponding to the human-readable serialization of an object of type
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer" />.
            </param>
            <param name="context">A context to pass through to all deserialization methods.</param>
            <returns>
                An object of type <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer" /> that corresponds to the serialized object represented by
                <paramref name="literal" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
            <returns>true if the specified object  is equal to the current object; otherwise, false.</returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer.GetHashCode">
            <summary>Serves as the default hash function. </summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken">
            <summary>
                An abstract class that represents tokens which represent some kind of entity.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken.EntityName">
            <summary>
                The name of this entity.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken.Equals(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken)">
            <summary>Indicates whether the current object is equal to another object of the same type.</summary>
            <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken.MakeSearchTreeEntries(Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleteSearchTree,System.Boolean)">
            <summary>
                Makes the entries corresponding this to this entity in a search tree for autocompletion.
            </summary>
            <param name="tree">The search tree to be used for autocompletion.</param>
            <param name="includeNonExtensionCompletions">
                If true, then the search tree will include completions that are _not_
                extensions of the user input. e.g. "day" -> "Monday", etc.
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken.ValueBasedEquality(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken)">
            <summary>
                Value based equality (as opposed to position based equality).
            </summary>
            <param name="other">The other <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> to check for equality with.</param>
            <returns>
                <c>true</c> if and only if the type of <paramref name="other" /> is the same as the type of this token, and
                <paramref name="other" /> is "value-equal" to <c>this</c>. The notion of value equality may be overriden by
                subclasses, but defaults to the <see cref="!:EntityToken.Value" /> property being equal on the two objects.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken.GetHashCode">
            <summary>Serves as the default hash function. </summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken.ValueBasedHashCode">
            <summary>
                Returns a value based hash code that satisfies the constraint of <see cref="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken.ValueBasedEquality(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken)" />.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken.ToString">
            <summary>Returns a string that represents the current object.</summary>
            <returns>A string that represents the current object.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.FileNameToken">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that represents file names.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.FileNameToken.#ctor(System.String,System.Int32,System.Int32,System.String,System.String)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
            <param name="fileName">The file name.</param>
            <param name="extension">The file extension.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.FileNameToken.EntityName">
            <summary>
                The name of this entity.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.FileNameToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.FormattedNumberToken">
            <summary>
                A <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.NumericToken" /> that represents a formatted number.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.FormattedNumberToken.#ctor(System.String,System.Int32,System.Int32,System.Double)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
            <param name="numericValue">The numeric value of this token.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.FormattedNumberToken.EntityName">
            <summary>
                The name of this entity.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.FormattedNumberToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.GuidToken">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that represents a <see cref="T:System.Guid" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.GuidToken.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.GuidToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.GuidToken.EntityName">
            <summary>
                The name of this entity.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.HexNumberToken">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that represents a hexadecimal number.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.HexNumberToken.#ctor(System.String,System.Int32,System.Int32,System.UInt64)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
            <param name="numericValue">The numeric value of this token.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.HexNumberToken.EntityName">
            <summary>
                The name of this entity.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.HexNumberToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpAddressToken">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that represents an IP address.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpAddressToken.#ctor(System.String,System.Int32,System.Int32,System.Net.IPAddress)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
            <param name="address">The IP address.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpAddressToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpAddressToken.MakeSearchTreeEntries(Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleteSearchTree,System.Boolean)">
            <summary>
                Makes the entries corresponding this to this entity in a search tree for autocompletion.
            </summary>
            <param name="tree">The search tree to be used for autocompletion.</param>
            <param name="includeNonExtensionCompletions">
                If true, then the search tree will include completions that are _not_
                extensions of the user input. e.g. "day" -> "Monday", etc.
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpAddressToken.ValueBasedEquality(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken)">
            <summary>
                Value based equality (as opposed to position based equality).
            </summary>
            <param name="other">The other <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> to check for equality with.</param>
            <returns>
                <c>true</c> if and only if the type of <paramref name="other" /> is the same as the type of this token,
                and the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpAddressToken.Address" /> properties of <paramref name="other" /> and <c>this</c> are equal.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpAddressToken.ValueBasedHashCode">
            <summary>
                Returns a value based hash code that satisfies the constraint of <see cref="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken.ValueBasedEquality(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken)" />.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpAddressTokenizer">
            <summary>
                A <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.RegexBasedTokenizer" /> that extracts IP addresses and yields <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpAddressToken" />s.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpAddressTokenizer.#ctor">
            <summary>
                Constructor.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpV4AddressToken">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that represents an IPV4 address.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpV4AddressToken.#ctor(System.String,System.Int32,System.Int32,System.Net.IPAddress)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
            <param name="address">The IP address.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpV4AddressToken.EntityName">
            <summary>The name of this entity.</summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpV4AddressToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpV4CidrAddressToken">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that represents a CIDR IPV4 address.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpV4CidrAddressToken.#ctor(System.String,System.Int32,System.Int32,System.Net.IPAddress,System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
            <param name="address">The IP address.</param>
            <param name="subnetBits">The number of bits of the address that represent the subnet.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpV4CidrAddressToken.ValueBasedEquality(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken)">
            <summary>
                Value based equality (as opposed to position based equality).
            </summary>
            <param name="other">The other <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> to check for equality with.</param>
            <returns>
                <c>true</c> if and only if the type of <paramref name="other" /> is the same as the type of this token,
                and the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpAddressToken.Address" /> properties of <paramref name="other" /> and <c>this</c> are equal,
                and the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpV4CidrAddressToken.SubnetBits" /> properties on the two objects are equal.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpV4CidrAddressToken.ValueBasedHashCode">
            <summary>
                Returns a value based hash code that satisfies the constraint of <see cref="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken.ValueBasedEquality(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken)" />.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpV6AddressToken">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that represents an IPV6 address.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpV6AddressToken.#ctor(System.String,System.Int32,System.Int32,System.Net.IPAddress)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
            <param name="address">The IP address.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpV6AddressToken.EntityName">
            <summary>The name of this entity.</summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpV6AddressToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpV6CidrAddressToken">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that represents a CIDR IPV6 address.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpV6CidrAddressToken.#ctor(System.String,System.Int32,System.Int32,System.Net.IPAddress,System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
            <param name="address">The IP address.</param>
            <param name="subnetBits">The number of bits in the address that denote the subnet.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpV6CidrAddressToken.ValueBasedEquality(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken)">
            <summary>
                Value based equality (as opposed to position based equality).
            </summary>
            <param name="other">The other <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> to check for equality with.</param>
            <returns>
                <c>true</c> if and only if the type of <paramref name="other" /> is the same as the type of this token,
                and the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpAddressToken.Address" /> properties of <paramref name="other" /> and <c>this</c> are equal,
                and the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpV6CidrAddressToken.SubnetBits" /> properties of the two objects are equal.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.IpV6CidrAddressToken.ValueBasedHashCode">
            <summary>
                Returns a value based hash code that satisfies the constraint of <see cref="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken.ValueBasedEquality(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken)" />.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.MacAddressToken">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that represents a MAC address.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.MacAddressToken.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.MacAddressToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.MacAddressToken.EntityName">
            <summary>
                The name of this entity.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.MacAddressToken.MakeSearchTreeEntries(Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleteSearchTree,System.Boolean)">
            <summary>
                Makes the entries corresponding this to this entity in a search tree for autocompletion.
            </summary>
            <param name="tree">The search tree to be used for autocompletion.</param>
            <param name="includeNonExtensionCompletions">
                If true, then the search tree will include completions that are _not_
                extensions of the user input. e.g. "day" -> "Monday", etc.
            </param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.MacAddressTokenizer">
            <summary>
                A <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.RegexBasedTokenizer" /> that extracts MAC addresses and yields <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.MacAddressToken" />s.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.MacAddressTokenizer.#ctor">
            <summary>
                Constructor.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.MaskedCreditCardNumberToken">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that represents a masked credit card number.
                e.g. XXXX-XXXX-XXXX-1234
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.MaskedCreditCardNumberToken.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.MaskedCreditCardNumberToken.EntityName">
            <summary>
                The name of this entity.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.MaskedCreditCardNumberToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.MaskedSocialSecurityNumberToken">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that represents a masked social security number.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.MaskedSocialSecurityNumberToken.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.MaskedSocialSecurityNumberToken.EntityName">
            <summary>
                The name of this entity.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.MaskedSocialSecurityNumberToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.NumericToken">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that represents numbers.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.NumericToken.#ctor(System.String,System.Int32,System.Int32,System.Double)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
            <param name="numericValue">The numeric value of this token.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.NumericToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.NumericToken.EntityName">
            <summary>
                The name of this entity.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.NumericToken.MakeSearchTreeEntries(Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleteSearchTree,System.Boolean)">
            <summary>
                Makes the entries corresponding this to this entity in a search tree for autocompletion.
            </summary>
            <param name="includeNonExtensionCompletions">
                If true, then the search tree will include completions that are _not_
                extensions of the user input. e.g. "day" -> "Monday", etc.
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.NumericToken.Equals(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken)">
            <summary>Indicates whether the current object is equal to another object of the same type.</summary>
            <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.NumericToken.ValueBasedEquality(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken)">
            <summary>
                Value based equality.
            </summary>
            <param name="other">The other <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> to check for equality with.</param>
            <returns>
                <c>true</c> if and only if the type of <paramref name="other" /> is the same as the type of this token, and
                the Value properties are equal.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.NumericToken.GetHashCode">
            <summary>Serves as the default hash function. </summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.NumericToken.ValueBasedHashCode">
            <summary>
                Returns a value based hash code that satisfies the constraint of <see cref="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken.ValueBasedEquality(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken)" />.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.NumericTokenizer">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer" /> that yields <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.NumericToken" />s
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.NumericTokenizer.#ctor">
            <summary>
                Constructor.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PathToken">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that represents file-system paths.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PathToken.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PathToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PathToken.EntityName">
            <summary>
                The name of this entity.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PathToken.MakeSearchTreeEntries(Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleteSearchTree,System.Boolean)">
            <summary>
                Makes the entries corresponding this to this entity in a search tree for autocompletion.
            </summary>
            <param name="tree">The search tree to be used for autocompletion.</param>
            <param name="includeNonExtensionCompletions">
                If true, then the search tree will include completions that are _not_
                extensions of the user input. e.g. "day" -> "Monday", etc.
            </param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PathTokenizer">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer" /> that yields <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PathToken" />s.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PathTokenizer.#ctor">
            <summary>
                Constructor.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PhoneNumberToken">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that represents phone numbers.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PhoneNumberToken.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PhoneNumberToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PhoneNumberToken.EntityName">
            <summary>
                The name of this entity.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PhoneNumberToken.MakeSearchTreeEntries(Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleteSearchTree,System.Boolean)">
            <summary>
                Makes the entries corresponding this to this entity in a search tree for autocompletion.
            </summary>
            <param name="tree">The search tree to be used for autocompletion.</param>
            <param name="includeNonExtensionCompletions">
                If true, then the search tree will include completions that are _not_
                extensions of the user input. e.g. "day" -> "Monday", etc.
            </param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PhoneNumberTokenizer">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer" /> that yields <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PhoneNumberToken" />s.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PhoneNumberTokenizer.#ctor">
            <summary>
                Constructor.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PhraseToken">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that represents a phrase
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PhraseToken.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PhraseToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PhraseToken.EntityName">
            <summary>
                The name of this entity.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PhraseToken.MakeSearchTreeEntries(Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleteSearchTree,System.Boolean)">
            <summary>
                Makes the entries corresponding this to this entity in a search tree for autocompletion.
            </summary>
            <param name="tree">The search tree to be used for autocompletion.</param>
            <param name="includeNonExtensionCompletions">
                If true, then the search tree will include completions that are _not_
                extensions of the user input. e.g. "day" -> "Monday", etc.
            </param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PhraseTokenizer">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer" /> that yields <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PhraseToken" />s
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PunctuationSeparatedAlphaNumericToken">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that represents sequences of alpha-numeric characters with dashes, dots, etc. between
                them.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PunctuationSeparatedAlphaNumericToken.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PunctuationSeparatedAlphaNumericToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PunctuationSeparatedAlphaNumericToken.EntityName">
            <summary>
                The name of this entity.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PunctuationSeparatedAlphaNumericToken.MakeSearchTreeEntries(Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleteSearchTree,System.Boolean)">
            <summary>
                Makes the entries corresponding this to this entity in a search tree for autocompletion.
            </summary>
            <param name="tree">The search tree to be used for autocompletion.</param>
            <param name="includeNonExtensionCompletions">
                If true, then the search tree will include completions that are _not_
                extensions of the user input. e.g. "day" -> "Monday", etc.
            </param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PunctuationSeparatedAlphaNumericTokenizer">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer" /> that yields <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.PunctuationSeparatedAlphaNumericToken" />s.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.OverlapStrategy">
            <summary>
                An enumerated type that is used to describe how overlapping <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPatternMatch" />es are to be handled.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.OverlapStrategy.None">
            <summary>
                Do nothing, all overlapping <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPatternMatch" />es are returned.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.OverlapStrategy.Subsumption">
            <summary>
                Returns only those <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPatternMatch" /> that are not strictly subsumed by
                any other match.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.OverlapStrategy.StopAtFirstSuccess">
            <summary>
                Stop tokenizing as soon as we find a pattern that returns a non-empty result.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.RegexBasedTokenizer">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer" /> that uses <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern" />s to specify the extraction logic.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.RegexBasedTokenizer.MakeTokensFromMatches(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPatternMatch})">
            <summary>
                Creates the <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> objects corresponding to a sequence of <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPatternMatch" />
                objects.
                This is a default implementation provided for convenience. Subclasses may override this method if necessary.
            </summary>
            <param name="matches">The sequence of <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPatternMatch" /> objects.</param>
            <returns>
                <c>null</c> if <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.RegexBasedTokenizer.TokenFactory" /> is null, otherwise a sequence of <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> objects
                obtained by applying <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.RegexBasedTokenizer.TokenFactory" /> on each element of <paramref name="matches" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.RegexBasedTokenizer.Tokenize(System.String)">
            <summary>
                Tokenize the given string.
            </summary>
            <param name="sequence">The input string.</param>
            <returns>
                A sequence of <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" />s correponding to the entities extracted from
                <paramref name="sequence" />.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.SocialSecurityNumberToken">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that represents a Social Security Number.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.SocialSecurityNumberToken.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.SocialSecurityNumberToken.EntityName">
            <summary>
                The name of this entity.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.SocialSecurityNumberToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.TimeToken">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that represents times.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.TimeToken.#ctor(System.String,System.Int32,System.Int32,System.DateTime)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
            <param name="time">
                The <see cref="T:System.DateTime" /> object corresponding to the time entity detected in
                <paramref name="source" />.
            </param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.TimeToken.Time">
            <summary>
                The time represented by this token.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.TimeToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.TimeToken.EntityName">
            <summary>
                The name of this entity.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.TimeToken.MakeSearchTreeEntries(Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleteSearchTree,System.Boolean)">
            <summary>
                Makes the entries corresponding this to this entity in a search tree for autocompletion.
            </summary>
            <param name="tree">The search tree to be used for autocompletion.</param>
            <param name="includeNonExtensionCompletions">
                If true, then the search tree will include completions that are _not_
                extensions of the user input. e.g. "day" -> "Monday", etc.
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.TimeToken.ValueBasedEquality(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken)">
            <summary>
                Value based equality (as opposed to position based equality).
            </summary>
            <param name="other">The other <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> to check for equality with.</param>
            <returns>
                <c>true</c> if and only if the type of <paramref name="other" /> is the same as the type of this token,
                and the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.TimeToken.Time" /> properties of <paramref name="other" /> and <c>this</c> are equal.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.TimeToken.ValueBasedHashCode">
            <summary>
                Returns a value based hash code that satisfies the constraint of <see cref="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken.ValueBasedEquality(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken)" />.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.TimeTokenizer">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer" /> that yields <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.TimeToken" />s.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.TimeTokenizer.#ctor">
            <summary>
                Constructor.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.TitleCaseToken">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that represents a TitleCaseWord
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.TitleCaseToken.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.TitleCaseToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.TitleCaseToken.EntityName">
            <summary>
                The name of this entity.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.TitleCaseToken.MakeSearchTreeEntries(Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleteSearchTree,System.Boolean)">
            <summary>
                Makes the entries corresponding this to this entity in a search tree for autocompletion.
            </summary>
            <param name="tree">The search tree to be used for autocompletion.</param>
            <param name="includeNonExtensionCompletions">
                If true, then the search tree will include completions that are _not_
                extensions of the user input. e.g. "day" -> "Monday", etc.
            </param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.TitleCaseTokenizer">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer" /> that yields <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.TitleCaseToken" />s.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.UrlToken">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that represents a URL.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.UrlToken.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The <see cref="T:System.String" /> that contains the entity.</param>
            <param name="start">The index of the first position in <paramref name="source" /> that is part of this entity.</param>
            <param name="end">The index of the last position in <paramref name="source" /> (exclusive) that is part of this entity.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.UrlToken.ScoreMultiplier">
            <summary>
                Represents the multiplier for the score of strings matched by this entity.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.UrlToken.EntityName">
            <summary>
                The name of this entity.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.UrlToken.MakeSearchTreeEntries(Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.IAutoCompleteSearchTree,System.Boolean)">
            <summary>
                Makes the entries corresponding this to this entity in a search tree for autocompletion.
            </summary>
            <param name="tree">The search tree to be used for autocompletion.</param>
            <param name="includeNonExtensionCompletions">
                If true, then the search tree will include completions that are _not_
                extensions of the user input. e.g. "day" -> "Monday", etc.
            </param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.UrlTokenizer">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer" /> that yields <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.UrlToken" />s.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.UrlTokenizer.#ctor">
            <summary>
                Constructor.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.ValueAndPositionBasedEntityEqualityComparer.Instance">
            <summary>
                The singleton instance of this class.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.ValueAndPositionBasedEntityEqualityComparer.Equals(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken,Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken)">
            <summary>Determines whether the specified objects are equal.</summary>
            <returns>true if the specified objects are equal; otherwise, false.</returns>
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.ValueAndPositionBasedEntityEqualityComparer.GetHashCode(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken)">
            <summary>Returns a hash code for the specified object.</summary>
            <returns>A hash code for the specified object.</returns>
            <param name="obj">The object for which a hash code is to be returned.</param>
            <exception cref="T:System.ArgumentNullException">
                The type of <paramref name="obj" /> is a reference type and
                <paramref name="obj" /> is null.
            </exception>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.ValueBasedEntityToken">
            <summary>
                A helper abstract class that derives from <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" />.
                The <see cref="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.ValueBasedEntityToken.Equals(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken)" /> method defaults to <see cref="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken.ValueBasedEquality(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken)" />
                and the <see cref="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.ValueBasedEntityToken.GetHashCode" /> method defaults to <see cref="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken.ValueBasedHashCode" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.ValueBasedEntityToken.Equals(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken)">
            <summary>Indicates whether the current object is equal to another object of the same type.</summary>
            <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.ValueBasedEntityToken.GetHashCode">
            <summary>Serves as the default hash function. </summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.IToken`2">
            <summary>
                A common interface for tokens. A <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.IToken`2" /> provides two views:
                1. As a contiguous subsequence of <typeparamref name="TSequenceable" /> objects, represented as a
                <typeparamref name="TSequence" /> object.
                2. As a contiguous subsequence of a <see cref="T:System.String" /> object.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.IToken`2.SourceSequence">
            <summary>
                The source sequence of this token.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.IToken`2.StartInSequence">
            <summary>
                The start index in the source sequence for this token.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.IToken`2.EndInSequence">
            <summary>
                The end index (exclusive) in the source sequence for this token.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.IToken`2.TokenSubSequence">
            <summary>
                The actual value of this token, represented as a contiguous subsequence of
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.IToken`2.SourceSequence" /> from <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.IToken`2.StartInSequence" /> to <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.IToken`2.EndInSequence" />, exclusive.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.IToken`2.SourceString">
            <summary>
                The backing <see cref="T:System.String" /> on top of which the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.IToken`2.SourceSequence" /> is built.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.IToken`2.Start">
            <summary>
                The start index of the string corresponding to the value <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.IToken`2.StartInSequence" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.IToken`2.End">
            <summary>
                The end index of the string corresponding to the value <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.IToken`2.EndInSequence" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.IToken`2.Value">
            <summary>
                The value of this token represented as a <see cref="T:System.String" />.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.ITokenizer`3">
            <summary>
                An interface for tokenizers.
            </summary>
            <typeparam name="TToken">The type of the tokens that the tokenizer returns.</typeparam>
            <typeparam name="TSequenceable">The type whose sequences are expected to be tokenized.</typeparam>
            <typeparam name="TSequence">
                The type of the actual sequence used to sequence objects of
                <typeparamref name="TSequenceable" />.
            </typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.ITokenizer`3.Tokenize(`2)">
            <summary>
                Tokenizes a sequence.
            </summary>
            <param name="sequence">The sequence of things to tokenize.</param>
            <returns>A semantic tokenization of <paramref name="sequence" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.ITokenizer`3.Tokenize(System.Collections.Generic.IEnumerable{`2})">
            <summary>
                Tokenizes a sequence of sequences.
            </summary>
            <param name="sequences">The sequence of sequences to tokenize.</param>
            <returns>One sequence of semantics tokens per sequence in <paramref name="sequences" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.ITokenizer`3.TokenAtStartOrDefault(`2)">
            <summary>
                Retrieves a token if and only if the <paramref name="sequence" /> begins with a token that this tokenizer
                recognizes.
            </summary>
            <param name="sequence">The sequence in which to look for the token.</param>
            <returns>
                The first occurrence of a token if <paramref name="sequence" /> begins with the token, otherwise
                <c>default(TToken)</c>.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.StringToken">
            <summary>
                Represents an <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.IToken`2" /> where the sequenceable type is <see cref="T:System.Char" />
                and a <see cref="T:System.String" /> is used to hold a sequence of <see cref="T:System.Char" />s.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.StringToken.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The source string.</param>
            <param name="start">The start index of this token in <paramref name="source" />.</param>
            <param name="end">The end index (exclusive) of this token in <paramref name="source" />.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.StringToken.Equals(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.StringToken)">
            <summary>Indicates whether the current object is equal to another object of the same type.</summary>
            <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.StringToken.SourceSequence">
            <summary>
                The source sequence of this token.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.StringToken.StartInSequence">
            <summary>
                The start index in the source sequence for this token.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.StringToken.EndInSequence">
            <summary>
                The end index (exclusive) in the source sequence for this token.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.StringToken.TokenSubSequence">
            <summary>
                The actual value of this token, represented as a contiguous subsequence of
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.IToken`2.SourceSequence" /> from
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.IToken`2.StartInSequence" /> to
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.IToken`2.EndInSequence" />, exclusive.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.StringToken.SourceString">
            <summary>
                The backing <see cref="T:System.String" /> on top of which the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.IToken`2.SourceSequence" />
                is built.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.StringToken.Start">
            <summary>
                The start index of the string corresponding to the value
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.IToken`2.StartInSequence" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.StringToken.End">
            <summary>
                The end index of the string corresponding to the value <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.IToken`2.EndInSequence" />
                .
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.StringToken.Length">
            <summary>
                The length of this token (End - Start).
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.StringToken.Value">
            <summary>
                The value of this token represented as a <see cref="T:System.String" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.StringToken.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
            <returns>true if the specified object  is equal to the current object; otherwise, false.</returns>
            <param name="other">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.StringToken.GetHashCode">
            <summary>Serves as the default hash function. </summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Tokenizer`3">
            <summary>
                A convenience abstract base class to build tokenizers upon. Provides a default implementation of
                <see cref="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Tokenizer`3.Tokenize(System.Collections.Generic.IEnumerable{`2})" />.
            </summary>
            <typeparam name="TToken">The type of tokens.</typeparam>
            <typeparam name="TSequenceable">The type of the sequenceable that the tokenizer accepts.</typeparam>
            <typeparam name="TSequence">The type of the sequence that the tokenizer accepts.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Tokenizer`3.Tokenize(`2)">
            <summary>
                Tokenizes a sequence.
            </summary>
            <param name="sequence">The sequence of things to tokenize.</param>
            <returns>A tokenization of <paramref name="sequence" /></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Tokenizer`3.Tokenize(System.Collections.Generic.IEnumerable{`2})">
            <summary>
                Tokenizes a sequence of sequences.
            </summary>
            <param name="sequences">The sequence of sequences to tokenize.</param>
            <returns>One sequence of tokens per sequence in <paramref name="sequences" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Tokenizer`3.TokenAtStartOrDefault(`2)">
            <summary>
                Retrieves a token if and only if the <paramref name="sequence" /> begins with a token that this tokenizer
                recognizes.
            </summary>
            <param name="sequence">The sequence in which to look for the token.</param>
            <returns>
                The first occurrence of a token if <paramref name="sequence" /> begins with the token, otherwise
                <c>default(TToken)</c>.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Translation.Python.TranslationMapping">
            <summary>
                A helper class that generates the required code for <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityBasedTokenizer" />s.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Translation.Python.TranslationMapping.GetSourceCodeForType(System.Type)">
            <summary>
                Gets all the Python source code units corresponding to a given type.
            </summary>
            <param name="type">The type to translate.</param>
            <returns>
                A list of <see cref="T:System.Collections.Generic.KeyValuePair`2" />s with TKey = <see cref="T:System.String" /> and TValue =
                <see cref="T:System.String" />. The <see cref="P:System.Collections.Generic.KeyValuePair`2.Key" /> of each pair represents the name of the
                code unit and the <see cref="P:System.Collections.Generic.KeyValuePair`2.Value" /> reprensents the actual code.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.CompletionInfo">
            <summary>
                Auxiliary information which may be useful for ranking.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.CompletionInfo.#ctor(System.String,System.String,Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken,System.Double,System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <summary>
                Constructor.
            </summary>
            <param name="key">The key associated with this completion.</param>
            <param name="value">The actual value to be used as a completion/suggestion.</param>
            <param name="token">The <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that corresponds to this autocomplete suggestion.</param>
            <param name="relativeScore">The relative score for this suggestion. See <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.CompletionInfo.RelativeScore" />.</param>
            <param name="metadata">A property map containing any metadata associated with this suggestion.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.CompletionInfo.#ctor(System.String,Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken,System.Double,System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <summary>
                Constructor.
            </summary>
            <param name="key">
                The key associated with this completion. This key is also used a <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.CompletionInfo.Value" /> for this
                completion.
            </param>
            <param name="token">The <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" /> that generated this completion.</param>
            <param name="relativeScore">The relative score for this suggestion. <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.CompletionInfo.RelativeScore" />.</param>
            <param name="metadata">A property map containing any metadata associated with this suggestion.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.CompletionInfo.Token">
            <summary>
                The token that the entry corresponds to
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.CompletionInfo.RelativeScore">
            <summary>
                A score value that is relative to all the other completions suggested by <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.CompletionInfo.Token" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.CompletionInfo.Value">
            <summary>
                The actual completion value, in the event that we need to map a value to a key that isn't
                a prefix of the value.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.CompletionInfo.Key">
            <summary>
                The key that triggers this completion.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.CompletionInfo.Metadata">
            <summary>
                Metadata about this completion.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.CompletionInfo.EntityScoreMultiplier">
            <summary>
                The score multiplier for the entity. See <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Entities.EntityToken" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.CompletionInfo.ToString">
            <summary>Returns the fully qualified type name of this instance.</summary>
            <returns>A <see cref="T:System.String" /> containing a fully qualified type name.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.CompletionInfo.CloneWithValue(System.String,System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <summary>
                Clones this <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.CompletionInfo" /> object with all fields identical,
                except for the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.CompletionInfo.Value" /> field, which takes its value from the
                parameter <paramref name="value" />.
            </summary>
            <param name="value">The updated <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.CompletionInfo.Value" /> field.</param>
            <param name="metadata">
                A property map containing any metadata associated with this suggestion. If null then
                <c>this.Metadata</c> will be used instead.
            </param>
            <returns>
                A new <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.CompletionInfo" /> object with the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.CompletionInfo.Value" /> field set to
                <paramref name="value" />.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence">
            <summary>
                A subsequence of a string.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence.Empty">
            <summary>
                The empty subsequence.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence.Equals(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence)">
            <summary>Indicates whether the current object is equal to another object of the same type.</summary>
            <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence.GetEnumerator">
            <summary>Returns an enumerator that iterates through the collection.</summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary>
            <returns>An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence.FullSequence">
            <summary>
                A reference to the entire sequence.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence.FullLength">
            <summary>
                The length of the full sequence that this sequence derives from.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence.Item(System.Int32)">
            <summary>
                Returns the <see cref="T:System.Char" /> object at <paramref name="position" /> in
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.Value" />.
            </summary>
            <param name="position">The relative index into this sequence, at which the object to be retrieved resides.</param>
            <returns>
                The <see cref="T:System.Char" /> at <paramref name="position" /> in
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.Value" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence.AbsoluteSlice(System.UInt32,System.UInt32)">
            <summary>
                Returns an absolute slice of this subsequence
            </summary>
            <param name="start">
                The start index of the absolute slice, i.e., relative to
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.FullSequence" />.
            </param>
            <param name="end">
                The end index (exclusive) of the absolute slice, i.e., relateive to
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.FullSequence" />.
            </param>
            <returns>A <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence" /> that represents the absolute slice.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence.StartsWith(System.String)">
            <summary>
                Checks if this sequence starts with the provided prefix
            </summary>
            <param name="prefix">The prefix to check.</param>
            <returns>true if this subsequence begins with <see cref="!:prefix" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence.StartsWith(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence)">
            <summary>
                Checks if this sequence starts with the provided prefix
            </summary>
            <param name="prefix">The prefix to check.</param>
            <returns>true if this subsequence begins with <see cref="!:prefix" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence.FindFirstMismatchingIndex(System.String)">
            <summary>
                Finds the first position in this sequence, at which the value does not agree with the value in the same position in
                <paramref name="prefix" />.
            </summary>
            <param name="prefix">The prefix to check.</param>
            <returns>
                The index of the first position in <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.Value" /> such
                that the value at the same position in
                <paramref name="prefix" /> does not equal the value at the position in
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.Value" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence.FindFirstMismatchingIndex(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence)">
            <summary>
                Finds the first position in this sequence, at which the value does not agree with the value in the same position in
                <paramref name="prefix" />.
            </summary>
            <param name="prefix">The prefix to check.</param>
            <returns>
                The index of the first position in <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.Value" /> such
                that the value at the same position in
                <paramref name="prefix" /> does not equal the value at the position in
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.AutoCompletion.SearchTree.ISubSequence`3.Value" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence.Concat(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence)">
            <summary>
                Create a new subsequence which is the concatenation of this subsequence with <paramref name="other" />.
            </summary>
            <param name="other">The subsequence to concatenate at the end of this.</param>
            <returns>A new subsequence which represents this subsequence concentenated with <paramref name="other" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence.Concat(System.String)">
            <summary>
                Create a new subsequence which is the concatenation of this subsequence with <paramref name="other" />.
            </summary>
            <param name="other">The sequence to concatenate at the end of this.</param>
            <returns>A new subsequence which represents this subsequence concentenated with <paramref name="other" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence.Create(System.String)">
            <summary>
                Create a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence" /> with represents the entire <see cref="T:System.String" /> s.
            </summary>
            <param name="s">The string.</param>
            <returns>A <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence" /> that represents the entire <see cref="T:System.String" /> <paramref name="s" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence.Create(System.String,System.UInt32)">
            <summary>
                Create a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence" /> with represents a suffix of <see cref="T:System.String" /> s.
            </summary>
            <param name="s">The string.</param>
            <param name="start">The starting index of the suffix.</param>
            <returns>
                A <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence" /> that represents the suffix of <see cref="T:System.String" /> <paramref name="s" />,
                starting at <paramref name="start" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence.Create(System.String,System.UInt32,System.UInt32)">
            <summary>
                Create a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence" /> which represents a substring of a string.
            </summary>
            <param name="s">The string.</param>
            <param name="start">The starting index in <paramref name="s" /> of the substring.</param>
            <param name="end">The ending index (exclusive) in <paramref name="s" /> of the substring.</param>
            <returns>
                A <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence" /> that represents the substring of <paramref name="s" />, beginning at
                <paramref name="start" /> and ending at <paramref name="end" /> (exclusive).
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
            <returns>true if the specified object  is equal to the current object; otherwise, false.</returns>
            <param name="other">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence.GetHashCode">
            <summary>Serves as the default hash function. </summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.StringSubSequence.ToString">
            <summary>Returns a string that represents the current object.</summary>
            <returns>A string that represents the current object.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern.#ctor(System.String,System.String,System.String,System.Boolean,System.Boolean,System.Text.RegularExpressions.RegexOptions[])">
            <summary>
                Constructor.
            </summary>
            <param name="contentPattern">The regular expression pattern that matches the content.</param>
            <param name="leftContextPattern">The regular expression pattern that must match to the left of the content.</param>
            <param name="rightContextPattern">The regular expression pattern that must match to the right of the content.</param>
            <param name="captureLeftContext">
                A flag that indicates that the left context needs to be captured, applicable only if
                <paramref name="leftContextPattern" /> is not null and not the empty string.
            </param>
            <param name="captureRightContext">
                A flag that indicates that the right context needs to be captured, applicable only if
                <paramref name="rightContextPattern" /> is not null and not the empty string.
            </param>
            <param name="regexOptions">
                Any additional <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern.RegexOptions" /> to use when constructing the <see cref="T:System.Text.RegularExpressions.Regex" />
                .
            </param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern.LeftContextGroupName">
            <summary>
                The name of the group used to capture the left context, if context captures are enabled.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern.RightContextGroupName">
            <summary>
                The name of the group used to capture the right context, if context captures are enabled.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern.ContentGroupName">
            <summary>
                The name of the group used to capture the actual content.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern.LeftContextPattern">
            <summary>
                The pattern to match on the left of the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern.ContentPattern" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern.ContentPattern">
            <summary>
                The pattern used to match the actual content.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern.RightContextPattern">
            <summary>
                The pattern to match on the right of the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern.ContentPattern" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern.CaptureLeftContext">
            <summary>
                Should the match for <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern.LeftContextPattern" /> be captured?
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern.CaptureRightContext">
            <summary>
                Should the match for <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern.RightContextPattern" /> be captured?
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern.RegexToMatch">
            <summary>
                The final <see cref="T:System.Text.RegularExpressions.Regex" /> object constructed according to <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern.LeftContextPattern" />,
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern.RightContextPattern" />, <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern.ContentPattern" /> as well as the flags
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern.CaptureLeftContext" /> and <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern.CaptureRightContext" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern.Equals(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern)">
            <summary>Indicates whether the current object is equal to another object of the same type.</summary>
            <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
            <returns>true if the specified object  is equal to the current object; otherwise, false.</returns>
            <param name="other">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern.GetHashCode">
            <summary>Serves as the default hash function. </summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern.Clone">
            <summary>
                Clones this <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern" /> object. All <see cref="T:System.Text.RegularExpressions.Regex" /> objects used internally are cloned.
            </summary>
            <returns>A new <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern" /> object that is equivalent to <c>this</c>.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern.Matches(System.String)">
            <summary>
                Compute all matches for this <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern" /> in the string <paramref name="s" />.
            </summary>
            <param name="s">The string to match this <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern" /> on.</param>
            <returns>
                A sequence of <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPatternMatch" /> objects, one for each non-overlapping match in
                <paramref name="s" />. Note that the right context of one match can be used as the left context
                of the next match. Only the content matches are guaranteed to be non-overlapping.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPatternMatch">
            <summary>
                Represents a match of a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPatternMatch.LeftContextGroup">
            <summary>
                The <see cref="T:System.Text.RegularExpressions.Group" /> representing the match for the left context of the <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern" />.
                <c>null</c> if no left context pattern was specified, or the left context was not requested to be captured.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPatternMatch.RightContextGroup">
            <summary>
                The <see cref="T:System.Text.RegularExpressions.Group" /> representing the match for the right context of the <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern" />.
                <c>null</c> if no right context pattern was specified, or the right context was not requested to be captured.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPatternMatch.ContentGroup">
            <summary>
                The <see cref="T:System.Text.RegularExpressions.Group" /> representing the match for the content pattern of the <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPatternMatch.FullMatch">
            <summary>
                A complete match of <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern.RegexToMatch" /> on <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPatternMatch.Source" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPatternMatch.Source">
            <summary>
                The source string that was matched with a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern" /> to obtain <c>this</c>
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPatternMatch" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPatternMatch.Pattern">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPattern" /> that produced this <see cref="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPatternMatch" /> when applied to
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPatternMatch.Source" />
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPatternMatch.Start">
            <summary>
                The start index of the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPatternMatch.ContentGroup" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPatternMatch.End">
            <summary>
                The end index (exclusive) of the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPatternMatch.ContentGroup" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPatternMatch.Length">
            <summary>
                The length of the string matched by <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPatternMatch.ContentGroup" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPatternMatch.Value">
            <summary>
                The actual value of the string matched by <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.TokenPatternMatch.ContentGroup" />.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.UnicodeCategoryUtils">
            <summary>
                Helper class to ease transition to coreclr
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.UnicodeCategoryUtils.GetUnicodeCategory(System.Char)">
            <summary>
                Retrieves the unicode catergory for a character.
            </summary>
            <param name="c">The character.</param>
            <returns>The unicode category for <paramref name="c" />.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.ValueAndCount`1">
            <summary>
                Represents a value and a count associated with the value
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.ValueAndCount`1.Value">
            <summary>
                Retrieves the value.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.ValueAndCount`1.Count">
            <summary>
                Retrieves the count associated with <see cref="P:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.ValueAndCount`1.Value" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.ValueAndCount`1.#ctor(`0,System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="value">The value to be stored.</param>
            <param name="count">The count associated with <paramref name="value" />.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.ValueAndCount`1.Equals(Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.ValueAndCount{`0})">
            <summary>Indicates whether the current object is equal to another object of the same type.</summary>
            <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.ValueAndCount`1.Equals(System.Object)">
            <summary>Indicates whether this instance and a specified object are equal.</summary>
            <returns>
                true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise,
                false.
            </returns>
            <param name="obj">The object to compare with the current instance. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.ValueAndCount`1.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
            <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.ValueAndCount`1.ToString">
            <summary>Returns the fully qualified type name of this instance.</summary>
            <returns>A <see cref="T:System.String" /> containing a fully qualified type name.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.VariableLengthBitArrayUtils">
            <summary>
                Helper functions for manipulation of bit-vectors which can possibly have varying lengths.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.VariableLengthBitArrayUtils.Canonicalize(System.Collections.BitArray,System.Collections.BitArray,System.Collections.BitArray@,System.Collections.BitArray@,System.Boolean)">
            <summary>
                Adjust lengths so that the two bitvectors have the same "universe"
            </summary>
            <param name="b0">The first bitvector to canonicalize.</param>
            <param name="b1">The second bitvector to canonicalize.</param>
            <param name="canonicalB0">The canonicalized bitvectors corresponding to <paramref name="b0" />.</param>
            <param name="canonicalB1">The canonicalized bitvectors corresponding to <paramref name="b1" />.</param>
            <param name="value">The boolean value to pad into the bitvector that has been extended to match the other one.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.VariableLengthBitArrayUtils.Canonicalize(System.Collections.BitArray,System.Collections.BitArray,System.Boolean)">
            <summary>
                Adjust lengths so that the two bitvectors have the same "universe". The canonicalization is done "in-place", i.e.,
                the two input bitvectors are modified.
            </summary>
            <param name="b0">The first bitvector to canonicalize.</param>
            <param name="b1">The second bitvector to canonicalize.</param>
            <param name="value">The boolean value to pad into the bitvector that has been extended to match the other one.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.VariableLengthBitArrayUtils.FunctionalOr(System.Collections.BitArray,System.Collections.BitArray,System.Boolean)">
            <summary>
                Returns a new <see cref="T:System.Collections.BitArray" /> that represents the "Or" of the two input <see cref="T:System.Collections.BitArray" />s.
            </summary>
            <param name="b0">The first <see cref="T:System.Collections.BitArray" />.</param>
            <param name="b1">The second <see cref="T:System.Collections.BitArray" />.</param>
            <param name="value">
                The value to insert into the shorter <see cref="T:System.Collections.BitArray" />, to make its length equal to the other
                <see cref="T:System.Collections.BitArray" />.
            </param>
            <returns>
                A new <see cref="T:System.Collections.BitArray" /> that represents the "Or" of the canonicalized versions of <paramref name="b0" />
                and <paramref name="b1" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.VariableLengthBitArrayUtils.FunctionalAnd(System.Collections.BitArray,System.Collections.BitArray,System.Boolean)">
            <summary>
                Returns a new <see cref="T:System.Collections.BitArray" /> that represents the "And" of the two input <see cref="T:System.Collections.BitArray" />s.
            </summary>
            <param name="b0">The first <see cref="T:System.Collections.BitArray" />.</param>
            <param name="b1">The second <see cref="T:System.Collections.BitArray" />.</param>
            <param name="value">
                The value to insert into the shorter <see cref="T:System.Collections.BitArray" />, to make its length equal to the other
                <see cref="T:System.Collections.BitArray" />.
            </param>
            <returns>
                A new <see cref="T:System.Collections.BitArray" /> that represents the "And" of the canonicalized versions of
                <paramref name="b0" /> and <paramref name="b1" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.VariableLengthBitArrayUtils.FunctionalNot(System.Collections.BitArray)">
            <summary>
                Returns a new <see cref="T:System.Collections.BitArray" /> that represents the bitwise negation of the input <see cref="T:System.Collections.BitArray" />.
            </summary>
            <param name="b0">The <see cref="T:System.Collections.BitArray" />.</param>
            <returns>A new <see cref="T:System.Collections.BitArray" /> that represents the negation of <paramref name="b0" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.VariableLengthBitArrayUtils.FunctionalXor(System.Collections.BitArray,System.Collections.BitArray,System.Boolean)">
            <summary>
                Returns a new <see cref="T:System.Collections.BitArray" /> that represents the "Xor" of the two input <see cref="T:System.Collections.BitArray" />s.
            </summary>
            <param name="b0">The first <see cref="T:System.Collections.BitArray" />.</param>
            <param name="b1">The second <see cref="T:System.Collections.BitArray" />.</param>
            <param name="value">
                The value to insert into the shorter <see cref="T:System.Collections.BitArray" />, to make its length equal to the other
                <see cref="T:System.Collections.BitArray" />.
            </param>
            <returns>
                A new <see cref="T:System.Collections.BitArray" /> that represents the "Xor" of the canonicalized versions of <paramref name="b0" />
                and <paramref name="b1" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.VariableLengthBitArrayUtils.InPlaceOr(System.Collections.BitArray,System.Collections.BitArray,System.Boolean)">
            <summary>
                Modifies the source <see cref="T:System.Collections.BitArray" /> in place to represent the value obtained by "or"-ing with the other
                <see cref="T:System.Collections.BitArray" />.
            </summary>
            <param name="b0">The source <see cref="T:System.Collections.BitArray" />.</param>
            <param name="b1">The <see cref="T:System.Collections.BitArray" /> to "or" with <see cref="!:b0" />.</param>
            <param name="value">
                The value to insert into the shorter <see cref="T:System.Collections.BitArray" />, to make its length equal to the other
                <see cref="T:System.Collections.BitArray" />.
            </param>
            <returns>
                <paramref name="b0" />, "or"-ed in place with <paramref name="b1" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.VariableLengthBitArrayUtils.InPlaceAnd(System.Collections.BitArray,System.Collections.BitArray,System.Boolean)">
            <summary>
                Modifies the source <see cref="T:System.Collections.BitArray" /> in place to represent the value obtained by "and"-ing with the other
                <see cref="T:System.Collections.BitArray" />.
            </summary>
            <param name="b0">The source <see cref="T:System.Collections.BitArray" />.</param>
            <param name="b1">The <see cref="T:System.Collections.BitArray" /> to "or" with <see cref="!:b0" />.</param>
            <param name="value">
                The value to insert into the shorter <see cref="T:System.Collections.BitArray" />, to make its length equal to the other
                <see cref="T:System.Collections.BitArray" />.
            </param>
            <returns>
                <paramref name="b0" />, "and"-ed in place with <paramref name="b1" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.VariableLengthBitArrayUtils.InPlaceXor(System.Collections.BitArray,System.Collections.BitArray,System.Boolean)">
            <summary>
                Modifies the source <see cref="T:System.Collections.BitArray" /> in place to represent the value obtained by "xor"-ing with the other
                <see cref="T:System.Collections.BitArray" />.
            </summary>
            <param name="b0">The source <see cref="T:System.Collections.BitArray" />.</param>
            <param name="b1">The <see cref="T:System.Collections.BitArray" /> to "or" with <see cref="!:b0" />.</param>
            <param name="value">
                The value to insert into the shorter <see cref="T:System.Collections.BitArray" />, to make its length equal to the other
                <see cref="T:System.Collections.BitArray" />.
            </param>
            <returns>
                <paramref name="b0" />, "xor"-ed in place with <paramref name="b1" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.EntityExtraction.Utils.VariableLengthBitArrayUtils.ExtendAndUpdate(System.Collections.BitArray,System.Int32,System.Boolean)">
            <summary>
                Extends a <see cref="T:System.Collections.BitArray" /> if necessary and then updates the value at a given index.
            </summary>
            <param name="b0">The <see cref="T:System.Collections.BitArray" />.</param>
            <param name="position">The position at which the value is to be updated in <paramref name="b0" />.</param>
            <param name="value">The value.</param>
            <returns>
                <paramref name="b0" /> extended if necessary, with the value in b0 at <paramref name="position" /> set to
                <paramref name="value" />.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Example">
            <summary>
                An example for a Transformation.Text learning task. An example consists of an <see cref="T:Microsoft.ProgramSynthesis.Wrangling.InputRow" /> and an output
                string.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Example.#ctor(Microsoft.ProgramSynthesis.Wrangling.IRow,System.Object,System.Boolean)">
            <summary>
                Constructs an example with the given input and output.
            </summary>
            <param name="input">The example input</param>
            <param name="output">The desired output on that input</param>
            <param name="isSoft">If true, this example is not required to be satisfied.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Example.ToAnonymizedString">
            <summary> 
                Returns a string that shows the masked values of 
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ConstraintOnInput`2.Input" /> and 
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Constraints.ValueToValueConstraint`2.Output" />.
                Upper case letters are converted to 'A', Lower case letters are converted to 'a',
                Numbers are converted to '9', Non-alphanumerics are preserved.
            </summary> 
            <returns> 
                A string that represents this example. 
            </returns> 
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Exceptions.InputsRequiredException">
            <summary>
                Indicates that a program could not be learned as the constraints indicate that inputs should be used to learn but
                no inputs were provided.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Exceptions.InputsRequiredException.#ctor">
            <summary>
                Constructs an <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Exceptions.InputsRequiredException" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Exceptions.InputsRequiredException.#ctor(System.String)">
            <summary>
                Constructs an <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Exceptions.InputsRequiredException" /> with the specified <paramref name="message" />.
            </summary>
            <param name="message">Message for this exception.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Exceptions.InvalidConstraintException">
            <summary>
                Indicates that a program could not be learned because a constraint is invalid.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Exceptions.InvalidConstraintException.#ctor">
            <summary>
                Constructs an <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Exceptions.InvalidConstraintException" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Exceptions.InvalidConstraintException.#ctor(System.String)">
            <summary>
                Constructs an <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Exceptions.InvalidConstraintException" /> with the specified <paramref name="message" />.
            </summary>
            <param name="message">Message for this exception.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Exceptions.InvalidInputException">
            <summary>
                Indicates that a program could not be learned because a provided input is invalid.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Exceptions.InvalidInputException.#ctor">
            <summary>
                Constructs an <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Exceptions.InvalidInputException" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Exceptions.InvalidInputException.#ctor(System.String)">
            <summary>
                Constructs an <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Exceptions.InvalidInputException" /> with the specified <paramref name="message" />.
            </summary>
            <param name="message">Message for this exception.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Exceptions.LearningException">
            <summary>
                The base class for learning exceptions.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Exceptions.LearningException.#ctor(System.String)">
            <summary>
                Constructs a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Exceptions.LearningException" /> with the specified <paramref name="message" />.
            </summary>
            <param name="message">Message for this exception.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Exceptions.ProgramSynthesisException">
            <summary>
                The base class for all learning/running exceptions.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Exceptions.ProgramSynthesisException.#ctor(System.String)">
            <summary>
                Constructs a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Exceptions.ProgramSynthesisException" /> with the specified <paramref name="message" />.
            </summary>
            <param name="message">Message for this exception.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Exceptions.RunningException">
            <summary>
                The base class for running exceptions.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Exceptions.RunningException.#ctor(System.String)">
            <summary>
                Constructs a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Exceptions.RunningException" /> with the specified <paramref name="message" />.
            </summary>
            <param name="message">Message for this exception.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.ExtractionLoader`3.VersionParsers">
            <summary>
                Pairs of (version, parser) in descending order.
                If the current assembly version greater than or equal to the (version) key, use the (parser) value.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.ExtractionLoader`3.DefaultVersionParser">
            <summary>
                Version parser to use when version information is missing.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.ExtractionLoader`3.Microsoft#ProgramSynthesis#Wrangling#IProgramLoader{TSequenceProgram,System#Collections#Generic#IEnumerable{TRegion},System#Collections#Generic#IEnumerable{System#Collections#Generic#IEnumerable{TRegion}}}#Create(Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Wraps a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> in a <typeparamref name="TSequenceProgram" />. <paramref name="program" /> must be a
                valid program for a <typeparamref name="TSequenceProgram" />.
            </summary>
            <param name="program">The code of the program.</param>
            <returns>A strongly-typed <typeparamref name="TSequenceProgram" /> object wrapping <paramref name="program" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.ExtractionLoader`3.Microsoft#ProgramSynthesis#Wrangling#IProgramLoader{TRegionProgram,System#Collections#Generic#IEnumerable{TRegion},System#Collections#Generic#IEnumerable{TRegion}}#Create(Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Wraps a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> in a <typeparamref name="TRegionProgram" />. <paramref name="program" /> must be a
                valid program for a <typeparamref name="TRegionProgram" />.
            </summary>
            <param name="program">The code of the program.</param>
            <returns>A strongly-typed <typeparamref name="TRegionProgram" /> object wrapping <paramref name="program" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.ExtractionLoader`3.CreateProgram(Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.Wrangling.ExtractionKind,Microsoft.ProgramSynthesis.Wrangling.ReferenceKind,System.Nullable{System.Double})">
            <summary>
                Wraps a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> in an <see cref="T:Microsoft.ProgramSynthesis.Wrangling.IExtractionProgram`1" />,
                so it can be more easily used for extraction tasks.
            </summary>
            <param name="programNode">The program AST as a Microsoft.ProgramSynthesis <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" />.</param>
            <param name="extractionKind">The kind of program.</param>
            <param name="refKind">The kind of reference the program expects as input.</param>
            <param name="score">The computed score of the program.</param>
            <returns>
                A <see cref="T:Microsoft.ProgramSynthesis.Wrangling.IExtractionProgram`1" /> wrapping a lower-level <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> of the AST of
                an extraction program.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.ExtractionLoader`3.Load(System.String,Microsoft.ProgramSynthesis.AST.ASTSerializationFormat,Microsoft.ProgramSynthesis.AST.DeserializationContext)">
            <summary>
                Deserializes the program from the serialized program string and the serialization format.
            </summary>
            <param name="serializedProgram">The serialized program string.</param>
            <param name="serializationFormat">The format used to serialize the program.</param>
            <returns>The extraction program stored in <paramref name="serializedProgram" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.ExtractionLoader`3.Load(System.String,Microsoft.ProgramSynthesis.AST.ASTSerializationFormat,Microsoft.ProgramSynthesis.AST.DeserializationContext,Microsoft.ProgramSynthesis.AST.ProgramNodeParser)">
            <summary>
                Deserializes the program from the serialized program string, the serialization format and a custom
                ProgramNode parser.
            </summary>
            <param name="serializedProgram">The serialized program string.</param>
            <param name="serializationFormat">The format used to serialize the program.</param>
            <param name="programNodeParser">Custom ProgramNode parser.</param>
            <param name="context">A context to pass through to all deserialization methods.</param>
            <returns>The extraction program stored in <paramref name="serializedProgram" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.ExtractionLoader`3.Convert(System.String,System.Version,System.Version)">
            <summary>
                Convert a serialized program from the format of an older version <paramref name="from" />
                to the format of the newer version <paramref name="to" />.
            </summary>
            <param name="serializedProgram">The serialized program.</param>
            <param name="from">The old version.</param>
            <param name="to">The new version.</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.ExtractionProgram`2">
            <summary>
                A program for performing a single extraction task. An extraction program takes a reference region as input and
                outputs zero or more extracted regions depending on its <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ExtractionKind"/>.
            </summary>
            <typeparam name="TExtractionProgram">The type of extraction program. Should be the type of the implementing subclass.</typeparam>
            <typeparam name="TRegion">The type of extracted region.</typeparam>
            <see cref="!:SchemaProgram&lt;TExtractionProgram,TSelector,TRegion&gt;" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.ExtractionProgram`2.Run(`1)">
            <summary>
            <para>
            Executes the program on a referencing region.
            If the program is a region program, the result is the first element in the output list.
            </para>
            <para>
            The output list may contain null.
            The reason is the training examples are not representative enough (i.e., <paramref name="reference"/>
            contains new, unseen structures).
            </para>
            </summary>
            <param name="reference">The referencing region to run the program on.</param>
            <returns>An output sequence of regions</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.ExtractionProgram`2.Run(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Executes the program on a sequence of referencing regions and obtains a sequence of output regions and their referencing regions.
            The output list may contain null outputs.
            The reason is the training examples are not representative enough (i.e., <paramref name="references"/>
            contains new, unseen structures).
            </summary>
            <param name="references">The sequence of referencing regions to run the program on.</param>
            <returns>An sequence of output regions and their referencing regions.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.ExtractionProgram`2.OutputRun(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Executes the program on a sequence of referencing regions and obtains a sequence of output regions.
            This method is similar to <see cref="M:Microsoft.ProgramSynthesis.Wrangling.ExtractionProgram`2.Run(System.Collections.Generic.IEnumerable{`1})"/> except that it does not keep the referencing regions with the output regions.
            The output list may contain nulls.
            The reason is the training examples are not representative enough (i.e., <paramref name="references"/>
            contains new, unseen structures).
            </summary>
            <param name="references">The sequence of referencing regions to run the program on.</param>
            <returns>An sequence of output regions.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.HumanReadableSchemaPrintVisitor`3">
            <summary>
            SchemaPrintVisitor used to get <see cref="F:Microsoft.ProgramSynthesis.AST.ASTSerializationFormat.HumanReadable"/> representation of SchemaNode.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.ExtractionKind">
            <summary>
                The kind of an extraction task.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.ExtractionKind.Region">
            <summary>
                Extraction of at most one element from each reference region.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.ExtractionKind.Sequence">
            <summary>
                Extraction of multiple elements from each reference region.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.ReferenceKind">
            <summary>
                How the reference region relates to the region to be extracted in the structure of the document.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.ReferenceKind.Invalid">
            <summary>
                Dummy value that should not be used to ensure <c>default(ReferenceKind)</c> is invalid.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.ReferenceKind.Parent">
            <summary>
                The reference region is a parent of the region to be extracted.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.ReferenceKind.PrecedingSibling">
            <summary>
                The reference region is a sibling of the region to be extracted and appears earlier in the document.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.ReferenceKind.SucceedingSibling">
            <summary>
                The reference region is a sibling of the region to be extracted and appears later in the document.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.IExtractionProgram`1.ExtractionKind">
            <summary>
                Represents the extraction kind of this program.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.IExtractionProgram`1.ReferenceKind">
            <summary>
                Specifies how this program relates to its referenced field.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.InputOutputs`1">
            <summary>
            A wrapper around regions to record relation between regions (e.g. used in dependent negative examples).
            One region is the input, and other dependent regions are stored in Outputs.
            </summary>
            <typeparam name="TRegion">The type of region it wraps</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.InputOutputs`1.Input">
            <summary>
            The input.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.InputOutputs`1.InputName">
            <summary>
            The name of the input.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.InputOutputs`1.Outputs">
            <summary>
            The list of outputs.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.InputOutputs`1.#ctor(`0,System.String,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Constructs the object from its properties.
            </summary>
            <param name="input">The input.</param>
            <param name="inputName">The name of the input.</param>
            <param name="outputs">The list of outputs.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.InputRow">
            <summary>
                An IRow implementation backed by an <c>ImmutableDictionary&lt;string, object&gt;</c>. Supports name/
                value pairs that are used to perform input lookup.  Also supports scenarios where only the values are
                specified and the columns are named implicitly using integers starting from 0.
                
                NOTE: For many cases it will be more efficient to implement IRow on your own type rather than copying data
                into an instance of this class, but this is available primarily to make it easy to get working quickly.
            </summary>
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.INumberedRow.RowNumber">
            <summary>
                Position of the current row.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.IProgramProperties">
            <summary>
                The interface for describing the metadata of an <see cref="T:Microsoft.ProgramSynthesis.Program`2" /> object.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.IRow">
            <summary>
                An input row which consists of one or more named columns identified by <see cref="T:System.String" />s. Each value is an
                <see cref="T:System.Object" /> which must actually be a <see cref="T:System.String" /> (other types will be supported in the future).
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.IRow.ColumnNames">
            <summary>
                Optional field giving the names of all of the columns in the row. Note that if this is missing during learning,
                then the set of available column names will have to be provided in some other way.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.IRow.TryGetValue(System.String,System.Object@)">
            <summary>
                Gets the value of the column named <paramref name="columnName" /> and puts it in <paramref name="value" /> if
                possible.
            </summary>
            <param name="columnName">The name of the column to get.</param>
            <param name="value">
                The value of the column. This must be a <see cref="T:System.String" /> (except internally during learning it may be a
                <see cref="!:ValueSubstring" />). Future versions will support other types.
            </param>
            <returns>
                <code>true</code> if the column exists and <paramref name="value" /> has been populated, or <code>false</code>
                otherwise.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.ITypedValue">
            <summary>
                A value that can be interpreted as a strongly typed value. The storage of the value is as a string
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ITypedValue.Value" />, which is interpreted by the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ITypedValue.Type" /> as some other types.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.ITypedValue.Value">
            <summary>
                The untyped value of this object.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.ITypedValue.Type">
            <summary>
                The type of the object. Used to convert to a strongly typed value.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.ITypedValue.GetTypedValue``1">
            <summary>
                If possible, get this value as type <typeparamref name="T" />. This uses <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ITypedValue.Type" /> and
                <see cref="M:Microsoft.ProgramSynthesis.Wrangling.IType`1.GetTypedValue(Microsoft.ProgramSynthesis.Wrangling.ITypedValue)" /> to do the conversion. This method exists to allow implementers of this
                interface to memoize the result.
            </summary>
            <typeparam name="T">Type to attempt to convert to.</typeparam>
            <returns>
                This value converted to <typeparamref name="T" /> according to <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ITypedValue.Type" /> or
                <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" />.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.IType">
            <summary>
                Supertype for the Microsoft.ProgramSynthesis type hierarchy.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.IType.IsValidObject(Microsoft.ProgramSynthesis.Wrangling.ITypedValue)">
            <summary>
                Checks if an object is valid element of the given type.
            </summary>
            <param name="obj">Object to check.</param>
            <returns>True if object can be treated as a value of this type or false otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.IType.IsAssignableFrom(Microsoft.ProgramSynthesis.Wrangling.IType)">
            <summary>
                Checks if this type is a superset of another type. That is, if true, then whenever <paramref name="other" />
                returns true for <see cref="M:Microsoft.ProgramSynthesis.Wrangling.IType.IsValidObject(Microsoft.ProgramSynthesis.Wrangling.ITypedValue)" /> so does this.
            </summary>
            <param name="other">Type to check if it can be used whenever this is expected.</param>
            <returns>True if <paramref name="other" /> is a subtype of this type.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.IType`1">
            <summary>
                A type whose values can be converted to the .NET type <typeparamref name="T" />.
            </summary>
            <typeparam name="T">.NET type this type can convert values to.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.IType`1.GetTypedValue(Microsoft.ProgramSynthesis.Wrangling.ITypedValue)">
            <summary>
                If possible, get <paramref name="obj" /> as type <typeparamref name="T" /> according to this type.
            </summary>
            <param name="obj"><see cref="T:Microsoft.ProgramSynthesis.Wrangling.ITypedValue" /> to convert to <typeparamref name="T" />.</param>
            <returns>
                <paramref name="obj" /> converted to <typeparamref name="T" /> according to this or
                <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" />.
            </returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.ITypedProgram`2.OutputTypes">
            <summary>
                The possible types of outputs of this program.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Json.JPath">
            <summary>
                Represents a JSON path to retrieve a token from another token.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JPath.#ctor">
            <summary>
                Constructs an empty path (which returns the same node).
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JPath.#ctor(Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.JPathStep[])">
            <summary>
                Constructs a path from its corresponding steps.
            </summary>
            <param name="steps">The corresponding steps.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JPath.#ctor(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.JPathStep})">
            <summary>
                Constructs a path from its corresponding steps.
            </summary>
            <param name="steps">The corresponding steps.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JPath.#ctor(System.String[])">
            <summary>
                Constructs a path from its corresponding steps.
            </summary>
            <param name="steps">The corresponding steps.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JPath.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Constructs a path from its corresponding steps.
            </summary>
            <param name="steps">The corresponding steps.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.JPath.Steps">
            <summary>
                The steps in this path.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.JPath.Score">
            <summary>
                The score of this path.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JPath.Join(Microsoft.ProgramSynthesis.Wrangling.Json.JPath[])">
            <summary>
            Joins several paths into a path.
            </summary>
            <param name="paths">The list of paths that need to join together.</param>
            <returns>The joined path.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JPath.GetPath(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Linq.JToken)">
            <summary>
            Returns a path from <paramref name="src"/> node to <paramref name="dst"/> node.
            </summary>
            <param name="src">The source node.</param>
            <param name="dst">The destination node.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JPath.ParseFromXML(System.Xml.Linq.XElement)">
            <summary>
                Load a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JPath" /> that had been serialized to XML.
            </summary>
            <param name="pathElement">An XML-representation of a path.</param>
            <returns>The path deserialized from <paramref name="pathElement" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JPath.ParseFromHumanReadable(System.String)">
            <summary>
                Deserializes a string into a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JPath" />.
            </summary>
            <param name="path">A string representation of a path.</param>
            <returns>The deserialized <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JPath" /> of <paramref name="path" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JPath.Serialize">
            <summary>
                Serializes this path into a string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JPath.ToString">
            <summary>
                Returns a JPath string representation.
            </summary>
            <returns>
                A JPath string.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JPath.Equals(Microsoft.ProgramSynthesis.Wrangling.Json.JPath)">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JPath.Equals(System.Object)">
            <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JPath.GetHashCode">
            <summary>
                Serves as the default hash function.
            </summary>
            <returns>
                A hash code for the current object.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.AccessStep">
            <summary>
                The step to access a value of an object.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.AccessStep.#ctor(System.String)">
            <summary>
                Constructs this step from a key.
            </summary>
            <param name="key">The key.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.AccessStep.Key">
            <summary>
                The access key.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.AccessStep.Kind">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.JPathStepKind" /> of this step.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.AccessStep.Score">
            <summary>
                The ranking score of this step.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.AccessStep.Equals(Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.AccessStep)">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.AccessStep.Serialize">
            <summary>
                Serializes the step.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.AccessStep.Apply(Newtonsoft.Json.Linq.JToken)">
            <summary>
                Retrieves the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.AccessStep.Key" /> child of <paramref name="token" />.
            </summary>
            <param name="token">The token.</param>
            <returns>The <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.AccessStep.Key" /> child.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.AccessStep.ToString">
            <summary>
                Returns a string that represents the current object.
            </summary>
            <returns>
                A string that represents the current object.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.AccessStep.Equals(System.Object)">
            <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.AccessStep.GetHashCode">
            <summary>
                Serves as the default hash function.
            </summary>
            <returns>
                A hash code for the current object.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.CurrentStep">
            <summary>
            The step to return the same node. This is similar to "." in file system path.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.CurrentStep.Kind">
            <summary>
            The <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.JPathStepKind"/> of this step.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.CurrentStep.Score">
            <summary>
            The ranking score of this step.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.CurrentStep.Serialize">
            <summary>
                Serializes the step.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.CurrentStep.Apply(Newtonsoft.Json.Linq.JToken)">
            <summary>
            Returns the same node.
            </summary>
            <param name="token">The token.</param>
            <returns><paramref name="token"/>.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.CurrentStep.Equals(Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.CurrentStep)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.CurrentStep.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.CurrentStep.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
            true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.CurrentStep.GetHashCode">
            <summary>
            Serves as the default hash function.
            </summary>
            <returns>
            A hash code for the current object.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.IndexStep">
            <summary>
                The step to access an array element.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.IndexStep.#ctor(System.Int32)">
            <summary>
                Constructs this step from an integer.
            </summary>
            <param name="k">The index.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.IndexStep.K">
            <summary>
                The index.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.IndexStep.Kind">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.JPathStepKind" /> of this step.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.IndexStep.Score">
            <summary>
                The ranking score of this step.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.IndexStep.Equals(Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.IndexStep)">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.IndexStep.Serialize">
            <summary>
                Serializes the step.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.IndexStep.Apply(Newtonsoft.Json.Linq.JToken)">
            <summary>
                Retrieves the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.IndexStep.K" /> element of <paramref name="token" />.
                Returns an empty list if <paramref name="token" /> is not a <see cref="T:Newtonsoft.Json.Linq.JArray" />.
            </summary>
            <param name="token">The array.</param>
            <returns>The <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.IndexStep.K" /> element.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.IndexStep.ToString">
            <summary>
                Returns a string that represents the current object.
            </summary>
            <returns>
                A string that represents the current object.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.IndexStep.Equals(System.Object)">
            <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.IndexStep.GetHashCode">
            <summary>
                Serves as the default hash function.
            </summary>
            <returns>
                A hash code for the current object.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.JPathStep">
            <summary>
                Class for specifying a specific step in <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JPath" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.JPathStep.Kind">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.JPathStepKind" /> of this step.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.JPathStep.Score">
            <summary>
                The ranking score of this step.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.JPathStep.Apply(Newtonsoft.Json.Linq.JToken)">
            <summary>
                Applies this step to <paramref name="token" />.
            </summary>
            <param name="token">The starting token.</param>
            <returns>The set of destination tokens.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.JPathStep.Serialize">
            <summary>
                Serializes the step.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.JPathStep.From(System.String)">
            <summary>
                Creates a step from its string representation.
            </summary>
            <param name="step">The step string representation</param>
            <returns>The corresponding <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.JPathStep" />.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.JPathStepKind">
            <summary>
                The kind of <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.JPathStep" />.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.ParentStep">
            <summary>
                The step to access parent.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.ParentStep.Kind">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.JPathStepKind" /> of this step.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.ParentStep.Score">
            <summary>
                The ranking score of this step.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.ParentStep.Equals(Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.ParentStep)">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.ParentStep.Apply(Newtonsoft.Json.Linq.JToken)">
            <summary>
                Retrieves the parent of <paramref name="token" />.
            </summary>
            <param name="token">The token to retrieve parent.</param>
            <returns>The parent of <paramref name="token" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.ParentStep.Serialize">
            <summary>
                Serializes the step.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.ParentStep.ToString">
            <summary>
                Returns a string that represents the current object.
            </summary>
            <returns>
                A string that represents the current object.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.ParentStep.Equals(System.Object)">
            <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.ParentStep.GetHashCode">
            <summary>
                Serves as the default hash function.
            </summary>
            <returns>
                A hash code for the current object.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.PropertyKeyStep">
            <summary>
                The step to return the key of a property.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.PropertyKeyStep.Kind">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.JPathStepKind" /> of this step.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.PropertyKeyStep.Score">
            <summary>
                The ranking score of this step.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.PropertyKeyStep.Equals(Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.PropertyKeyStep)">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.PropertyKeyStep.Apply(Newtonsoft.Json.Linq.JToken)">
            <summary>
                Retrieves the key of the property.
            </summary>
            <param name="token">The token.</param>
            <returns>The key of <paramref name="token" />, null if <paramref name="token" /> is not a <see cref="T:Newtonsoft.Json.Linq.JProperty" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.PropertyKeyStep.Serialize">
            <summary>
                Serializes the step.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.PropertyKeyStep.ToString">
            <summary>
                Returns a string that represents the current object.
            </summary>
            <returns>
                A string that represents the current object.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.PropertyKeyStep.Equals(System.Object)">
            <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.PropertyKeyStep.GetHashCode">
            <summary>
                Serves as the default hash function.
            </summary>
            <returns>
                A hash code for the current object.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.PropertyValueStep">
            <summary>
                The step to return the key of a property.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.PropertyValueStep.Kind">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.JPathStepKind" /> of this step.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.PropertyValueStep.Score">
            <summary>
                The ranking score of this step.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.PropertyValueStep.Equals(Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.PropertyValueStep)">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.PropertyValueStep.Apply(Newtonsoft.Json.Linq.JToken)">
            <summary>
                Retrieves the value of the property.
            </summary>
            <param name="token">The token.</param>
            <returns>The value of <paramref name="token" />, null if <paramref name="token" /> is not a <see cref="T:Newtonsoft.Json.Linq.JProperty" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.PropertyValueStep.Serialize">
            <summary>
                Serializes the step.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.PropertyValueStep.ToString">
            <summary>
                Returns a string that represents the current object.
            </summary>
            <returns>
                A string that represents the current object.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.PropertyValueStep.Equals(System.Object)">
            <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.PropertyValueStep.GetHashCode">
            <summary>
                Serves as the default hash function.
            </summary>
            <returns>
                A hash code for the current object.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.SinglePropertyStep">
            <summary>
                The step to return the single value of a <see cref="T:Newtonsoft.Json.Linq.JObject" />
                This is not applicable to objects that have more than 1 child.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.SinglePropertyStep.Kind">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.JPathStepKind" /> of this step.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.SinglePropertyStep.Score">
            <summary>
                The ranking score of this step.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.SinglePropertyStep.Equals(Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.SinglePropertyStep)">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.SinglePropertyStep.Apply(Newtonsoft.Json.Linq.JToken)">
            <summary>
                Retrieves the single value of <paramref name="token" />.
                Returns an empty array if <paramref name="token" /> is not a <see cref="T:Newtonsoft.Json.Linq.JObject" /> or it does not has 1 child.
            </summary>
            <param name="token">The singleton object.</param>
            <returns>The single value of <paramref name="token" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.SinglePropertyStep.Serialize">
            <summary>
                Serializes the step.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.SinglePropertyStep.ToString">
            <summary>
                Returns a string that represents the current object.
            </summary>
            <returns>
                A string that represents the current object.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.SinglePropertyStep.Equals(System.Object)">
            <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.SinglePropertyStep.GetHashCode">
            <summary>
                Serves as the default hash function.
            </summary>
            <returns>
                A hash code for the current object.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.StarStep">
            <summary>
                The step to return the all properties of a <see cref="T:Newtonsoft.Json.Linq.JObject" />
                or all elements in a <see cref="T:Newtonsoft.Json.Linq.JArray" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.StarStep.Kind">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.JPathStepKind" /> of this step.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.StarStep.Score">
            <summary>
                The ranking score of this step.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.StarStep.Equals(Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.StarStep)">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.StarStep.Apply(Newtonsoft.Json.Linq.JToken)">
            <summary>
                Retrieves the all properties or elements of <paramref name="token" /> depending on whether it is
                <see cref="T:Newtonsoft.Json.Linq.JObject" /> or <see cref="T:Newtonsoft.Json.Linq.JArray" />.
            </summary>
            <param name="token">The token.</param>
            <returns>All properties or elements of <paramref name="token" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.StarStep.Serialize">
            <summary>
                Serializes the step.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.StarStep.ToString">
            <summary>
                Returns a string that represents the current object.
            </summary>
            <returns>
                A string that represents the current object.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.StarStep.Equals(System.Object)">
            <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JpathStep.StarStep.GetHashCode">
            <summary>
                Serves as the default hash function.
            </summary>
            <returns>
                A hash code for the current object.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Json.JsonErrors">
            <summary>
                The JSON errors
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion">
            <summary>
                Represents a JSON region in a document.
                A region is defined by <see cref="T:Newtonsoft.Json.Linq.JToken" /> in the document and a pair of starting and ending positions
                within the value of that token.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion.Document">
            <summary>
                The document this region belongs to.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion.Token">
            <summary>
                The <see cref="T:Newtonsoft.Json.Linq.JToken" /> of this region.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion.Start">
            <summary>
                The starting position of this region (within the value of <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion.Token" />).
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion.End">
            <summary>
                The ending position of this region (within the value of <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion.Token" />).
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion.Value">
            <summary>
                The string value of this region.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion.Create(Newtonsoft.Json.Linq.JToken)">
            <summary>
                Creates a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion" /> for <paramref name="token" />.
            </summary>
            <param name="token">The token associated with the <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion"/>.</param>
            <returns>The resulting <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion"/>.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion.Create(Newtonsoft.Json.Linq.JToken,System.UInt32,System.UInt32)">
            <summary>
                Creates a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion" /> within <paramref name="token" />.
                The region is defined by the pair of starting and ending positions.
            </summary>
            <param name="token">The token associated with the <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion"/>.</param>
            <param name="start">The starting position of the region within <paramref name="token"/>.</param>
            <param name="end">The ending position of the region within <paramref name="token"/>.</param>
            <returns>The resulting <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion"/>.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion.Equals(Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion)">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion.Equals(System.Object)">
            <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion.GetHashCode">
            <summary>
                Serves as the default hash function.
            </summary>
            <returns>
                A hash code for the current object.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion.Contains(Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion)">
            <summary>
                Checks if this region contains <paramref name="other" /> region.
            </summary>
            <param name="other">The region to look for in this region.</param>
            <returns>True if <paramref name="other" /> is a region in the same document contained inside or equal to this region.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion.IntersectNonEmpty(Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion)">
            <summary>
                Checks if this region intersects with <paramref name="other" /> region.
            </summary>
            <param name="other">The region needs to check for intersection.</param>
            <returns>True if they intersect, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion.IsBefore(Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion)">
            <summary>
                Checks if this region appears before <paramref name="other" /> region.
            </summary>
            <param name="other">The region to check.</param>
            <returns>True if this region appears first, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion.ClipBefore(Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion)">
            <summary>
                Clip this region to end before <paramref name="other" />.
            </summary>
            <param name="other">A region starting after this one.</param>
            <returns>A region that starts at the same position but ends before <paramref name="other" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion.CompareTo(Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion)">
            <summary>
                Compares the current instance with another object of the same type and returns an integer that indicates whether
                the current instance precedes, follows, or occurs in the same position in the sort order as the other object.
            </summary>
            <returns>
                A value that indicates the relative order of the objects being compared. The return value has these meanings: Value
                Meaning Less than zero This instance precedes <paramref name="other" /> in the sort order.  Zero This instance
                occurs in the same position in the sort order as <paramref name="other" />. Greater than zero This instance follows
                <paramref name="other" /> in the sort order.
            </returns>
            <param name="other">An object to compare with this instance. </param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Json.ParsedJson">
            <summary>
                The result of parsing a JSON document.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.ParsedJson.#ctor(System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion},System.String,System.String,Microsoft.ProgramSynthesis.Wrangling.Json.JsonErrors)">
            <summary>
                Construct a parse result.
            </summary>
            <param name="regions">The parsed <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion" />s.</param>
            <param name="startDelimiter">The extra delimiter at the start (if exists) for new-line delimited JSON.</param>
            <param name="endDelimiter">The extra delimiter at the end (if exists) for new-line delimited JSON.</param>
            <param name="errors">The errors in the JSON.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.ParsedJson.Regions">
            <summary>
                The parsed set of <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.ParsedJson.Errors">
            <summary>
                The errors found in this JSON.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.ParsedJson.IsDelimitedJson">
            <summary>
                Indicates if the JSON is (new line) delimited.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.ParsedJson.EndDelimiter">
            <summary>
                The extra delimiter at the end (if exists) for new-line delimited JSON.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Json.ParsedJson.StartDelimiter">
            <summary>
                The extra delimiter at the start (if exists) for new-line delimited JSON.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.Utils.SelectTokens(Newtonsoft.Json.Linq.JToken,Microsoft.ProgramSynthesis.Wrangling.Json.JPath)">
            <summary>
                Selects a list of tokens identified by <paramref name="path" /> starting from <paramref name="token" />.
            </summary>
            <param name="token">The source token.</param>
            <param name="path">The JSON path.</param>
            <returns>The list of destination tokens.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.Utils.SelectFirstToken(Newtonsoft.Json.Linq.JToken,Microsoft.ProgramSynthesis.Wrangling.Json.JPath)">
            <summary>
                Selects the first token in the list identified by <paramref name="path" /> starting from <paramref name="token" />.
            </summary>
            <param name="token">The source token.</param>
            <param name="path">The JSON path.</param>
            <returns>The first token in the destination tokens.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.Utils.SelectFirstProperty(Newtonsoft.Json.Linq.JToken,Microsoft.ProgramSynthesis.Wrangling.Json.JPath)">
            <summary>
                Selects the first property token in all tokens identified by a JSON path.
                Because the path always returns the value of the property node, this method returns
                the parent of the value, which is the property.
            </summary>
            <param name="token">The source token.</param>
            <param name="path">The JSON path.</param>
            <returns>The destination property token.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.Utils.GetAllPathsTo(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Linq.JToken)">
            <summary>
                Calculates all possible <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JPath" />s from <paramref name="src" /> to <paramref name="dest" />.
                <paramref name="dest" /> can be the descendant or ancestor of <paramref name="src" />.
                Note that in traditional JSON path, <paramref name="dest" /> can only be the descendant.
            </summary>
            <param name="src">The source token.</param>
            <param name="dest">The destination token.</param>
            <returns>The JSON path from <paramref name="src" /> to <paramref name="dest" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.Utils.DescendantsAndSelf(Newtonsoft.Json.Linq.JToken)">
            <summary>
                Returns the current <paramref name="token" /> and all of its descendants.
            </summary>
            <param name="token">The token to find descendants for.</param>
            <returns>The <paramref name="token" /> and its descendants.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.Utils.IsNullOrNullType(Newtonsoft.Json.Linq.JToken)">
            <summary>
                Checks if <paramref name="token" /> is null or of type <see cref="F:Newtonsoft.Json.Linq.JTokenType.Null" />.
            </summary>
            <param name="token">The token.</param>
            <returns>True if <paramref name="token" /> is null or of type <see cref="F:Newtonsoft.Json.Linq.JTokenType.Null" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.Utils.PathToDescendant(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Linq.JToken)">
            <summary>
                Returns all possible paths from <paramref name="src" /> to its descendant <paramref name="dest" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.Utils.Sample(Newtonsoft.Json.Linq.JToken,System.Int32,System.Int32)">
            <summary>
                Generates a sample for <paramref name="token" />.
                This method assumes that the JSON is well-structured (such as no missing fields).
                For <see cref="T:Newtonsoft.Json.Linq.JArray" />, this method selects the first <paramref name="arrayElementLimit" /> elements.
                For <see cref="T:Newtonsoft.Json.Linq.JObject" />, this method always preserves values that are <see cref="T:Newtonsoft.Json.Linq.JArray" /> or
                <see cref="T:Newtonsoft.Json.Linq.JObject" />.
                It only samples "leaf" values such as number or string (i.e., <see cref="T:Newtonsoft.Json.Linq.JValue" />.
                The maximum number of these values are specified in <paramref name="valueInObjectLimit" />.
            </summary>
            <param name="token">The token to be sampled.</param>
            <param name="arrayElementLimit">The maximum number of array elements in the sample.</param>
            <param name="valueInObjectLimit">The maximum number of "leaf" values in every object in the sample.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.Utils.TryParse(System.String,Microsoft.ProgramSynthesis.Wrangling.Json.ParsedJson@)">
            <summary>
                Tries parsing a (possibly truncated) JSON text into a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion" />.
                If the last element is a truncated object property or array element, this method ignores the element.
                However, if the element is a number, this method assumes that the number is not truncated and keeps the element.
            </summary>
            <param name="document">The JSON text.</param>
            <param name="parsedJson">
                When this method returns, contains the parsed JSON object, if the JSON is parsable; otherwise,
                null.
            </param>
            <returns>
                True if <paramref name="document" /> is parsable; otherwise, false.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.Utils.Parse(System.String)">
            <summary>
                Parses a (possibly truncated) JSON text into a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion" /> given the type of the JSON.
                If the last element is a truncated object property or array element, this method ignores the element.
                However, if the element is a number, this method assumes that the number is not truncated and keeps the element.
            </summary>
            <param name="document">The JSON text.</param>
            <returns>The parsed <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.Utils.RepairAndParseTruncatedJson(System.String)">
            <summary>
                Repairs and parses the truncated JSON text.
                If the last element is a truncated object property or array element, this method ignores the element.
                However, if the element is a number, this method assumes that the number is not truncated and keeps the element.
            </summary>
            <param name="document">The truncated JSON text.</param>
            <returns>The fixed and parsed <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.Utils.ParseImpl(System.String)">
            <summary>
                Parses a JSON text into a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion" />.
            </summary>
            <param name="document">The input JSON text.</param>
            <returns>The output <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Json.JsonRegion" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Json.Utils.TryParseDelimitedJson(System.String,Microsoft.ProgramSynthesis.Wrangling.Json.ParsedJson@)">
            <summary>
                Tries parsing a newline-delimited JSON text and detects its delimiter.
                Also tries to fix the last record if the file was truncated in the middle of the last line.
            </summary>
            <param name="document">The input JSON text.</param>
            <param name="parsedJson">
                When this method returns, contains the parsed JSON object, if the JSON is parsable; otherwise,
                null.
            </param>
            <returns>
                True if <paramref name="document" /> is parsable; otherwise, false.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Logging.ConsoleLogger">
            <summary>
                Implementation of <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Logging.ILogger" /> which turns every logging operation into a Console.Error.WriteLine
            </summary>    
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.Logging.ConsoleLogger.Instance">
            <summary>Singleton instance of <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Logging.ConsoleLogger" />.</summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Logging.ILogger">
            <summary>
                Interface used by program synthesis DSLs to provide telemetry information.  Clients may implement this
                interface and call <see cref="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.SetLogger(Microsoft.ProgramSynthesis.Wrangling.Logging.ILogger)" /> for a DSL to
                receive telemetry data.
            
                Implementations of this interface should consider augmenting messages with correlation information and/or
                filtering messages which contain user data in order to enforce customer preferences or privacy policies.
            
                NOTE: User data must be handled with utmost caution.  So these APIs carefully separate user data from
                data which does not contain any PII or other user data.  The PROSE team encourages implementers of this
                interface to preserve consumer data whenever possible (while maintaining privacy expectations of customers)
                since it can be very helpful to the long-term improvement of these APIs.  If necessary, user data may be
                ignored altogether.  It may be stored only if the customer agrees.  Or if customer agreements allow, it
                may be stored in a more secure/restricted access location to allow programmatic aggregation / analysis
                in a PII compliant manner.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Logging.ILogger.Error(System.String,System.String,System.String)">
            <summary>
                Log an error message.
            </summary>
            <param name="area">The code source of the message.</param>
            <param name="message">Details about the error guaranteed not to include any user data.</param>
            <param name="userData">If there is user data associated with the message, it will be included here.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Logging.ILogger.Warn(System.String,System.String,System.String)">
            <summary>
                Log a warning.
            </summary>
            <param name="area">The code source of the message.</param>
            <param name="message">Details about the error.</param>
            <param name="userData">If there is user data associated with the message, it will be included here.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Logging.ILogger.Info(System.String,System.String,System.String)">
            <summary>
                Log a message about standard operation.  (High-level tracing.)
            </summary>
            <param name="area">The code source of the message.</param>
            <param name="message">Details about the error.</param>
            <param name="userData">If there is user data associated with the message, it will be included here.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Logging.ILogger.Debug(System.String,System.String,System.String)">
            <summary>
                Log debug info.  (Verbose tracing.)
            </summary>
            <param name="area">The code source of the message.</param>
            <param name="message">Details about the error.</param>
            <param name="userData">If there is user data associated with the message, it will be included here.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Logging.ILogger.TrackException(System.Exception)">
            <summary>
                Log an unexpected exception.  The exception object should NEVER contain user data.
            </summary>
            <param name="exception">The exception object (including stack trace, etc.)</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Logging.ILogger.TrackEvent(System.String,System.Collections.Generic.IReadOnlyCollection{System.Collections.Generic.KeyValuePair{System.String,System.Double}},System.Collections.Generic.IReadOnlyCollection{System.Collections.Generic.KeyValuePair{System.String,System.String}},System.Collections.Generic.IReadOnlyCollection{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
                Log an event -- often with metrics.
            
                NOTE: PROSE DSLs should use values from LoggingConstants.cs to ensure that the event, metric and
                property names stay consistent over time.  New constants may be added as needed.
            </summary>
            <param name="eventName">
                The name of the event.  This should be kept constant over time so that reporting can aggregate based
                on the name.  <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Logging.LoggingEvent"/>
            </param>
            <param name="metrics">
                A collection of named metric values.  This might include things like the time to complete an operation
                in ms.  Metric names should be kept constant over time.  <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Logging.LoggingMetric"/>
            </param>
            <param name="properties">
                A collection of properties associated with the event.  This should NOT include any user data (no
                examples, no serialized programs), but it might include interesting characteristics of a program or
                the like.  Property names should be kept constant over time.  <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Logging.LoggingProperty"/>
            </param>
            <param name="userDataProperties">
                A collection of properties associated with the event that contain user data (examples, etc.).  Property
                names should be kept constant over time.  <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Logging.LoggingProperty"/>
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Logging.ILogger.Flush(System.Boolean)">
            <summary>
                Notifies the background thread to flush buffered events.
            </summary>
            <param name="wait">Whether to wait for the flush to complete or do it in background.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Logging.LoggerUtils">
            <summary>
                Logger helper methods.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Logging.LoggerUtils.IsPIISafeException(System.Exception)">
            <summary>
                Checks whether an exception is considered PII safe.
            </summary>
            <param name="ex">The exception to check.</param>
            <returns>Whether the exception is considered PII safe.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Logging.LoggingEvent">
            <summary>
                Used to specify event names with the TrackEvent method.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Logging.LoggingMetric">
            <summary>
                Used to specify metric names with the TrackEvent method.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Logging.LoggingProperty">
            <summary>
                Used to specify property names with the TrackEvent method.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Logging.LoggingValue">
            <summary>
                Used to specify property values for the TrackEvent method.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.Logging.LoggingValue.OmitString">
            <summary>
                Value for telemetry context field that we do not want to collect because it may contain PII.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Logging.MultiLogger">
            <summary>
                Class to combine multiple <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Logging.ILogger" /> instances into a single object.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Logging.MultiLogger.#ctor(Microsoft.ProgramSynthesis.Wrangling.Logging.ILogger[])">
            <summary>Create a logger that pushes all logging operations to a set of loggers.</summary>
            <param name="loggers">The set of loggers to be combined.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Logging.MultiLogger.Error(System.String,System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Logging.MultiLogger.Warn(System.String,System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Logging.MultiLogger.Info(System.String,System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Logging.MultiLogger.Debug(System.String,System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Logging.MultiLogger.TrackException(System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Logging.MultiLogger.TrackEvent(System.String,System.Collections.Generic.IReadOnlyCollection{System.Collections.Generic.KeyValuePair{System.String,System.Double}},System.Collections.Generic.IReadOnlyCollection{System.Collections.Generic.KeyValuePair{System.String,System.String}},System.Collections.Generic.IReadOnlyCollection{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Logging.MultiLogger.Flush(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Logging.NullLogger">
            <summary>
                Default implementation of <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Logging.ILogger" /> which turns every logging operation into a no-op.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.Logging.NullLogger.Instance">
            <summary>Singleton instance of <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Logging.NullLogger" />.</summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Logging.NullLogger.#ctor">
            <summary>Create a logger that turns every logging operation into a no-op.</summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.NamespaceDoc">
            <summary>
                Contains classes common to extraction tasks from any kind of input.
                Currently used by Extraction.Text and Extraction.Web, but generalizable
                to other scenerios. Extraction DSLs are parameterized by a subclass of
                <see cref="T:Microsoft.ProgramSynthesis.Utils.IRegion`1"/> which describes parts of the input that can be
                extracted.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4">
            <summary>
                Represents a collection of top-ranked programs and a
                set of randomly sampled programs. Produced as a result of
                <see cref="M:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.LearnTopK(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`1,`2}},System.Int32,System.Collections.Generic.IEnumerable{`1},System.Threading.CancellationToken)" />.
            </summary>
            <typeparam name="TProgram">The type of the programs contained in this set.</typeparam>
            <typeparam name="TInput">The type of the inputs to the programs.</typeparam>
            <typeparam name="TOutput">The type of the output produced by the programs.</typeparam>
            <typeparam name="TFeatureValue">The type of the feature values used to rank the programs.</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4.TopPrograms">
            <summary>
                The top-ranked programs, with respect to <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4.Feature" />, ordered in
                descending order of their scores.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4.RandomPrograms">
            <summary>
                The randomly sampled programs.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4.FeatureCalculationContext">
            <summary>
                The <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4.FeatureCalculationContext" /> used to rank the programs in <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4.TopPrograms" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4.Feature">
            <summary>
                The feature used to rank the programs in <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4.TopPrograms" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4.IsEmpty">
            <summary>
                Is this <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4" /> empty?
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4.Empty">
            <summary>
                The empty program collection.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0},Microsoft.ProgramSynthesis.Features.Feature{`3},Microsoft.ProgramSynthesis.Features.FeatureCalculationContext)">
            <summary>
                Constructor.
            </summary>
            <param name="topPrograms">See <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4.TopPrograms" />.</param>
            <param name="randomPrograms">See <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4.RandomPrograms" />.</param>
            <param name="feature">See <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4.Feature" />.</param>
            <param name="fcc">See <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4.FeatureCalculationContext" />.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4.GetFeatureValueForProgram(`0)">
            <summary>
                Returns the feature value for a program.
            </summary>
            <param name="program">The program.</param>
            <returns>The value of the feature for <paramref name="program" />, which was used to rank the program.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4.From(Microsoft.ProgramSynthesis.VersionSpace.PrunedProgramSet,System.Func{Microsoft.ProgramSynthesis.AST.ProgramNode,`0},Microsoft.ProgramSynthesis.Features.Feature{`3})">
            <summary>
                Constructs a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4" /> from a
                <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.PrunedProgramSet" />.
            </summary>
            <param name="prunedProgramSet">The pruned program set.</param>
            <param name="programFactory">
                A function that produces TProgram, given a  <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" />.
            </param>
            <param name="feature">The typed feature that was used to construct the <paramref name="prunedProgramSet" />.</param>
            <returns>
                A new <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4" /> that contains the programs in
                <paramref name="prunedProgramSet" />, wrapped in a TProgram.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3">
            <summary>
                The main class where all learning happens.
            </summary>
            <typeparam name="TProgram">The type of program.</typeparam>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.SupportsProgramSampling">
            <summary>
                Does this <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3" /> support random sampling of programs?
                If <c>false</c> then any requests to include random programs in the <see cref="M:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.LearnTopK(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`1,`2}},System.Int32,System.Collections.Generic.IEnumerable{`1},System.Threading.CancellationToken)" /> methods
                will be ignored.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.SupportsArbitraryFeatures">
            <summary>
                Does this <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3" /> support topK learning with arbitrary features?
                If <c>false</c> then top-K will always be performed with <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.ScoreFeature" />, any <see cref="T:Microsoft.ProgramSynthesis.Features.Feature`1" />
                typed parameters to the <see cref="M:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.LearnTopK(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`1,`2}},System.Int32,System.Collections.Generic.IEnumerable{`1},System.Threading.CancellationToken)" /> methods will be ignored.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.Learn(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`1,`2}},System.Collections.Generic.IEnumerable{`1},System.Threading.CancellationToken)">
            <summary>
                Learns top-ranked program that satisfies the given <paramref name="constraints" />.
                In the case of a tie, only one result will be returned.
                Returns <c>null</c> if no program can be learned.
                Use
                <see
                    cref="!:LearnTopK(IEnumerable&lt;Constraint&lt;TInput,TOutput&gt;&gt;,int,IEnumerable&lt;TInput&gt;,System.Nullable&lt;System.Threading.CancellationToken&gt;)" />
                with k=1 to get all of the programs tied for best.
                Programs will be ranked using <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.ScoreFeature" />.
            </summary>
            <param name="constraints">The constraints on the program to be learned.</param>
            <param name="additionalInputs">
                The set of additional references that do not have output examples, which helps learn
                programs.
            </param>
            <param name="cancel">
                The token to monitor for cancellation requests. The default value is
                <see cref="P:System.Threading.CancellationToken.None" />.
            </param>
            <returns>The top-ranked program.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.Learn``1(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`1,`2}},Microsoft.ProgramSynthesis.Features.Feature{``0},System.Collections.Generic.IEnumerable{`1},System.Threading.CancellationToken)">
            <summary>
                Learns top-ranked program that satisfies the given <paramref name="constraints" />.
                In the case of a tie, only one result will be returned.
                Returns <c>null</c> if no program can be learned.
                Use <see cref="M:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.LearnTopK(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`1,`2}},System.Int32,System.Collections.Generic.IEnumerable{`1},System.Threading.CancellationToken)" />
                with k=1 to get all of the programs tied for best.
            </summary>
            <param name="constraints">The constraints on the program to be learned.</param>
            <param name="feature">
                The <see cref="T:Microsoft.ProgramSynthesis.Features.IFeature" /> with respect to which programs will be ranked. If the
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.SupportsArbitraryFeatures" /> property of
                the <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3" /> returns <c>false</c>, then this parameter will be
                ignored and
                the top-K will always be computed with respect to <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.ScoreFeature" />.
            </param>
            <param name="additionalInputs">
                The set of additional references that do not have output examples, which helps learn
                programs.
            </param>
            <param name="cancel">
                The token to monitor for cancellation requests. The default value is
                <see cref="P:System.Threading.CancellationToken.None" />.
            </param>
            <returns>The top-ranked program.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.LearnTopK(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`1,`2}},System.Int32,System.Collections.Generic.IEnumerable{`1},System.Threading.CancellationToken)">
            <summary>
                Learns a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4" /> containing at least
                <paramref name="k" /> top-ranked programs that satisfy the given <paramref name="constraints" />, provided
                that there exist at least <paramref name="k" /> programs that satisfy the given constraints. The
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4" /> may contain
                fewer than <paramref name="k" /> programs if there are fewer than <paramref name="k" /> programs that satisfy the
                constraints.
                Returns all tied results in case of ties.
                Programs will be ranked using <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.ScoreFeature" />.
            </summary>
            <param name="constraints">The constraints on the programs to be learned.</param>
            <param name="k">The number of top programs returned.</param>
            <param name="additionalInputs">
                The set of additional references that do not have output examples, which helps learn and
                rank programs.
            </param>
            <param name="cancel">
                The token to monitor for cancellation requests. The default value is
                <see cref="P:System.Threading.CancellationToken.None" />.
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.LearnTopK(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`1,`2}},System.Int32,System.TimeSpan,System.Collections.Generic.IEnumerable{`1},System.Threading.CancellationToken)">
            <summary>
                Learns a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4" /> containing at least
                <paramref name="k" /> top-ranked programs that satisfy the given <paramref name="constraints" />, provided
                that there exist at least <paramref name="k" /> programs that satisfy the given constraints. The
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4" /> may contain
                fewer than <paramref name="k" /> programs if there are fewer than <paramref name="k" /> programs that satisfy the
                constraints.
                Returns all tied results in case of ties.
                Programs will be ranked using <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.ScoreFeature" />.
                The empty program collection is returned if the learn call exceeds the given <paramref name="timeout" />.
            </summary>
            <param name="constraints">The constraints on the programs to be learned.</param>
            <param name="k">The number of top programs returned.</param>
            <param name="timeout">The maximum timeout for the learn call.</param>
            <param name="additionalInputs">
                The set of additional references that do not have output examples, which helps learn and
                rank programs.
            </param>
            <param name="cancel">
                The token to monitor for cancellation requests. The default value is
                <see cref="P:System.Threading.CancellationToken.None" />.
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.LearnTopK(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`1,`2}},System.Int32,System.Nullable{System.Int32},Microsoft.ProgramSynthesis.Learning.ProgramSamplingStrategy,System.Collections.Generic.IEnumerable{`1},System.Threading.CancellationToken)">
            <summary>
                Learns a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4" /> containing at least
                <paramref name="k" /> top-ranked programs that satisfy the given <paramref name="constraints" />, provided
                that there exist at least <paramref name="k" /> programs that satisfy the given constraints. The
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4" /> may contain
                fewer than <paramref name="k" /> programs if there are fewer than <paramref name="k" /> programs that satisfy the
                constraints.
                Returns all tied results in case of ties.
                In addition, if the parameter
                <paramref name="numRandomProgramsToInclude" />
                is set, then the returned <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4" /> also contains
                <paramref name="numRandomProgramsToInclude" /> additional randomly sampled programs that satisfy the
                given examples. Note that randomly sampled programs will only be returned if the
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.SupportsProgramSampling" />
                property of the <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3" /> returns <c>true</c>. Otherwise, the
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3" />
                does not support random sampling and no randomly sampled programs will be returned.
                Programs will be ranked using <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.ScoreFeature" />.
            </summary>
            <param name="constraints">The constraints on the programs to be learned.</param>
            <param name="k">The number of top programs returned.</param>
            <param name="numRandomProgramsToInclude">
                The number of randomly sampled programs to include. If the
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.SupportsProgramSampling" /> property of the <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3" />
                return <c>false</c>, then this parameter will be ignored, and no random programs will be returned.
            </param>
            <param name="samplingStrategy">
                The <see cref="T:Microsoft.ProgramSynthesis.Learning.ProgramSamplingStrategy" /> to use while sampling programs. Only
                applicable if <paramref name="numRandomProgramsToInclude" /> is non-null and positive, and if the
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.SupportsProgramSampling" /> property of the <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3" />
                returns <c>true</c>.
            </param>
            <param name="additionalInputs">
                The set of additional references that do not have output examples, which helps learn and
                rank programs.
            </param>
            <param name="cancel">
                The token to monitor for cancellation requests. The default value is
                <see cref="P:System.Threading.CancellationToken.None" />.
            </param>
            <returns>
                A <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4" /> that contains the top
                <paramref name="k" /> ranked programs. If <paramref name="numRandomProgramsToInclude" /> is non-null, then the
                returned <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4" /> will include
                <paramref name="numRandomProgramsToInclude" /> randomly sampled programs as well.
                programs (if requested) as described in the summary.
            </returns>
            <remarks>
                The number of randomly sampled programs returned can be less than the specified
                <paramref name="numRandomProgramsToInclude" />, or even zero. Only a best-effort guarantee is made on the number of
                randomly sampled programs returned.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.LearnTopK``1(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`1,`2}},Microsoft.ProgramSynthesis.Features.Feature{``0},System.Int32,System.Nullable{System.Int32},Microsoft.ProgramSynthesis.Learning.ProgramSamplingStrategy,System.Collections.Generic.IEnumerable{`1},System.Threading.CancellationToken)">
            <summary>
                Learns a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4" /> containing at least
                <paramref name="k" /> top-ranked programs that satisfy the given <paramref name="constraints" />, provided
                that there exist at least <paramref name="k" /> programs that satisfy the given constraints. The
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4" /> may contain
                fewer than <paramref name="k" /> programs if there are fewer than <paramref name="k" /> programs that satisfy the
                constraints.
                Returns all tied results in case of ties. In addition, if the parameter
                <paramref name="numRandomProgramsToInclude" />
                is set, then the returned <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4" /> also contains
                <paramref name="numRandomProgramsToInclude" /> additional randomly sampled programs that satisfy the
                given examples. Note that randomly sampled programs will only be returned if the
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.SupportsProgramSampling" />
                property of the <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3" /> returns <c>true</c>. Otherwise, the
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3" />
                does not support random sampling and no randomly sampled programs will be returned.
            </summary>
            <param name="constraints">The constraints on the programs to be learned.</param>
            <param name="feature">
                The <see cref="T:Microsoft.ProgramSynthesis.Features.IFeature" /> with respect to which programs will be ranked. If the
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.SupportsArbitraryFeatures" /> property of
                the <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3" /> returns <c>false</c>, then this parameter will be
                ignored and
                the top-K will always be computed with respect to <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.ScoreFeature" />.
            </param>
            <param name="k">The number of top programs returned.</param>
            <param name="numRandomProgramsToInclude">
                The number of randomly sampled programs to include. If the
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.SupportsProgramSampling" /> property of the <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3" />
                return <c>false</c>, then this parameter will be ignored, and no random programs will be returned.
            </param>
            <param name="samplingStrategy">
                The <see cref="T:Microsoft.ProgramSynthesis.Learning.ProgramSamplingStrategy" /> to use while sampling programs. Only
                applicable if <paramref name="numRandomProgramsToInclude" /> is non-null and positive, and if the
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.SupportsProgramSampling" /> property of the <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3" />
                returns <c>true</c>.
            </param>
            <param name="additionalInputs">
                The set of additional references that do not have output examples, which helps learn and
                rank programs.
            </param>
            <param name="cancel">
                The token to monitor for cancellation requests. The default value is
                <see cref="P:System.Threading.CancellationToken.None" />.
            </param>
            <returns>
                A <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4" /> that contains the top
                <paramref name="k" /> ranked programs. If <paramref name="numRandomProgramsToInclude" /> is non-null, then the
                returned <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramCollection`4" /> will include
                <paramref name="numRandomProgramsToInclude" /> randomly sampled programs as well.
                programs (if requested) as described in the summary.
            </returns>
            <remarks>
                The number of randomly sampled programs returned can be less than the specified
                <paramref name="numRandomProgramsToInclude" />, or even zero. Only a best-effort guarantee is made on the number of
                randomly sampled programs returned.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.LearnAll(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`1,`2}},System.Collections.Generic.IEnumerable{`1},System.Threading.CancellationToken)">
            <summary>
                Learns all programs that satisfy the given <paramref name="constraints" />.
            </summary>
            <param name="constraints">The constraints on the programs to be learned.</param>
            <param name="additionalInputs">
                The set of additional references that do not have output examples, which helps learn
                programs.
            </param>
            <param name="cancel">
                The token to monitor for cancellation requests. The default value is
                <see cref="P:System.Threading.CancellationToken.None" />.
            </param>
            <returns>The set of all programs that satisfy the given <paramref name="constraints" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.GetFeatureOptionsFor(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`1,`2}},System.Collections.Generic.IEnumerable{`1})">
            <summary>
                Compute the options to be passed down to the feature calculators for the given set of constraints and additional
                inputs.
                The default implementation returns <c>null</c>.
            </summary>
            <param name="constraints">The constraints.</param>
            <param name="additionalInputs">The additional inputs.</param>
            <returns>An <see cref="T:Microsoft.ProgramSynthesis.Features.IFeatureOptions" /> object that can be used by feature calculators.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.ScoreFeature">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.Features.FeatureInfo" /> used for ranking the top-k programs in <see cref="M:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.LearnTopK(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`1,`2}},System.Int32,System.Collections.Generic.IEnumerable{`1},System.Threading.CancellationToken)" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.SpecSerializationContext">
            <summary>
                Returns a <see cref="P:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.SpecSerializationContext"/> that is applicable for this DSL.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3.SpecsGeneratedFromLastLearn">
            <summary>
                If supported by implementors, then returns a collection of <see cref="T:Microsoft.ProgramSynthesis.Specifications.Spec"/> objects that
                were generated during the last call to any of the learn methods.
                Note that this only provides a best-effort guarantee about the <see cref="T:Microsoft.ProgramSynthesis.Specifications.Spec"/> objects
                that are returned. Due to caching in the framework, some <see cref="T:Microsoft.ProgramSynthesis.Specifications.Spec"/> objects might
                not be preserved. Further, if the implementing <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3"/>
                does not support retrieving <see cref="T:Microsoft.ProgramSynthesis.Specifications.Spec"/> objects, then this property might have a <c>null</c>
                value.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.IProgramLoader`3.Load(System.String,Microsoft.ProgramSynthesis.AST.ASTSerializationFormat,Microsoft.ProgramSynthesis.AST.DeserializationContext)">
            <summary>
                Loads a <typeparamref name="TProgram" /> that has been serialized to
                <paramref name="serializedProgram" />.
            </summary>
            <param name="serializedProgram">
                The serialized program generated by
                <see cref="M:Microsoft.ProgramSynthesis.Program`2.Serialize(Microsoft.ProgramSynthesis.AST.ASTSerializationFormat)" />.
            </param>
            <param name="serializationFormat">The serialization format of <paramref name="serializedProgram" />.</param>
            <param name="context">A context to pass through to all deserialization methods.</param>
            <returns>A <typeparamref name="TProgram" /> deserialized from <paramref name="serializedProgram" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.IProgramLoader`3.Load(System.String,Microsoft.ProgramSynthesis.AST.ASTSerializationFormat,Microsoft.ProgramSynthesis.AST.DeserializationContext,Microsoft.ProgramSynthesis.AST.ProgramNodeParser)">
            <summary>
                Loads a <typeparamref name="TProgram" /> that has been serialized to
                <paramref name="serializedProgram" />.
            </summary>
            <param name="serializedProgram">
                The serialized program generated by
                <see cref="M:Microsoft.ProgramSynthesis.Program`2.Serialize(Microsoft.ProgramSynthesis.AST.ASTSerializationFormat)" />.
            </param>
            <param name="serializationFormat">The serialization format of <paramref name="serializedProgram" />.</param>
            <param name="context">A context to pass through to all deserialization methods.</param>
            <param name="programNodeParser">A custom parser that produces ProgramNodes from their serialized formats.</param>
            <returns>A <typeparamref name="TProgram" /> deserialized from <paramref name="serializedProgram" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.IProgramLoader`3.Create(Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Creates a <typeparamref name="TProgram" /> for a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" />. <paramref name="program" /> must be a
                valid program for a <typeparamref name="TProgram" />.
            </summary>
            <param name="program">The code of the program.</param>
            <returns>A strongly-typed <typeparamref name="TProgram" /> object wrapping <paramref name="program" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SimpleSymbolProgramLoader`3.Load(System.String,Microsoft.ProgramSynthesis.AST.ASTSerializationFormat,Microsoft.ProgramSynthesis.AST.DeserializationContext)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SimpleSymbolProgramLoader`3.Load(System.String,Microsoft.ProgramSynthesis.AST.ASTSerializationFormat,Microsoft.ProgramSynthesis.AST.DeserializationContext,Microsoft.ProgramSynthesis.AST.ProgramNodeParser)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SimpleSymbolProgramLoader`3.Create(Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.ProgramVersion00Converter">
            <summary>
            Converts pre-release region programs to newer version.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.RegionExtractionProgram`2.ExtractionKind">
            <summary>
                Represents the extraction kind of this program.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.RegionExtractionProgram`2.ReferenceKind">
            <summary>
                Specifies how this program relates to its referenced field.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.RegionExtractionProgram`2.Serialize(Microsoft.ProgramSynthesis.AST.ASTSerializationSettings)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.SchemaLearner`5">
            <summary>
            The class to learn a sequence of schema programs.
            </summary>
            <typeparam name="TSchemaProgram">The type of output schema.</typeparam>
            <typeparam name="TSequenceProgram">The type of sequence extraction programs.</typeparam>
            <typeparam name="TRegionProgram">The type of region extraction programs.</typeparam>
            <typeparam name="TRegion">The type of the region used.</typeparam>
            <typeparam name="TSelector">The type of the selector.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaLearner`5.Select(`4,`3)">
            <summary>
            Creates a region from the input and a selector.
            </summary>
            <param name="input"></param>
            <param name="selector"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaLearner`5.StringToInput(System.String)">
            <summary>
            Creates a region from a string.
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaLearner`5.Wrap(Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaGrammar{`1,`2,`4})">
            <summary>
            Wraps a <see cref="!:SchemaGrammar&lt;TExtractionProgram,TRegion&gt;"/> in a <see cref="!:SchemaProgram&lt;TExtractionProgram,TSelector,TRegion&gt;"/>.
            </summary>
            <param name="grammar">The schema grammar being wrapped.</param>
            <returns>A <typeparamref name="TSchemaProgram"/> referencing <paramref name="grammar"/>.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaLearner`5.GetLearner">
            <summary>
            Gets the <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ExtractionLearner`3"/> used to learn individual programs.
            </summary>
            <returns>The learner for programs that make up the learned schema programs.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaLearner`5.LearnSchema(System.String,System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.DocumentSpecInterface},System.Int32,System.Boolean,Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElementInterface[])">
            <summary>
            Learns schema program from multiple examples.
            </summary>
            <param name="schema">Schema in XML format.</param>
            <param name="specs">A list of specifications, each contains an input document and dictionaries with positive
                and negative examples for fields</param>
            <param name="k">The number of output programs.</param>
            <param name="learnAll">Specify whether we want to learn all programs.</param>
            <param name="converters">The converter.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.SchemaProgramLearnerExtensions">
            <summary>
            The extension class for schema learner.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaProgramLearnerExtensions.LearnSchema``5(Microsoft.ProgramSynthesis.Wrangling.SchemaLearner{``0,``1,``2,``3,``4},System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IEnumerable{``3}},System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IEnumerable{``3}},System.Int32,System.Boolean)">
            <summary>
            Learns a schema program from a set of all examples of every field.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaProgramLearnerExtensions.LearnSchemaExt``5(Microsoft.ProgramSynthesis.Wrangling.SchemaLearner{``0,``1,``2,``3,``4},System.String,System.Collections.Generic.IEnumerable{System.Tuple{``4,System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IEnumerable{``3}},System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IEnumerable{``3}}}},System.Int32,System.Boolean,Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElementInterface[])">
            <summary>
            Learns a sequence of schema programs from multiple examples.
            </summary>
            <param name="learner">The custom learner.</param>
            <param name="schema">Schema in XML format.</param>
            <param name="specs">A list of specifications, each containing an input document and dictionaries with positive
            and negative examples for fields.</param>
            <param name="k">Number of programs to learn.</param>
            <param name="learnAll">If true, the program set will be generated.</param>
            <param name="converters">An array of converters.</param>
            <returns>A sequence of schema programs.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaProgramLearnerExtensions.LearnSchemaExt``5(Microsoft.ProgramSynthesis.Wrangling.SchemaLearner{``0,``1,``2,``3,``4},System.String,System.Collections.Generic.IEnumerable{System.Tuple{``4,System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IEnumerable{``4}},System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IEnumerable{``4}}}},System.Int32,System.Boolean,Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElementInterface[])">
            <summary>
            Learns a sequence of schema programs from one input file and positive/negative examples.
            </summary>
            <param name="learner">Custom learner provided.</param>
            <param name="schema">Schema in XML format.</param>
            <param name="specs">A list of specifications, each containing an input document and dictionaries with positive
            and negative examples for fields.</param>
            <param name="k">Number of programs to learn</param>
            <param name="learnAll">If true, the program set will be generated.</param>
            <param name="converters">An array of converters.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaProgramLearnerExtensions.LearnSchemaExt``5(Microsoft.ProgramSynthesis.Wrangling.SchemaLearner{``0,``1,``2,``3,``4},System.String,``4,System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IEnumerable{``4}},System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IEnumerable{``4}},System.Int32,System.Boolean,Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElementInterface[])">
            <summary>
            Learns a sequence of schema programs from the examples.
            </summary>
            <typeparam name="TSchemaProgram">The type of output schema.</typeparam>
            <typeparam name="TSequenceProgram">The type of sequence extraction programs.</typeparam>
            <typeparam name="TRegionProgram">The type of region extraction programs.</typeparam>
            <typeparam name="TRegion">The type of the region used.</typeparam>
            <typeparam name="TSelector">The type of the selector.</typeparam>
            <param name="learner"></param>
            <param name="schema"></param>
            <param name="doc"></param>
            <param name="positiveExamples"></param>
            <param name="negativeExamples"></param>
            <param name="k">Number of programs to learn</param>
            <param name="learnAll">If true, the program set will be generated.</param>
            <param name="converters">An array of converters</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.BotSchemaElement`3">
            <summary>
            This class is the highest element in the schema, representing the entire file.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElementInterface">
            <summary>
            A generic converter interface exposing the name for retrieving it.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElementInterface.ConverterName">
            <summary>
            The name of this converter
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElementInterface.#ctor(System.String)">
            <summary>
            Protected constructor.
            </summary>
            <param name="converterName"></param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElementFactoryGeneric2`3">
            <summary>
            Generic ConvertSchemaElement factory exposing only the creation methods used in different parse methods (grammar and whole program).
            It does not refer to the child regions.
            </summary>
            <typeparam name="TSequenceProgramParent">The type of sequence extraction programs for the parent (source type of the conversion).</typeparam>
            <typeparam name="TRegionProgramParent">The type of region extraction programs for the parent (source type of the conversion).</typeparam>
            <typeparam name="TRegionParent">The type of regions being converted.</typeparam>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElementFactory`6">
            <summary>
            Class to extend to create conversion rules between regions and extraction programs.
            It can eventually convert the same region to itself, e.g. for removing clutter in input.
            </summary>
            <typeparam name="TSequenceProgramParent">The type of sequence extraction programs for the parent (source type of the conversion).</typeparam>
            <typeparam name="TRegionProgramParent">The type of region extraction programs for the parent (source type of the conversion).</typeparam>
            <typeparam name="TRegionParent">The type of regions being converted.</typeparam>
            <typeparam name="TSequenceProgramChild">The type of sequence extraction programs for the child (target type of the conversion).</typeparam>
            <typeparam name="TRegionProgramChild">The type of region extraction programs for the child (target type of the conversion).</typeparam>
            <typeparam name="TRegionChild">The type of regions being converted to.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElementFactory`6.ConvertToChildRegion(`2)">
            <summary>
            Method to convert the parent region to the child region.
            Many converters can convert the same region to another one.
            </summary>
            <param name="regionParent"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElementFactory`6.GetChildLearner">
            <summary>
            Returns the child extraction learner.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElementFactory`6.CreateInternal(System.String,Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement{`0,`1,`2},System.Boolean,Microsoft.ProgramSynthesis.Wrangling.ExtractionLearner{`0,`1,`2})">
            <summary>
            Private constructor used in Create and CreateAndParseChildInternal
            </summary>
            <param name="name"></param>
            <param name="parent"></param>
            <param name="nullable"></param>
            <param name="learner"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElementFactory`6.ParseChid(System.Xml.Linq.XElement,Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElementInterface[],Microsoft.ProgramSynthesis.AST.ASTSerializationFormat,Microsoft.ProgramSynthesis.AST.DeserializationContext,System.Func{System.Xml.Linq.XElement,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet})">
            <summary>
            Parses a child, calling the SchemaElement.Parse method.
            </summary>
            <param name="element">The element in xml</param>
            <param name="converters">The list of converters</param>
            <param name="formatPrograms">The way programs are formatted</param>
            <param name="getProgramSet">A way to retrieve the program set from the xml element, if any</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElementFactory`6.CreateAndParseChild(System.String,Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement{`0,`1,`2},System.Boolean,Microsoft.ProgramSynthesis.Wrangling.ExtractionLearner{`0,`1,`2},System.Xml.Linq.XElement,Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElementInterface[],Microsoft.ProgramSynthesis.AST.ASTSerializationFormat,Microsoft.ProgramSynthesis.AST.DeserializationContext)">
            <summary>
            Creates a ConvertSchemaElement and parse its provided child with its program and children in xml format.
            </summary>
            <param name="name">Name</param>
            <param name="parent">The parent of the returned element</param>
            <param name="nullable">If this element is nullable</param>
            <param name="learner">The learner of the Parent's region and Program Extraction</param>
            <param name="child">The child in xml</param>
            <param name="converters">The list of available converters</param>
            <param name="formatPrograms">The way the programs are serialized (xml or HumanReadable)</param>
            <returns>The ConvertSchemaElement</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElementFactory`6.Create(System.String,Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement{`0,`1,`2},System.Boolean,Microsoft.ProgramSynthesis.Wrangling.ExtractionLearner{`0,`1,`2})">
            <summary>
            Creates a ConvertSchemaElement for a top-down creation.
            </summary>
            <param name="name">Name</param>
            <param name="parent">The parent of the returned element</param>
            <param name="nullable">If this element is nullable</param>
            <param name="learner">The learner of the Parent's region and Program Extraction</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElementFactory`6.CreateAndParseChildGrammar(System.String,System.Xml.Linq.XElement,System.Boolean,Microsoft.ProgramSynthesis.Wrangling.ExtractionLearner{`0,`1,`2},Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElementInterface[])">
            <summary>
            Creates and element and parses its child (not programs) using the SchemaGrammar.Parse method.
            </summary>
            <param name="name">The name of the convert schema element. Can be different from the name of the converter</param>
            <param name="childMemberXml">The child in xml format</param>
            <param name="nullable">If this element is nullable</param>
            <param name="learner">The learner of the parent of the returned ConvertSchemaElement</param>
            <param name="converters">The list of converters</param>
            <returns>The ConvertSchemaElement</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElement`6">
            <summary>
            Allows one schema element of type Child be part of a schema element of type Parent
            </summary>
            <typeparam name="TSequenceProgramParent">The type of sequence extraction programs for the parent (source type of the conversion).</typeparam>
            <typeparam name="TRegionProgramParent">The type of region extraction programs for the parent (source type of the conversion).</typeparam>
            <typeparam name="TRegionParent">The type of regions being converted.</typeparam>
            <typeparam name="TSequenceProgramChild">The type of sequence extraction programs for the child (target type of the conversion).</typeparam>
            <typeparam name="TRegionProgramChild">The type of region extraction programs for the child (target type of the conversion).</typeparam>
            <typeparam name="TRegionChild">The type of regions being converted to.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElement`6.#ctor(Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElementFactory{`0,`1,`2,`3,`4,`5},System.String,System.Boolean,Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement{`3,`4,`5},Microsoft.ProgramSynthesis.Wrangling.ExtractionLearner{`0,`1,`2})">
            <summary>
            Bottom-up constructor of ConvertSchemaElement.
            Used to learn programs from examples.
            </summary>
            <param name="converter">The converter</param>
            <param name="name">The name of this ConvertSchemaElement. Can be different from the converter's name</param>
            <param name="childElement">The child element already constructed</param>
            <param name="nullable">If this element is nullable</param>
            <param name="learner">The learner.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElement`6.#ctor(Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElementFactory{`0,`1,`2,`3,`4,`5},System.String,Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement{`0,`1,`2},System.Boolean,Microsoft.ProgramSynthesis.Wrangling.ExtractionLearner{`0,`1,`2})">
            <summary>
            Top-down constructor of StructSchemaElement
            Used to parse programs.
            </summary>
            <param name="converter"></param>
            <param name="name"></param>
            <param name="parent"></param>
            <param name="nullable"></param>
            <param name="learner"></param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.FieldSchemaElement`3.#ctor(System.String,Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement{`0,`1,`2},System.Boolean,Microsoft.ProgramSynthesis.Wrangling.ExtractionLearner{`0,`1,`2})">
            <summary>
            Top-down constructor of StructSchemaElement
            Used to parse programs.
            </summary>
            <param name="name"></param>
            <param name="parent"></param>
            <param name="nullable"></param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.NamespaceDoc">
            <summary>
                Support for loading a schema from a string using
                <see cref="!:SchemaGrammar&lt;TExtractionProgram,TRegion&gt;" />.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.Extensions.NamespaceDoc">
            <summary>
                Helpers for <see cref="!:SchemaElement&lt;TExtractionProgram,TRegion&gt;" />.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement`3">
            <summary>
                A tree node in a schema description.
            </summary>
            <typeparam name="TSequenceProgram">
                The type of <see cref="T:Microsoft.ProgramSynthesis.Wrangling.SequenceExtractionProgram`2" /> this schema
                works on.
            </typeparam>
            <typeparam name="TRegionProgram">
                The type of <see cref="T:Microsoft.ProgramSynthesis.Wrangling.RegionExtractionProgram`2" /> this schema works
                on.
            </typeparam>
            <typeparam name="TRegion">The type of <see cref="T:Microsoft.ProgramSynthesis.Utils.IRegion`1" /> this schema works on.</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement`3.ExecutionCache">
            <summary>
                Store the execution cache of the kth program in Programs under a string
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement`3.#ctor(System.String,Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement{`0,`1,`2},System.Boolean,Microsoft.ProgramSynthesis.Wrangling.ExtractionLearner{`0,`1,`2})">
            <summary>
                Top-down constructor of SchemaElement
                Used to parse programs.
            </summary>
            <param name="name"></param>
            <param name="parent"></param>
            <param name="nullable"></param>
            <param name="learner"></param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement`3.#ctor">
            <summary>
                Internal use only.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement`3.ReferencedElement">
            <summary>
                The node that serves as a boundary.
                This node is not necessarily the Parent.
                It can be any ancestor (including \bot).
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement`3.ExtractionKind">
            <summary>
                If the program extracting this node is a sequence or a region.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement`3.Programs">
            <summary>
                The top-ranked field extraction programs for this node.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement`3.AllPrograms">
            <summary>
                All field extraction programs for this node.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement`3.AddChild(Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement{`0,`1,`2})">
            <summary>
                Sibling method to top-down build this SchemaElement
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement`3.AcceptVisitor``1(Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaVisitor{``0,`0,`1,`2})">
            <summary>
                Returns the value computed by the hierarchical application of the <paramref name="visitor" /> instance.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement`3.Parse(System.Xml.Linq.XElement,Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement{`0,`1,`2},Microsoft.ProgramSynthesis.Wrangling.ExtractionLearner{`0,`1,`2},Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElementInterface[],Microsoft.ProgramSynthesis.AST.ASTSerializationFormat,Microsoft.ProgramSynthesis.AST.DeserializationContext,System.Func{System.Xml.Linq.XElement,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet})">
            <summary>
                Parses an XML element and returns a SchemaElement.
            </summary>
            <param name="element">The code to parse as XElement</param>
            <param name="parent"></param>
            <param name="learner"></param>
            <param name="converters"></param>
            <param name="formatPrograms">If the programs are formatted in XML or in human-readable format.</param>
            <param name="context">A context to pass through to all deserialization methods.</param>
            <param name="getProgramSet"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement`3.Parse(System.Xml.Linq.XElement,Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement{`0,`1,`2},Microsoft.ProgramSynthesis.Wrangling.ExtractionLearner{`0,`1,`2},Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElementInterface[],Microsoft.ProgramSynthesis.AST.ASTSerializationFormat,Microsoft.ProgramSynthesis.AST.ProgramNodeParser,Microsoft.ProgramSynthesis.AST.DeserializationContext,System.Func{System.Xml.Linq.XElement,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet})">
            <summary>
                Parses an XML element and returns a SchemaElement.
            </summary>
            <param name="element">The code to parse as XElement</param>
            <param name="parent"></param>
            <param name="learner"></param>
            <param name="converters"></param>
            <param name="formatPrograms">If the programs are formatted in XML or in human-readable format.</param>
            <param name="programNodeParser"></param>
            <param name="context">A context to pass through to all deserialization methods.</param>
            <param name="getProgramSet"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement`3.Parse(System.String,Microsoft.ProgramSynthesis.Wrangling.ExtractionLearner{`0,`1,`2},Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElementInterface[],Microsoft.ProgramSynthesis.AST.ASTSerializationFormat,Microsoft.ProgramSynthesis.AST.DeserializationContext,System.Func{System.Xml.Linq.XElement,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet})">
            <summary>
                Parses an xml element in a string and returns the corresponding SchemaElement.
            </summary>
            <param name="code">The code to parse. The schema is in XML, but the ProgramNodes are formatted using formatPrograms.</param>
            <param name="learner">The learned</param>
            <param name="converters"></param>
            <param name="formatPrograms">If the programs are formatted in XML or in human-readable format.</param>
            <param name="context">A context to pass through to all deserialization methods.</param>
            <param name="getProgramSet">A function to retrieve the program set from the XElement after parsing.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement`3.Parse(System.String,Microsoft.ProgramSynthesis.Wrangling.ExtractionLearner{`0,`1,`2},Microsoft.ProgramSynthesis.Wrangling.SchemaParser.ConvertSchemaElementInterface[],Microsoft.ProgramSynthesis.AST.ASTSerializationFormat,Microsoft.ProgramSynthesis.AST.ProgramNodeParser,Microsoft.ProgramSynthesis.AST.DeserializationContext,System.Func{System.Xml.Linq.XElement,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet})">
            <summary>
                Parses an xml element in a string and returns the corresponding SchemaElement.
            </summary>
            <param name="code">The code to parse. The schema is in XML, but the ProgramNodes are formatted using formatPrograms.</param>
            <param name="learner">The learned</param>
            <param name="converters"></param>
            <param name="formatPrograms">If the programs are formatted in XML or in human-readable format.</param>
            <param name="programNodeParser">Custom parser for serialized ProgramNodes.</param>
            <param name="context">A context to pass through to all deserialization methods.</param>
            <param name="getProgramSet">A function to retrieve the program set from the XElement after parsing.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement`3.ComputeReferencedElement">
            <summary>
                Computes the references node and returns it. Computes whether this element will run for a SequenceTreeElement or
                just a field/struct.
            </summary>
            <returns>Returns true if this node is a sequence, false otherwise</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement`3.RunTree(`2)">
            <summary>
                Build the execution tree for this element and its children.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement`3.TopLevelRunOfReferencedElement(`2)">
            <summary>
                Returns the top-level run of the referenced element.
            </summary>
            <param name="str">The whole string on which to run the parent.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement`3.TopLevelRun(`2)">
            <summary>
                Returns the absolute positions in the string of this program when all ancestor programs execute.
            </summary>
            <param name="str">The whole string</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement`3.TopLevelRunPlusParent(`2)">
            Returns the top level run with the dependency to the parent.
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement`3.Run(`2,System.Int32)">
            <summary>
                Execute the kth program of this element on the region <paramref name="s" />.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElementProgram`3">
            <summary>
                This class represents a specific program of all learned programs of a
                <see cref="!:SchemaElement&lt;TExtractionProgram,TRegion&gt;" />.
                <see cref="!:SchemaElement&lt;TExtractionProgram,TRegion&gt;.Programs" /> is the list of all programs; this refers to a
                specific program in that list.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElementExtensions.ForEach``3(Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement{``0,``1,``2},System.Action{Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement{``0,``1,``2}})">
            <summary>
            Performs an operation on each element of the tree.
            </summary>
            <param name="callback"></param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElementExtensions.ForEachWhile``3(Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement{``0,``1,``2},System.Func{Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement{``0,``1,``2},System.Boolean})">
            <summary>
            Performs an operation on each element of the tree while the function returns true.
            Returns true if the operation was successful on the last element.
            </summary>
            <param name="callback"></param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaGrammar`3">
            <summary>
            The class that represents the schema tree. Essentially a wrapper around a <see cref="!:SchemaElement&lt;TExtractionProgram,TRegion&gt;" />.
            Includes parsing functions to retrieve a schema from a string.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaGrammar`3.Root">
            <summary>
            The root element of this schema.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaGrammar`3.#ctor(Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement{`0,`1,`2})">
            <summary>
                Constructs a <see cref="!:SchemaGrammar&lt;TExtractionProgram,TRegion&gt;" /> rooted at <paramref name="e" />.
            </summary>
            <param name="e">The root element of the schema.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaGrammar`3.FindElement(System.String)">
            <summary>
            Return the node in the schema whose id is <paramref name="e"/>
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SequenceSchemaElement`3.#ctor(Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement{`0,`1,`2},System.String,System.Boolean,Microsoft.ProgramSynthesis.Wrangling.ExtractionLearner{`0,`1,`2})">
            <summary>
            Top-down constructor of StructSchemaElement
            Used to parse programs.
            </summary>
            <param name="parent"></param>
            <param name="name"></param>
            <param name="nullable"></param>
            <param name="learner"></param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.StructSchemaElement`3.#ctor(System.String,System.Collections.Generic.List{Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement{`0,`1,`2}},System.Boolean,Microsoft.ProgramSynthesis.Wrangling.ExtractionLearner{`0,`1,`2})">
            <summary>
            Bottom-up constructor of StructSchemaElement.
            Used to learn programs from examples.
            </summary>
            <param name="name"></param>
            <param name="members"></param>
            <param name="nullable"></param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.StructSchemaElement`3.#ctor(System.String,Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement{`0,`1,`2},System.Boolean,Microsoft.ProgramSynthesis.Wrangling.ExtractionLearner{`0,`1,`2})">
            <summary>
            Top-down constructor of StructSchemaElement
            Used to parse programs.
            </summary>
            <param name="name"></param>
            <param name="parent"></param>
            <param name="nullable"></param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.StructSchemaElement`3.RunTreeBoundaries(`2,System.Collections.Generic.IEnumerable{`2})">
            <summary>
            Short-circuit so that this method can be run even without RunTree.
            </summary>
            <param name="s"></param>
            <param name="run"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.StructSchemaElement`3.FindExplicitElement``1(Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement{`0,`1,`2},Microsoft.ProgramSynthesis.Wrangling.SchemaParser.TreeElement{``0},``0)">
            <summary>
            Return the singleton object wrapped by the sequence tree inside the boundaries.
            There should be exactly one element, as this is used by implicit structs only.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.StructSchemaElement`3.IsChildDefiningImplicitBoundaries(Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement{`0,`1,`2})">
            <summary>
            Returns true if the given child/member is defining implicit boundaries.
            </summary>
            <param name="member">The child to test</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.UnionSchemaElement`3.#ctor(System.String,System.Collections.Generic.List{Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement{`0,`1,`2}},System.Boolean,Microsoft.ProgramSynthesis.Wrangling.ExtractionLearner{`0,`1,`2})">
            <summary>
            Bottom-up constructor.
            </summary>
            <param name="name"></param>
            <param name="members"></param>
            <param name="nullable"></param>
            <param name="learner"></param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaParser.UnionSchemaElement`3.#ctor(System.String,Microsoft.ProgramSynthesis.Wrangling.SchemaParser.SchemaElement{`0,`1,`2},System.Boolean,Microsoft.ProgramSynthesis.Wrangling.ExtractionLearner{`0,`1,`2})">
            <summary>
            Top-down constructor of StructSchemaElement
            Used to parse programs.
            </summary>
            <param name="name"></param>
            <param name="parent"></param>
            <param name="nullable"></param>
            <param name="learner"></param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.SchemaProgram`4">
            <summary>
                Wrapper around a <see cref="!:SchemaElement&lt;TExtractionProgram,TRegion&gt;"/> of the given type, used to
                perform learning on one element
            </summary>
            <typeparam name="TSequenceProgram">The type of sequence extraction programs.</typeparam>
            <typeparam name="TRegionProgram">The type of region extraction programs.</typeparam>
            <typeparam name="TRegion">The type of regions on which this operates</typeparam>
            <typeparam name="TSelector">The type of selector used by the method Select</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.SchemaProgram`4.LearnedSchemaProgram">
            <summary>
                The learned schema program.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaProgram`4.Format(Microsoft.ProgramSynthesis.AST.ASTSerializationFormat)">
            <summary>
                Format the schema program.
            </summary>
            <param name="format">The desired format.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaProgram`4.Select(`3,`2)">
            <summary>
                Creates a region from the input and a selector.
            </summary>
            <param name="input"></param>
            <param name="selector"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaProgram`4.Run(`3)">
            <summary>
                Executes the schema program on the string <paramref name="s"/>. Returns the highlighting of the tree.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaProgram`4.LearnElementField(System.String,System.Collections.Generic.IEnumerable{`2},System.Collections.Generic.IEnumerable{`2},`3,System.Int32)">
            <summary>
                Learns an element interactively. We can repeatedly call this method (with an increasing number of
                examples) to learn a field. Once we switch to a new field, we cannot call this method on previously
                learned fields.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SchemaProgram`4.LearnElementField(System.String,System.Collections.Generic.IEnumerable{`3},System.Collections.Generic.IEnumerable{`3},`3,System.Int32)">
            <summary>
                Learns an element interactively. We can repeatedly call this method (with an increasing number of
                examples) to learn a field. Once we switch to a new field, we cannot call this method on previously
                learned fields.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Schema.Element.ISchemaElement`1">
            <summary>
                Represents an element in the schema definition. An element in the schema corresponds to a field in the extraction.
                An element may contain other elements to form a hierarchical structure.
            </summary>
            <typeparam name="TRegion">The output type of this element.</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Schema.Element.ISchemaElement`1.Name">
            <summary>
                The name of the field corresponding to this element.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Schema.Element.ISchemaElement`1.IsNullable">
            <summary>
                Determines whether this element may return null.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Schema.Element.ISchemaElement`1.UseOutput">
            <summary>
                Determines whether the output of this element are included in the output.
                It is false if the element is dummy (i.e., its existence is to group several elements together).
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Schema.Element.ISchemaElement`1.DescendantOutputFields">
            <summary>
                All output fields of this node and its descendants.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Schema.Element.SequenceElement`1">
            <summary>
                Represents a sequence of structures, each of which may contain a list of children.
                A child can be any kind of <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Schema.Element.ISchemaElement`1" />.
            </summary>
            <typeparam name="TRegion">The output type of this element.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Schema.Element.SequenceElement`1.#ctor(System.String,System.Boolean,System.Boolean,Microsoft.ProgramSynthesis.Wrangling.Schema.Element.ISchemaElement{`0})">
            <summary>
                Constructs a sequence of leaf elements from its constituent parts.
            </summary>
            <param name="name">The name of this element</param>
            <param name="isNullable">Specifies whether the output can be null.</param>
            <param name="useOutput">Specifies whether the overall output include the structure boundaries.</param>
            <param name="child">The child element.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Schema.Element.SequenceElement`1.Child">
            <summary>
                The child of this sequence.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Schema.Element.SequenceElement`1.Name">
            <summary>
                The name of the field corresponding to this element.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Schema.Element.SequenceElement`1.IsNullable">
            <summary>
                Determines whether this element may return null.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Schema.Element.SequenceElement`1.UseOutput">
            <summary>
                Determines whether the output of this element are included in the output.
                If this is false, we do not include the value of this sequence to the output (but we include the values of its
                elements).
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Schema.Element.SequenceElement`1.DescendantOutputFields">
            <summary>
                All output fields of this node and its descendants.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Schema.Element.StructElement`1">
            <summary>
                Represents a structure that contains a list of children,
                each of which can be other kinds of <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Schema.Element.ISchemaElement`1" />.
            </summary>
            <typeparam name="TRegion">The output type of this element.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Schema.Element.StructElement`1.#ctor(System.String,System.Boolean)">
            <summary>
                Constructs a leaf element from its constituent parts.
            </summary>
            <param name="name">The name of this element</param>
            <param name="isNullable">Specifies whether the output can be null.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Schema.Element.StructElement`1.#ctor(System.String,System.Boolean,System.Boolean,System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Schema.Element.ISchemaElement{`0}})">
            <summary>
                Constructs a structure element from its constituent parts.
            </summary>
            <param name="name">The name of this element</param>
            <param name="isNullable">Specifies whether the output can be null.</param>
            <param name="useOutput">
                Specifies whether the overall output include the structure boundaries.
            </param>
            <param name="children">The children elements.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Schema.Element.StructElement`1.Children">
            <summary>
                The list of children of this structure.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Schema.Element.StructElement`1.Name">
            <summary>
                The name of the field corresponding to this element.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Schema.Element.StructElement`1.IsNullable">
            <summary>
                Determines whether this element may return null.c
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Schema.Element.StructElement`1.UseOutput">
            <summary>
                Determines whether the output of this element are included in the output.
                If this is false, we do not include the struct boundary to the output (but we include the values of its
                children).
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Schema.Element.StructElement`1.DescendantOutputFields">
            <summary>
                All output fields of this node and its descendants.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Schema.TableOutput.ICell`1">
            <summary>
                Represents an output cell
            </summary>
            <typeparam name="TRegion">The output type.</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Schema.TableOutput.ICell`1.CellValue">
            <summary>
                The value of this cell.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Schema.TableOutput.ITable`1">
            <summary>
                Represents a table.
            </summary>
            <typeparam name="T">The type of the table cell.</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Schema.TableOutput.ITable`1.ColumnNames">
            <summary>
                The column names.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Schema.TableOutput.ITable`1.Rows">
            <summary>
                The actual table, which contains a list of rows.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Schema.TableOutput.ITable`1.Metadata">
            <summary>
                The metadata about this table.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Schema.TableOutput.Table`1">
            <summary>
                Represents a rectangular table that has some columns and a list of rows.
            </summary>
            <typeparam name="T">The type of the table cell.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Schema.TableOutput.Table`1.#ctor(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`0}},System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.Wrangling.Schema.TableOutput.ITableMetadata})">
            <summary>
                Creates a table that has the columns name in <paramref name="columnNames" /> and the data rows in
                <paramref name="rows" />.
                If <paramref name="columnNames" /> is null, use the default names "column{i}".
            </summary>
            <param name="columnNames">The column names.</param>
            <param name="rows">The data rows.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Schema.TableOutput.Table`1.Equals(Microsoft.ProgramSynthesis.Wrangling.Schema.TableOutput.Table{`0})">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Schema.TableOutput.Table`1.Rows">
            <summary>
                The actual table, which contains a list of rows.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Schema.TableOutput.Table`1.ColumnNames">
            <summary>
                The column names.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Schema.TableOutput.Table`1.GetEnumerator">
            <summary>
                Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
                An enumerator that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Schema.TableOutput.Table`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
                Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
                An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Schema.TableOutput.Table`1.Equals(System.Object)">
            <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Schema.TableOutput.Table`1.GetHashCode">
            <summary>
                Serves as the default hash function.
            </summary>
            <returns>
                A hash code for the current object: this includes the entire table content
                (all column names, their values, and number of prefix rows)
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Schema.TableOutput.Table`1.HashedColumn(System.String)">
            <summary>
                Serves as the column-wise hash function.
            </summary>
            <returns>
                A hash code for a column of the table.
            </returns>
            <param name="columnName">The name of the column whose hash is desired.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Schema.TableOutput.Table`1.HashedNormalizedColumn(System.String)">
            <summary>
                Serves as the normalized column-wise hash function.
            </summary>
            <returns>
                A hash code for a normalized column of the table.
            </returns>
            <param name="columnName">The name of the column whose hash is desired.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Schema.TableOutput.ITableMetadata">
            <summary>
               An interface for the metadata of a table.
            </summary>
            <remarks>
               API users can implement this interface to provide metadata for a table,
               or use one of the existing implementations below.
            </remarks>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Schema.TableOutput.ColumnTypesMetadata">
            <summary>
                Specifies the column types of the table.
            </summary>
            <remarks>
                Useful for specifying the type names in the native language of the data source.
            </remarks>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Schema.TableOutput.NumPrefixRowsMetadata">
            <summary>
                Specifies the number of prefix rows in the table.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Schema.TreeOutput.ITreeOutput`1">
            <summary>
                Represents a node in the output tree.
            </summary>
            <typeparam name="TRegion">The type of value of this node.</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Schema.TreeOutput.ITreeOutput`1.Name">
            <summary>
                The name of the field corresponding to this node.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Schema.TreeOutput.ITreeOutput`1.ToTable(Microsoft.ProgramSynthesis.Wrangling.Schema.Element.ISchemaElement{`0},Microsoft.ProgramSynthesis.Wrangling.Schema.TreeToTableSemantics)">
            <summary>
                Returns the table representation of this node.
            </summary>
            <param name="schema">The schema of this node.</param>
            <param name="semantics">The semantics of generating the table. See <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Schema.TreeToTableSemantics" />.</param>
            <returns>The table representation of this node.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Schema.TreeOutput.SequenceOutput`1">
            <summary>
            Represents a sequence of nodes.
            </summary>
            <typeparam name="TRegion">The type of value of this node.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Schema.TreeOutput.SequenceOutput`1.#ctor(System.String,System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Schema.TreeOutput.ITreeOutput{`0}})">
            <summary>
            Constructs a sequence of nodes.
            </summary>
            <param name="name">The name of the field corresponding to this node.</param>
            <param name="elements">The list of nodes.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Schema.TreeOutput.SequenceOutput`1.Name">
            <summary>
            The name of the field corresponding to this node.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Schema.TreeOutput.SequenceOutput`1.ToTable(Microsoft.ProgramSynthesis.Wrangling.Schema.Element.ISchemaElement{`0},Microsoft.ProgramSynthesis.Wrangling.Schema.TreeToTableSemantics)">
            <summary>
            Returns the table representation of this node.
            </summary>
            <param name="schema">The schema of this node.</param>
            <param name="semantics">The semantics of generating the table. See <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Schema.TreeToTableSemantics"/>.</param>
            <returns>The table representation of this node.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Schema.TreeOutput.SequenceOutput`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Schema.TreeOutput.SequenceOutput`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Schema.TreeOutput.StructOutput`1">
            <summary>
            Represents an output node of a field.
            This node may contains other nodes that belong to its children.
            </summary>
            <typeparam name="TRegion">The type of value of this node.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Schema.TreeOutput.StructOutput`1.#ctor(System.String,`0,System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Schema.TreeOutput.ITreeOutput{`0}})">
            <summary>
            Constructs a output node from its constituent elements.
            </summary>
            <param name="name">The name of the field corresponding to this node.</param>
            <param name="value">The value of this node.</param>
            <param name="children">The children nodes.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Schema.TreeOutput.StructOutput`1.Value">
            <summary>
            The value of this node.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Schema.TreeOutput.StructOutput`1.Children">
            <summary>
            The children nodes.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Schema.TreeOutput.StructOutput`1.Name">
            <summary>
            The name of the field corresponding to this node.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Schema.TreeOutput.StructOutput`1.ToTable(Microsoft.ProgramSynthesis.Wrangling.Schema.Element.ISchemaElement{`0},Microsoft.ProgramSynthesis.Wrangling.Schema.TreeToTableSemantics)">
            <summary>
            Returns the table representation of this node.
            </summary>
            <param name="schema">The schema of this node.</param>
            <param name="semantics">The semantics of generating the table. See <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Schema.TreeToTableSemantics"/>.</param>
            <returns>The table representation of this node.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Schema.TreeToTableSemantics">
            <summary>
                Specifies the semantics when transforming a tree to a table.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.Schema.TreeToTableSemantics.InnerJoin">
            <summary>
                If the child array is empty, this node will not be present in the output table.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.Schema.TreeToTableSemantics.OuterJoin">
            <summary>
                If the child array is empty, this node will be present in the output table.
                The child array element will be filled with null values.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.SequenceExtractionProgram`2.ExtractionKind">
            <summary>
                Represents the extraction kind of this program.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.SequenceExtractionProgram`2.ReferenceKind">
            <summary>
                Specifies how this program relates to its referenced field.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SequenceExtractionProgram`2.Serialize(Microsoft.ProgramSynthesis.AST.ASTSerializationSettings)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Session.Conflict">
            <summary>
                Information about a conflict between constraints. A conflict occurs when two constraints contradict each other. A
                conflict contains the set of other constraints involved in the conflict.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.Conflict.#ctor(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Constraints.IConstraint})">
            <summary>
                Constructs a new <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Session.Conflict" />.
            </summary>
            <param name="conflictingConstraints">The constraints which contradict each other.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.Conflict.#ctor(Microsoft.ProgramSynthesis.Wrangling.Constraints.IConstraint[])">
            <summary>
                Constructs a new <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Session.Conflict" />.
            </summary>
            <param name="conflictingConstraints">The constraints which contradict each other.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.Conflict.ConflictingConstraints">
            <summary>
                The constraints which conflict with each other. At least one must be removed to resolve the conflict.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Session.IJournalStorage">
            <summary>
                Interface for backing store for a journal, which is a persistent dictionary from strings to string. Journals are
                used for information that is persisted across multiple <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3" />s for
                adapting to a user's or organization's preferences. The client is responsible for the persistence of the journal,
                which is done by providing an implementation of this interface pointing to the same persistent store to each
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3" />.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Session.ITextReaderInput">
             <summary>
                 Interface (for <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3"/>s)
                 that support reading inputs (in the session) from a <see cref="T:System.IO.TextReader"/>.
            
                 This is used to allow Detection to add functionality to DSLs that read from files
                 (e.g., Extraction.Json and Read.FlatFile) without needing an explicit dependency.
             </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest`3">
            <summary>
                Wraps the information needed for learning in an immutable object.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest`3._hashCode">
            <summary>
                Cached hashcode value.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest`3.#ctor(System.Collections.Immutable.IImmutableList{`1},System.Collections.Immutable.IImmutableList{Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`1,`2}})">
            <summary>
                Wrap the information needed to run the synthesizer.
            </summary>
            <param name="inputs">The known inputs.</param>
            <param name="constraints">The constraints the program must satisfy.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest`3.Inputs">
            <summary>
                All of the known inputs.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest`3.Constraints">
            <summary>
                The constraints describing what programs are valid.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest`3.Equals(Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest{`0,`1,`2})">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest`3.Equals(System.Object)">
            <summary>
                Returns a value that indicates whether the current <see cref="T:System.Tuple`4" /> object is equal to a specified
                object.
            </summary>
            <returns>
                true if the current instance is equal to the specified object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with this instance.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest`3.GetHashCode">
            <summary>
                Returns the hash code for the current object.
            </summary>
            <returns>
                A 32-bit signed integer hash code.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest`3.op_Equality(Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest{`0,`1,`2},Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest{`0,`1,`2})">
            <summary>
                Checks if two <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest`3" />s are equal.
            </summary>
            <param name="left">The first request.</param>
            <param name="right">The second request.</param>
            <returns>True if <paramref name="left" /> and <paramref name="right" /> wrap the same information.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest`3.op_Inequality(Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest{`0,`1,`2},Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest{`0,`1,`2})">
            <summary>
                Checks if two <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest`3" />s are not equal.
            </summary>
            <param name="left">The first request.</param>
            <param name="right">The second request.</param>
            <returns>False if <paramref name="left" /> and <paramref name="right" /> wrap the same information.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest`3.WithoutInputs">
            <summary>
                Returns the current request without the additional inputs.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest`3.IsConstrained(`1)">
            <summary>
                Check if an input constrained in this request.
            </summary>
            <param name="input">The input.</param>
            <returns>True if the input is constrained, and false otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest`3.ConstrainedInputs">
            <summary>
                The list of inputs that are constrained by the request.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Session.LearnResultKind">
            <summary>
                The kind of a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Session.LearnResult`3" />.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.Session.LearnResultKind.Unknown">
            <summary>
                Kind is unknown. This is the default value if no kind is set.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.Session.LearnResultKind.Success">
            <summary>
                At least one program was learned.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.Session.LearnResultKind.NoPrograms">
            <summary>
                No programs were learned, but <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.LearnResult`3.Conflicts" /> does not contain
                information on conflicts.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.Session.LearnResultKind.HasConficts">
            <summary>
                The <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.LearnResult`3.Conflicts" /> collection is non-empty, explaining why no
                programs were learned.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Session.LearnResult`3">
            <summary>
                All of the information extracted from a session from a single <see cref="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Learn(Microsoft.ProgramSynthesis.Wrangling.Session.RankingMode,System.Threading.CancellationToken,System.Nullable{System.Guid})" />
                call.
            </summary>
            <typeparam name="TProgram">Type of programs to learn.</typeparam>
            <typeparam name="TInput">Input type of <typeparamref name="TProgram" />.</typeparam>
            <typeparam name="TOutput">Output type of <typeparamref name="TProgram" />.</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.LearnResult`3.Kind">
            <summary>
                Summary of this result.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.LearnResult`3.LearnedPrograms">
            <summary>
                Ranked list of programs learned, if any. This is non-empty only if <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.LearnResult`3.Kind" /> is
                <see cref="F:Microsoft.ProgramSynthesis.Wrangling.Session.LearnResultKind.Success" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.LearnResult`3.Conflicts">
            <summary>
                Conflicts between constraints which make learning impossible. This is non-empty only if <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.LearnResult`3.Kind" /> is
                <see cref="F:Microsoft.ProgramSynthesis.Wrangling.Session.LearnResultKind.HasConficts" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.LearnResult`3.ProgramOutputs">
            <summary>
                Outputs of the programs on the inputs in the <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3" />. This is non-empty
                only if <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.LearnResult`3.Kind" /> is <see cref="F:Microsoft.ProgramSynthesis.Wrangling.Session.LearnResultKind.Success" />.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Session.SessionUtils">
            <summary>
                Utility class for generating <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Session.LearnResult`3" />s from a
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3" />. This calls all of the relevant
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3" /> methods to collect the data for the
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Session.LearnResult`3" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.SessionUtils.ComputeLearnResultAsync``3(Microsoft.ProgramSynthesis.Wrangling.Session.Session{``0,``1,``2},System.Int32,Microsoft.ProgramSynthesis.Wrangling.Session.RankingMode,System.Threading.CancellationToken,System.Nullable{System.Guid})">
            <summary>
                Run <see cref="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.LearnTopKAsync(System.Int32,Microsoft.ProgramSynthesis.Wrangling.Session.RankingMode,System.Threading.CancellationToken,System.Nullable{System.Guid})" /> and collect related data into a
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Session.LearnResult`3" />.
            </summary>
            <typeparam name="TProgram">Type of programs to learn.</typeparam>
            <typeparam name="TInput">Input type of <typeparamref name="TProgram" />.</typeparam>
            <typeparam name="TOutput">Output type of <typeparamref name="TProgram" />.</typeparam>
            <param name="session">Session to learn in.</param>
            <param name="numPrograms">
                How many programs to learn. Will only return fewer programs if there are not
                <paramref name="numPrograms" /> programs consistent with the constraints. May learn more in the case of ties in
                choosing the top <paramref name="numPrograms" /> programs.
            </param>
            <param name="rankingMode"><see cref="T:Microsoft.ProgramSynthesis.Wrangling.Session.RankingMode" /> to use for selecting top programs.</param>
            <param name="cancel">Cancellation token.</param>
            <param name="guid">Correlation id for logging and telemtry.</param>
            <returns>A <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Session.LearnResult`3" /> with all of the requested information.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Session.NonInteractiveSession`3">
            <summary>
                A <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3" /> that learns at once using a
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3" /> as opposed to supporting incremental learning.
            </summary>
            <typeparam name="TProgram">Type of programs this session learns.</typeparam>
            <typeparam name="TInput">Type of inputs to programs this session learns.</typeparam>
            <typeparam name="TOutput">Type of outputs of programs this session learns.</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.NonInteractiveSession`3.JsonSerializerSettings">
            <summary>
                Pass this property to json.net when serializing or deserializing a session object.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.NonInteractiveSession`3.JsonSerializerSettingsInstance">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.NonInteractiveSession`3.Grammar">
            <summary>
                The grammar of programs this session synthesizes. Currently used for the
                <see cref="P:Microsoft.ProgramSynthesis.Grammar.InputSymbol" /> only.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.NonInteractiveSession`3.LoggingTypeName">
            <inheritdoc />
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.Session.NonInteractiveSession`3._useCache">
            <summary>
            Determines whether learning results should be cached.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.NonInteractiveSession`3.#ctor(Microsoft.ProgramSynthesis.Wrangling.ProgramLearner{`0,`1,`2},Microsoft.ProgramSynthesis.Wrangling.IProgramLoader{`0,`1,`2},Microsoft.ProgramSynthesis.Wrangling.Session.IJournalStorage,System.Globalization.CultureInfo,System.String,Microsoft.ProgramSynthesis.Wrangling.Logging.ILogger,System.Boolean)">
            <summary>
                Creates a new session.
            </summary>
            <param name="learner">The <see cref="T:Microsoft.ProgramSynthesis.Wrangling.ProgramLearner`3" /> used to learn.</param>
            <param name="loader">
                The <see cref="T:Microsoft.ProgramSynthesis.Wrangling.IProgramLoader`3" /> used to create
                <typeparamref name="TProgram" /> objects.
            </param>
            <param name="journalStorage">
                Backing store for the journal of user actions used to adapt to user preferences. May be
                null to not save this data.
            </param>
            <param name="culture">
                The <see cref="T:System.Globalization.CultureInfo" /> to use when learning programs; accessible using
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Culture" />. Used to select preferred date and number formats and
                defaults for other culture-specific settings.
            </param>
            <param name="loggingTypeName">
                Name to use to identify the type of this session in the logger. Defaults to
                <see cref="P:Microsoft.ProgramSynthesis.Grammar.Name" />.
            </param>
            <param name="logger">
                The <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Logging.ILogger" /> implementation to use for providing telemetry information.
            </param>        
            <param name="useCache">
                Specifies whether to cache the learning results.
            </param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.NonInteractiveSession`3.MaxCacheSize">
            <summary>
                Maximum number of <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest`3" />s to cache results for.
                Defaults to 5.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.NonInteractiveSession`3.CleanCache">
            <summary>
                Remove old learning results from the cache.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.NonInteractiveSession`3.ChooseSignificantInputFromCluster(System.Collections.Generic.IReadOnlyList{`1})">
            <summary>
                Selects a representative input from a cluster of inputs. <paramref name="cluster" /> is a single cluster, so any of
                its elements should be an acceptable representative of the cluster, but a DSL may wish to override this to select
                the best representative.
            </summary>
            <param name="cluster">A collection of inputs which are all similar to each other.</param>
            <returns>An element of <paramref name="cluster" /> determined to be representative.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.NonInteractiveSession`3.GetSignificantInputsAsync(Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.ProgramSamplingStrategy,System.Nullable{System.Double},System.Threading.CancellationToken,System.Nullable{System.Guid},Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest{`0,`1,`2})">
            <inheritdoc cref="M:Microsoft.ProgramSynthesis.Wrangling.Session.NonInteractiveSession`3.GetSignificantInputsAsync(System.Nullable{System.Double},System.Threading.CancellationToken,System.Nullable{System.Guid})" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.NonInteractiveSession`3.GetSignificantInputsAsync(System.Nullable{System.Double},System.Threading.CancellationToken,System.Nullable{System.Guid})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.NonInteractiveSession`3.GetSignificantInputs(System.Nullable{System.Double},System.Threading.CancellationToken,System.Nullable{System.Guid})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.NonInteractiveSession`3.ComputeTopKOutputsAsync(`1,System.Int32,Microsoft.ProgramSynthesis.Wrangling.Session.RankingMode,System.Nullable{System.Double},System.Threading.CancellationToken)">
            <summary>
                Compute the top-<paramref name="k" /> outputs for <paramref name="input" /> of programs that satisfy
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Constraints" />. This differs from taking the outputs of the top-
                <paramref name="k" /> programs from
                <see cref="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.LearnTopKAsync(System.Int32,Microsoft.ProgramSynthesis.Wrangling.Session.RankingMode,System.Threading.CancellationToken,System.Nullable{System.Guid})" /> in two ways: (1) more than <paramref name="k" />
                programs are learned and only
                <em>distinct</em> outputs are returned, and (2) the <paramref name="confidenceThreshold" /> (defaults to
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.ConfidenceThreshold" />) is used to discard programs that are much
                worse than the best program.
            </summary>
            <param name="input">Input to give outputs for.</param>
            <param name="k">How many outputs to attempt to generate. Will never generate more, but may generate fewer.</param>
            <param name="rankingMode">How the programs should be ranked.</param>
            <param name="confidenceThreshold">
                Optional value in [0,1] used to limit outputs to those likely to be useful. A value
                of 1 would mean to only return outputs which are tied for the best.
            </param>
            <param name="cancel">Cancellation token.</param>
            <returns>Up to <paramref name="k" /> of the best outputs for <paramref name="input" /> in ranked order.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Session.NonInteractiveSessionJsonSerializerSettings`3">
            <summary>
                Serializer settings to be used with Json.Net when serializing or deserializing a NonInteractiveSession
                object. This is normally exposed through a static property on the Session class.
            </summary>
            <typeparam name="TProgram">Program type used by the session class.</typeparam>
            <typeparam name="TInput">Input type used by the session class.</typeparam>
            <typeparam name="TOutput">Output type used by the session class.</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.NonInteractiveSessionJsonSerializerSettings`3.SessionTypes">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Session.RankingMode">
            <summary>
                Strategy to use for ranking programs. Examples include the most likely program and the most performant program.
                Note that all learned programs will satisfy the constraints; ranking is used to select one of the many programs
                satisfying the constraints.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.RankingMode.MostLikely">
            <summary>
                Use heuristics to select the program which most likely matches the user's intent.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3">
            <summary>
                A learning session for learning a program for a specific task. Key concepts are: <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Inputs" /> which
                provide the inputs known for the program at learning time.
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Constraints" /> which specify what the program must satisfy. <see cref="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Learn(Microsoft.ProgramSynthesis.Wrangling.Session.RankingMode,System.Threading.CancellationToken,System.Nullable{System.Guid})" /> which
                learns a program.
            </summary>
            <typeparam name="TProgram">Type of programs this session learns.</typeparam>
            <typeparam name="TInput">Type of inputs to programs this session learns.</typeparam>
            <typeparam name="TOutput">Type of outputs of programs this session learns.</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.JsonSerializerSettings">
            <summary>
                Pass this property to json.net when serializing or deserializing a session object.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.JsonSerializerSettingsInstance">
            <summary>
                Provides instance access to the static property <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.JsonSerializerSettings" />; override in any subclass
                that has its own <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.JsonSerializerSettings" />.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3._conflicts">
            <summary>
                The <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Conflicts" /> among <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Constraints" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.ProgramLoader">
            <summary>
                The program loader to use to load programs for this session.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.JournalStorage">
            <summary>
                The backing store for the journal used for adaptive learning across sessions.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Culture">
            <summary>
                The <see cref="T:System.Globalization.CultureInfo" /> that learned programs will use. This may be used in learning to prefer certain date
                or number formats or other culture-specific settings. If not specified, <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>
                is used by default.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.UseInputsInLearn">
            <summary>
                If <c>true</c> (default), then <see cref="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Learn(Microsoft.ProgramSynthesis.Wrangling.Session.RankingMode,System.Threading.CancellationToken,System.Nullable{System.Guid})" />, <see cref="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.LearnTopK(System.Int32,Microsoft.ProgramSynthesis.Wrangling.Session.RankingMode,System.Threading.CancellationToken,System.Nullable{System.Guid})" />, <see cref="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.LearnAll(System.Threading.CancellationToken,System.Nullable{System.Guid})" />, and their
                async variants will use <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Inputs" /> when learning. Otherwise, other methods like
                <see cref="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.GetSignificantInputsAsync(System.Nullable{System.Double},System.Threading.CancellationToken,System.Nullable{System.Guid})" /> may use
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Inputs" /> but explicitly learned programs will only use <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Constraints" />.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.DefaultConfidenceThreshold">
            <summary>
                The default value for <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.ConfidenceThreshold"/>. Empirically a good value.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.ConfidenceThreshold">
            <summary>
                The default confidence threshold for methods that take one. This is a value in the range [0,1] which represents the
                certainly level a computation should have for returning a result. That is at 0.95, methods will only return results
                that they are 95% confident should appear in the result set. This defaults to a sensible value so most clients
                should not need to modify this.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.DeserializationContext">
            <summary>
                The <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.DeserializationContext"/> to use when deserializing programs generated by this session.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Logger">
            <summary>
                Telemetry logger.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Inputs">
            <summary>
                All known inputs. Used when learning programs to prefer programs that work on these inputs.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.RankingMode">
            <summary>
                Default <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.RankingMode" /> for Learn() calls.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Constraints">
            <summary>
                Constraints to define what programs are valid to be learned.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Conflicts">
            <summary>
                The <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Conflicts" /> among <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Constraints" /> which make learning impossible. If this is non-empty
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.CanLearn" /> will be false.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.CanLearn">
            <summary>
                False if learning will definitely not return any programs due to <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Conflicts" /> being non-empty.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.SetLogger(Microsoft.ProgramSynthesis.Wrangling.Logging.ILogger)">
            <summary>
                Set the telemetry logger implementation.
            </summary>
            <param name="logger">
                Implementation of ILogger to use for telemetry.  Null is allowed.  If supplied, it turns off logging.
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Load(System.String,Microsoft.ProgramSynthesis.AST.ASTSerializationFormat)">
            <summary>
                Loads a <typeparamref name="TProgram" /> that has been serialized to
                <paramref name="serializedProgram" /> using <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.DeserializationContext"/> as the context.
            </summary>
            <param name="serializedProgram">
                The serialized program generated by
                <see cref="M:Microsoft.ProgramSynthesis.Program`2.Serialize(Microsoft.ProgramSynthesis.AST.ASTSerializationFormat)" />.
            </param>
            <param name="serializationFormat">The serialization format of <paramref name="serializedProgram" />.</param>
            <returns>A <typeparamref name="TProgram" /> deserialized from <paramref name="serializedProgram" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Load(System.String,Microsoft.ProgramSynthesis.AST.ASTSerializationFormat,Microsoft.ProgramSynthesis.AST.ProgramNodeParser)">
            <summary>
                Loads a <typeparamref name="TProgram" /> that has been serialized to
                <paramref name="serializedProgram" /> using <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.DeserializationContext"/> as the context.
            </summary>
            <param name="serializedProgram">
                The serialized program generated by
                <see cref="M:Microsoft.ProgramSynthesis.Program`2.Serialize(Microsoft.ProgramSynthesis.AST.ASTSerializationFormat)" />.
            </param>
            <param name="serializationFormat">The serialization format of <paramref name="serializedProgram" />.</param>
            <param name="programNodeParser">A custom parser that produces ProgramNodes from their serialized formats.</param>
            <returns>A <typeparamref name="TProgram" /> deserialized from <paramref name="serializedProgram" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.UpdateConflicts(System.Object,Microsoft.ProgramSynthesis.Utils.CollectionEvent{Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{`1,`2}})">
            <summary>
                Update conflicts in response to the constraints being changed.
            </summary>
            <param name="sender">Ignored.</param>
            <param name="args">How the set of constraints changed.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.BuildLearnProgramRequest(System.Nullable{System.Boolean})">
            <summary>
                Build an immutable object containing the current information needed for learning a program.
            </summary>
            <param name="useInputsInLearn">
                If <c>true</c> (defaults to <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.UseInputsInLearn" />), <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Inputs" /> will
                be included in the <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest`3" />; otherwise, only
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Constraints" /> will be included.
            </param>
            <returns>An immutable object wrapping the current values of <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Inputs" /> and <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Constraints" />.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.LoggingTypeName">
            <summary>
                Identifier to use for the kind of session this is when logging. Usually just the name of the DSL like
                "Transformation.Text" or "Extraction.Web".
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.LearnTopKRandomKCached(Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest{`0,`1,`2},Microsoft.ProgramSynthesis.Wrangling.Session.RankingMode,System.Int32,System.Nullable{System.Int32},System.Boolean,System.Threading.CancellationToken)">
            <summary>
                Override in subclasses to implement learning of the top-<paramref name="k" /> programs.
            </summary>
            <param name="request">Inputs and constraints to use when learning.</param>
            <param name="rankingMode">How the programs should be ranked.</param>
            <param name="k">
                Minimum number of programs to learn if possible. May only return fewer programs if all programs are
                returned.
            </param>
            <param name="randomK">Number of random programs to sample.</param>
            <param name="cachedOnly">If <c>true</c>, return <c>null</c> if the program is not in the cache.</param>
            <param name="cancel">Cancellation token.</param>
            <returns>The top-<see cref="!:k" /> (by <paramref name="rankingMode" />) programs satisfying <paramref name="request" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Learn(Microsoft.ProgramSynthesis.Wrangling.Session.RankingMode,System.Threading.CancellationToken,System.Nullable{System.Guid})">
            <summary>
                Learns the top program.
            </summary>
            <param name="rankingMode">What "top" means.</param>
            <param name="cancel">Cancellation token.</param>
            <param name="guid">Correlation id for logging and telemetry.</param>
            <returns>The top program or null if no program can be learned.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.LearnAsync(Microsoft.ProgramSynthesis.Wrangling.Session.RankingMode,System.Threading.CancellationToken,System.Nullable{System.Guid})">
            <summary>
                Learns the top program. This runs a task on a separate thread after capturing the current <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Inputs" /> and
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Constraints" />.
            </summary>
            <param name="rankingMode">What "top" means.</param>
            <param name="cancel">Cancellation token.</param>
            <param name="guid">Correlation id for logging and telemtry.</param>
            <returns>The top program or null if no program can be learned.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.LearnTopK(System.Int32,Microsoft.ProgramSynthesis.Wrangling.Session.RankingMode,System.Threading.CancellationToken,System.Nullable{System.Guid})">
            <summary>
                Learns the top-<paramref name="k" /> programs.
            </summary>
            <param name="k">
                Minimum number of programs to learn if possible. May only return fewer programs if all programs are
                returned.
            </param>
            <param name="rankingMode">How the programs should be ranked.</param>
            <param name="cancel">Cancellation token.</param>
            <param name="guid">Correlation id for logging and telemtry.</param>
            <returns>
                The top-<paramref name="k" /> programs (according to <paramref name="rankingMode" />). May contain fewer than
                <paramref name="k" /> programs only if there do not exist <paramref name="k" /> programs that satisfy the
                constraints.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.LearnTopKAsync(System.Int32,Microsoft.ProgramSynthesis.Wrangling.Session.RankingMode,System.Threading.CancellationToken,System.Nullable{System.Guid})">
            <summary>
                Learns the top-<paramref name="k" /> programs. This runs a task on a separate thread after capturing the current
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Inputs" /> and <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Constraints" />.
            </summary>
            <param name="k">
                Minimum number of programs to learn if possible. May only return fewer programs if all programs are
                returned.
            </param>
            <param name="rankingMode">How the programs should be ranked.</param>
            <param name="cancel">Cancellation token.</param>
            <param name="guid">Correlation id for logging and telemtry.</param>
            <returns>
                The top-<paramref name="k" /> programs (according to <paramref name="rankingMode" />). May contain fewer than
                <paramref name="k" /> programs only if there do not exist <paramref name="k" /> programs that satisfy the
                constraints.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.LearnAllCached(Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest{`0,`1,`2},System.Boolean,System.Threading.CancellationToken)">
            <summary>
                Override in subclasses to implement learning of the entire VSA.
            </summary>
            <param name="request">Inputs and constraints to use when learning.</param>
            <param name="cachedOnly">If <c>true</c>, return <c>null</c> if the program is not in the cache.</param>
            <param name="cancel">Cancellation token.</param>
            <returns>All programs satisfying <paramref name="request" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.LearnAllCached(Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest{`0,`1,`2},System.Threading.CancellationToken)">
            <summary>
                Learn the entire VSA. Overload of
                <see cref="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.LearnAllCached(Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest{`0,`1,`2},System.Boolean,System.Threading.CancellationToken)" />.
            </summary>
            <param name="request">Inputs and constraints to use when learning.</param>
            <param name="cancel">Cancellation token.</param>
            <returns>All programs satisfying <paramref name="request" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.LearnAll(System.Threading.CancellationToken,System.Nullable{System.Guid})">
            <summary>
                Learns all programs satisfying the constraints.
            </summary>
            <param name="cancel">Cancellation token.</param>
            <param name="guid">Correlation id for logging and telemetry.</param>
            <returns>
                All programs satisfying the constraints. May be <c>null</c> or empty if no programs satisfy the constraints.
                Note this collection may be too large to enumerate.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.LearnAllAsync(System.Threading.CancellationToken,System.Nullable{System.Guid})">
            <summary>
                Learns all programs satisfying the constraints. This runs a task on a separate thread after capturing the current
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Inputs" /> and <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Constraints" />.
            </summary>
            <param name="cancel">Cancellation token.</param>
            <param name="guid">Correlation id for logging and telemetry.</param>
            <returns>
                All programs satisfying the constraints. May be <c>null</c> or empty if no programs satisfy the constraints.
                Note this collection may be too large to enumerate.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.GetSignificantInputsAsync(System.Nullable{System.Double},System.Threading.CancellationToken,System.Nullable{System.Guid})">
            <summary>
                Computes a subset of <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Inputs" /> which is sufficient for future
                learning. Enough representative inputs should be selected such that all of the patterns are present without keeping
                all of the inputs. This can be used to make a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3" /> smaller for saving
                and later reloading and/or to present those inputs to the user to increase their confidence that the learned
                program is correct.
            </summary>
            <param name="confidenceThreshold">
                A number in [0,1] representing how confident the algorithm should be in the inputs
                it selects where higher thresholds correspond to more certain that the input is needed and therefore fewer
                inputs. A threshold of 1 means to only include inputs when completely certain.
            </param>
            <param name="cancel">Cancellation token.</param>
            <param name="guid">Correlation id for logging and telemetry.</param>
            <returns>
                A list of inputs paired with confidence scores sorted in descending order by confidence (higher confidence values
                mean the user should look at those inputs first) or <c>null</c> if unable to select inputs for any reason.
            </returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.GetSignificantInputsAsync(System.Nullable{System.Double},System.Threading.CancellationToken,System.Nullable{System.Guid})"/>
            <seealso cref="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.ComputeTopKOutputsAsync(`1,System.Int32,Microsoft.ProgramSynthesis.Wrangling.Session.RankingMode,System.Nullable{System.Double},System.Threading.CancellationToken)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.GetSignificantInputs(System.Nullable{System.Double},System.Threading.CancellationToken,System.Nullable{System.Guid})">
            <summary>
                Computes successively refined subsets of <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Inputs" /> which are
                sufficient for future learning. Enough representative inputs should be selected such that all of the patterns are
                present without keeping all of the inputs. This can be used to make a
                <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3" /> smaller for saving and later reloading and/or to present those
                inputs to the user to increase their confidence that the learned program is correct.
                <para>
                    This method will return immediately before producing any results. Instead it will schedule a new task
                    (currently using <see cref="M:System.Threading.Tasks.Task.Run(System.Action)" />), which will produce results which will be published
                    using the returned <see cref="T:System.IObservable`1" />.
                </para>
                <para>
                    The results are returned as an <see cref="T:System.IObservable`1" /> where each observed element is a progressively
                    better set of significant inputs. Only non-empty sets will be returned except the very final result, which
                    may be empty indicating that there really are no significant inputs at the given
                    <paramref name="confidenceThreshold" />.
                </para>
                <para>
                    Note that the successive results have no guaranteed relationships to each other.
                </para>
            </summary>
            <param name="confidenceThreshold">
                A number in [0,1] representing how confident the algorithm should be in the inputs
                it selects where higher thresholds correspond to more certain that the input is needed and therefore fewer
                inputs. A threshold of 1 means to only include inputs when completely certain.
            </param>
            <param name="cancel">Cancellation token.</param>
            <param name="guid">Correlation id for logging and telemetry.</param>
            <returns>
                An <see cref="T:System.IObservable`1" /> that continuously publishes the best known so far list of inputs paired with
                confidence scores sorted in descending order by confidence (higher confidence values mean the user should look at
                those inputs first). If unable to select inputs for any reason, then the <see cref="M:System.IObserver`1.OnNext(`0)" /> method
                will never be called, only the <see cref="M:System.IObserver`1.OnCompleted" /> method will be called.
            </returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.GetSignificantInputsAsync(System.Nullable{System.Double},System.Threading.CancellationToken,System.Nullable{System.Guid})" />
            <seealso cref="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.ComputeTopKOutputsAsync(`1,System.Int32,Microsoft.ProgramSynthesis.Wrangling.Session.RankingMode,System.Nullable{System.Double},System.Threading.CancellationToken)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.ComputeTopKOutputsAsync(`1,System.Int32,Microsoft.ProgramSynthesis.Wrangling.Session.RankingMode,System.Nullable{System.Double},System.Threading.CancellationToken)">
            <summary>
                Compute the top-<paramref name="k" /> outputs for <paramref name="input" /> of programs that satisfy
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.Constraints" />. This differs from taking the outputs of the top-<paramref name="k" /> programs from
                <see cref="M:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.LearnTopKAsync(System.Int32,Microsoft.ProgramSynthesis.Wrangling.Session.RankingMode,System.Threading.CancellationToken,System.Nullable{System.Guid})" /> in two ways: (1) more than <paramref name="k" /> programs are learned and only
                <em>distinct</em> outputs are returned, and (2) the <paramref name="confidenceThreshold" /> (defaults to
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.ConfidenceThreshold" />) is used to discard programs that are much worse than the best program.
            </summary>
            <param name="input">Input to give outputs for.</param>
            <param name="k">How many outputs to attempt to generate. Will never generate more, but may generate fewer.</param>
            <param name="rankingMode">How the programs should be ranked.</param>
            <param name="confidenceThreshold">
                Optional value in [0,1] used to limit outputs to those likely to be useful. A value
                of 1 would mean to only return outputs which are tied for the best.
            </param>
            <param name="cancel">Cancellation token.</param>
            <returns>Up to <paramref name="k" /> of the best outputs for <paramref name="input" /> in ranked order.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.IProgramSetWrapper">
            <summary>
                Gives access to the programs in a VSA as <typeparamref name="TProgram" />s. This wraps a <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.IProgramSetWrapper.ProgramSet" />
                object providing access to its <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" />s as more usable <typeparamref name="TProgram" />s.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.IProgramSetWrapper.RealizedPrograms">
            <summary>
                The programs in this program set. Note that this may contain a very large number of programs (possibly many
                trillions), so enumerating the entire list may not be possible.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.IProgramSetWrapper.ProgramSet">
            <summary>
                The underlying VSA (<see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.IProgramSetWrapper.ProgramSet" />).
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3.PrunedProgramSetWrapper">
            <summary>
                Gives access to TopK + RandomK learning results.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Session.SessionJsonSerializerSettings`3">
            <summary>
                Serializer settings to be used with Json.Net when serializing or deserializing a Session object.
                This is normally exposed through a static property on the Session class.
            </summary>
            <typeparam name="TProgram">Program type used by the session class.</typeparam>
            <typeparam name="TInput">Input type used by the session class.</typeparam>
            <typeparam name="TOutput">Output type used by the session class.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.SessionJsonSerializerSettings`3.Initialize">
            <summary>
                Must be called before passing an instance to Json.Net.  Should normally be called by a static property
                on the matching session class.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.SessionJsonSerializerSettings`3.SessionTypes">
            <summary>
                IEnumerable of .net types of session objects which are valid when serializing to or deserializing from
                json.  Derived types should override this property and add their corresponding session type.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.SessionJsonSerializerSettings`3.ValueTypes">
            <summary>
                IEnumerable of .net types of value types which are valid when serializing to or deserializing from json.
                Derived types should override this property and add any value types supported by their corresponding
                session type.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.SessionJsonSerializerSettings`3.ConstraintTypes">
            <summary>
                IEnumerable of .net types of constraint objects which are valid types when serializing to or
                deserializing from json.  Derived types should override this property if their corresponding session
                type supports any additional constraint types beyond this list.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Session.SignificantInput`1">
            <summary>
                An input along with a confidence value (0-1) that that input is worth letting the user know about.
            </summary>
            <typeparam name="TInput">Type of <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.SignificantInput`1.Input" />.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Session.SignificantInput`1.#ctor(System.Double,`0,Microsoft.ProgramSynthesis.Utils.Optional{System.Collections.Generic.IReadOnlyList{`0}})">
            <summary>
                Constructs a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Session.SignificantInput`1" /> with given input
                <paramref name="input"/> and confidence <paramref name="confidence"/>.
                If a cluster <paramref name="cluster" /> is provided, it must contain
                the input <paramref name="input"/>.
            </summary>
            <param name="confidence">The confidence in [0,1] that this input is significant.</param>
            <param name="input">The input.</param>
            <param name="cluster">The cluster, if any, of equivalently significant inputs.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.SignificantInput`1.Confidence">
            <summary>
                A confidence value in the range [0,1] where greater values mean higher confidence that this input should be shown
                to the user.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.SignificantInput`1.Input">
            <summary>
                This input.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Session.SignificantInput`1.Cluster">
            <summary>
                A cluster of significant inputs that are significant in the same way as this one.
                This cluster is guaranteed to contain <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Session.SignificantInput`1.Input"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.Distinguisher`1">
            <summary>
                A choice an input can correspond to, which is used to distinguish inputs when clustering. A good clustering
                contains one input for each value of the choice. A choice maps an input to one of <see cref="P:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.Distinguisher`1.NumChoices" />
                options, identified by the integers 0 through <see cref="P:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.Distinguisher`1.NumChoices" />. This mapping is performed by
                <see cref="P:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.Distinguisher`1.ChoiceFunc" /> (or <see cref="M:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.Distinguisher`1.ChoiceFor(`0)" />).
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.Distinguisher`1.#ctor(System.UInt32,System.Func{`0,System.Nullable{System.UInt32}},System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:System.Tuple`3" /> class.</summary>
            <param name="numChoices">The range of <paramref name="choiceFunc" /> is [0, numChoices).</param>
            <param name="choiceFunc">Function to compute the choice for a given input or <c>null</c> if not relevant to that input.</param>
            <param name="significantEvenIfCorrect">
                If true, then when <paramref name="choiceFunc" /> is non-<c>null</c>, this
                overrides the guess that the top-program is correct.
            </param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.Distinguisher`1.NumChoices">
            <summary>
                The range of <see cref="P:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.Distinguisher`1.ChoiceFunc" />/<see cref="M:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.Distinguisher`1.ChoiceFor(`0)" /> is [0, <see cref="P:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.Distinguisher`1.NumChoices" />).
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.Distinguisher`1.ChoiceFunc">
            <summary>
                Function to compute the value of this choice for a given input.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.Distinguisher`1.SignificantEvenIfCorrect">
            <summary>
                Allow inputs for which <see cref="P:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.Distinguisher`1.ChoiceFunc" /> returns a non-<c>null</c> value to be significant inputs even if
                they are considered to be correct already.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.Distinguisher`1.ChoiceFor(`0)">
            <summary>
                Compute the value of this choice for <paramref name="input" />.
            </summary>
            <param name="input">Input to compute choice for.</param>
            <returns>Choice selection for <paramref name="input" /> according to <see cref="P:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.Distinguisher`1.ChoiceFunc" />.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.Distinguisher`1.Choices">
            <summary>
                The set of all choice values possible for this choice.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.SignificantInputProgramProfile`3">
            <summary>
                A profile of correct programs used to generate significant inputs. It inc
            </summary>
            <typeparam name="TProgram"></typeparam>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.SignificantInputProgramProfile`3.TopPrograms">
            <summary>
               The top K programs that satisfy the specification.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.SignificantInputProgramProfile`3.RandomPrograms">
            <summary>
               Some randomly sampled programs that satisfies the specification.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.SignificantInputProgramProfile`3.TopProgram">
            <summary>
               The top program that satisfies the specification.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.SignificantInputProgramProfile`3.TopProgramNoInputs">
            <summary>
               The top program that satisfies the specification given no additional inputs.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.SignificantInputProgramProfile`3.#ctor(System.Collections.Generic.IReadOnlyList{`0},System.Collections.Generic.IReadOnlyList{`0},`0)">
            <summary>
                Default constructor.
            </summary>
            <param name="topPrograms">The top K programs.</param>
            <param name="randomPrograms">The randomly sampled programs.</param>
            <param name="topProgramNoInputs">The top programs given no additional inputs.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.SignificantInputProgramProfile`3.AnyTopProgram">
            <summary>
                Return the top program if known, and otherwise, the top program without inputs.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.SignificantInputProgramProfile`3.RankedPrograms">
            <summary>
                Return a ranked collection of the programs in this profile
                (i.e., top programs, followed by the top no inputs program, followed by
                the sampled programs), along with a function that identifies top program
                indices in this collection.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.ProgramSamplingStrategy">
            <summary>
                A class to represent program sampling strategies for generating significant inputs.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.ProgramSamplingStrategy.#ctor(System.Int32,System.Int32,System.Boolean)">
            <summary>
                Initialize a sampling strategy that takes <paramref name="numTopPrograms"/>
                top programs, <paramref name="numRandomPrograms"/> random programs, and uses only
                cached results if <paramref name="cachedOnly"/> is true.
            </summary>
            <param name="numTopPrograms"></param>
            <param name="numRandomPrograms"></param>
            <param name="cachedOnly"></param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.ProgramSamplingStrategy.NumTopPrograms">
            <summary>
                Number of top programs to sample.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.ProgramSamplingStrategy.NumRandomPrograms">
            <summary>
                Number of random programs to sample.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.ProgramSamplingStrategy.CachedOnly">
            <summary>
                Use only cached results, or actually perform learns.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.ProgramSamplingStrategy.DefaultSamplingStrategy">
            <summary>
                The default sampling strategy of picking top 5 and random 10 programs.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.ProgramSamplingStrategy.TopK(System.Int32,System.Boolean)">
            <summary>
               Build a non-cachedOnly sampling strategy that picks <paramref name="k"/>
               top programs.
            </summary>
            <param name="k">Number of top programs to pick.</param>
            <param name="cachedOnly">Use cached results only?</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.ProgramSamplingStrategy.TopKRandomK(System.Int32,System.Int32)">
            <summary>
               Build a non-cachedOnly sampling strategy that picks <paramref name="topK"/>
               top programs and <paramref name="randomK"/> randomly sampled programs.
            </summary>
            <param name="topK">Number of top programs to pick.</param>
            <param name="randomK">Number of programs to randomly sample.</param>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.ProgramSamplingStrategy.DefaultSamplingStrategies">
            <summary>
                These are the program sampling strategies, in order of how expensive they are.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.ProgramSamplingStrategy.SamplePrograms``4(Microsoft.ProgramSynthesis.Wrangling.Session.LearnProgramRequest{``1,``2,``3},System.Double,``0,System.Threading.CancellationToken)">
            <summary>
                Sample programs according to the given sampling strategy.
            </summary>
            <typeparam name="TSession">Type of the session.</typeparam>
            <typeparam name="TProgram">Type of the program.</typeparam>
            <typeparam name="TInput">Type of the inputs.</typeparam>
            <typeparam name="TOutput">Type of the outputs.</typeparam>
            <param name="request">The learning request.</param>
            <param name="confidenceThreshold">The confidence threshold.</param>
            <param name="session">The session to learn from.</param>
            <param name="cancel">The cancellation token.</param>
            <returns>A significant inputs program profile.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.ProgramSamplingStrategy.ToString">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.SignificantInputsEngine`3">
            <summary>
                The core algorithms to compute significant inputs.
            </summary>
            <typeparam name="TProgram">Type of the program.</typeparam>
            <typeparam name="TInput">Type of the input.</typeparam>
            <typeparam name="TOutput">Type of the output.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.SignificantInputsEngine`3.ConstructOutputTable(System.Collections.Generic.IReadOnlyList{`0},System.Collections.Generic.IReadOnlyList{`1},System.Threading.CancellationToken)">
            <summary>
               Return a table of output ids for each input and program.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.SignificantInputsEngine`3.ConstructDistinguisherTable(System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.Distinguisher{`1}},System.Collections.Generic.IReadOnlyList{`1},System.Threading.CancellationToken)">
            <summary>
                Return a table of distinguisher values for each input in
                <paramref name="inputs"/> and distinguisher in <paramref name="distinguishers"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.SignificantInputsEngine`3.ComputeProgramRepresentatives">
            <summary>
               Return a sublist of programs that cover all the unique behaviour with respect to the inputs.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.SignificantInputsEngine`3.InputSignature(System.Int32)">
            <summary>
                Given an input id <paramref name="inputId"/>, compute an input signature based on the outputs
                on programs and distinguishers.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.SignificantInputsEngine`3.InputClusters">
            <summary>
                Returns a sublist of inputs that cover all unique program and distinguisher behaviour,
                along with the set of all inputs that behave similar to each one.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.SignificantInputsEngine`3.SignificantInputClustersCover(Microsoft.ProgramSynthesis.Wrangling.Session.NonInteractiveSession{`0,`1,`2},System.Collections.Generic.HashSet{`1})">
            <summary>
                Set-cover based significant inputs computation. Informally, pick a set of inputs (preferably small)
                that can separate any two programs in <see cref="F:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.SignificantInputsEngine`3._programs"/>, and further, witness
                any value returned by <see cref="F:Microsoft.ProgramSynthesis.Wrangling.SignificantInputs.SignificantInputsEngine`3._distinguishers"/>.
            </summary>
            <param name="session">Session for which significant inputs are being computed.</param>
            <param name="constrainedInputs">Set of inputs that have already been constrained.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.TableProgram`1">
            <summary>
                A compound program that returns a table of multiple columns.
            </summary>
            <typeparam name="TRegion">The region of the field.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.TableProgram`1.Run(System.IO.TextReader)">
            <summary>
                Executes the program on the <paramref name="inputReader" /> to obtain the output.
            </summary>
            <param name="inputReader">The input reader.</param>
            <returns>The output table.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.TransformationProgram`3">
            <summary>
                A program which transforms values of type <typeparamref name="TInput" /> to values of type
                <typeparamref name="TOutput" />.
                The input and output types may be the same.
            </summary>
            <typeparam name="TProgram">The concrete class extending this.</typeparam>
            <typeparam name="TInput">The input type of the program.</typeparam>
            <typeparam name="TOutput">The output type of the program.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.TransformationProgram`3.#ctor(Microsoft.ProgramSynthesis.AST.ProgramNode,System.Double,System.Func{Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode})">
            <summary>
                Constructs a transformation program wrapping <paramref name="programNode" /> with the score
                <paramref name="score" />.
            </summary>
            <param name="programNode">The program to wrap.</param>
            <param name="score">The ranking score of <paramref name="programNode" />.</param>
            <param name="programNormalizingFunc">
                Optional function to transform <paramref name="programNode" />. The pre-transform
                <paramref name="programNode" /> can be accessed via <see cref="P:Microsoft.ProgramSynthesis.IProgram.RawProgramNode" />.
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.TransformationProgram`3.Run(`1)">
            <summary>
                Run this program to transform <paramref name="input" />.
            </summary>
            <param name="input">The input to be transformed.</param>
            <returns>The result of running the transformation program.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes">
            <summary>
                Stores textual attributes associated with every node (<see cref="T:Microsoft.ProgramSynthesis.Wrangling.Tree.Node"/>).
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.Attribute">
            <summary>
                Represent a Tree attribute.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.Attribute.Name">
            <summary>
                Name of the attribute.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.Attribute.Value">
            <summary>
                Value of the attribute.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.Attribute.#ctor(System.String,System.String)">
            <summary>
                Creates an attribute;.
            </summary>
            <param name="name">Name of the attribute.</param>
            <param name="value">Value of the attribute.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.Attribute.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.Attribute.Equals(Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.Attribute)">
            <inheritdoc cref="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.Attribute.Equals(System.Object)"/>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.Attribute.op_Inequality(Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.Attribute,Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.Attribute)">
            <summary>
                Determines whether the <paramref name="left"/> object is not equal to the <paramref name="right"/> object.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.Attribute.op_Equality(Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.Attribute,Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.Attribute)">
            <summary>
                Determines whether the <paramref name="left"/> object is equal to the <paramref name="right"/> object.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.StrongComparer">
            <summary>
               An equality comparer that compares both strong and weak attributes.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.StrongComparer.Default">
            <summary>
               Singleton instance.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.StrongComparer.Equals(Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes,Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.StrongComparer.GetHashCode(Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.CreateUnsafe(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.Attribute})">
            <summary>
               Does not check if attributes are unique
            </summary>
            <param name="attributes">Collection of distinct attributes</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.CreateSingle(Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.Attribute)">
            <summary>
               Creates Attributes with just one single attribute.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.Create(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.Attribute})">
            <summary>
               Creates attributes while ensuring distinct and non-null
            </summary>
            <param name="attributes"></param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.Item(System.String)">
            <summary>
                Retrieves an attribute given its name.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.StrongAttributes">
            <summary>
                Strong attributes.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.SoftAttributes">
            <summary>
                Soft attributes.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.AllAttributes">
            <summary>
                All attributes.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.TryGetValue(System.String,System.String@)">
            <inheritdoc cref="M:System.Collections.Generic.Dictionary`2.TryGetValue(`0,`1@)"/>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.Equals(Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.op_Equality(Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes,Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes)">
            <summary>
                Determines whether the <paramref name="left"/> object is equal to the <paramref name="right"/> object.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.op_Inequality(Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes,Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes)">
            <summary>
                Determines whether the <paramref name="left"/> object is not equal to the <paramref name="right"/> object.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.ToString">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes.Empty">
            <summary>
                An empty set of attributes.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Tree.UnaryPredicates">
            <summary>
             A class to store some predicates for hole nodes. We have 3 separate predicates:
              1. IsNullable: if true, this hole is allowed to match zero nodes.
              2. Type: specifies the label of the nodes this hole is allowed to match.
                 We have 2 special types: NA and Any representing match no labels or match any label.
              3. MatchLength: specifies the **maximum** number of nodes this hole can match. Either one or many.
              
              We have the additional condition that (MatchLength = Many ==> Type = Any)
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.UnaryPredicates.IsNullable">
            <summary>
             Nullability property 
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.UnaryPredicates.Type">
            <summary>
             Type attribute of nodes that the hole substitutes 
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.UnaryPredicates.Generalize(Microsoft.ProgramSynthesis.Wrangling.Tree.Node)">
            <summary>
               Generalize hole predicates assuming merge with a new node.
                    If the new node is "null", the IsNullable property is set to be True
                    If the new node is not a Hole Node:
                        If it has a different type than the Type predicate the Type predicate is set to "Any"
                    If the new node is a Hole Node:
                        If the new node is nullable, the IsNullable property is set to be True
                        If the new node has a different Type predicate, the Type property is set to "Any"
                        If there is a mismatch in Range Predicates, they mismathced property is set "NA"
               <param name="other"> Node with which the hole predicates are generalized </param>
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.UnaryPredicates.Check(Microsoft.ProgramSynthesis.Wrangling.Tree.Node)">
            <summary>
               Checks if the hole predicates are consistent with a give node
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.UnaryPredicates.Check(Microsoft.ProgramSynthesis.Wrangling.Tree.Node[])">
            <summary>
               Checks if the hole predicates are consistent with a given list of nodes 
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Tree.HoleNodeType">
            <summary>
                Enum for the type of hole node.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.Tree.HoleNodeType.TrueHole">
            <summary>
               True hole generated by anti-unification.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.Tree.HoleNodeType.SameNode">
            <summary>
               Same node generated by the remove same procedure.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Tree.HoleNode">
            <summary>
               Represent hole nodes in an AST
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.HoleNode.CreateTrueHole(System.String,Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes,Microsoft.ProgramSynthesis.Wrangling.Tree.UnaryPredicates,Microsoft.ProgramSynthesis.Wrangling.Tree.Node)">
            <summary>
               Safely create a frozen HoleNode. 
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.HoleNode.CreateSameNode(System.String,Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes,Microsoft.ProgramSynthesis.Wrangling.Tree.UnaryPredicates,Microsoft.ProgramSynthesis.Wrangling.Tree.Node)">
            <summary>
               Safely create a same node. 
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.HoleNode.Equals(Microsoft.ProgramSynthesis.Wrangling.Tree.HoleNode)">
            <summary>Indicates whether the current object is equal to another object of the same type.</summary>
            <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.HoleNode.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
            <returns>true if the specified object  is equal to the current object; otherwise, false.</returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.HoleNode.GetHashCode">
            <summary>Serves as the default hash function. </summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.HoleNode.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.HoleNode.AcceptVisitor``1(Microsoft.ProgramSynthesis.Wrangling.Tree.NodeVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.HoleNode.DeserializeFromXml(System.Xml.Linq.XElement)">
            <summary>
                Deserializes a HoleNode object.
            </summary>
            <param name="node">Serialized object</param>
            <returns>Deserialized object</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Tree.Node">
            <summary>
                Represents a node in a tree.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.Position">
            <summary>
                Represents the position of the node in a textual representation. 
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.Position.Line">
            <summary>
                Line number.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.Position.Column">
            <summary>
                Column number.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.Position.#ctor(System.Int32,System.Int32)">
            <summary>
                Creates a position.
            </summary>
            <param name="line">Line number.</param>
            <param name="column">Column number.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.Position.Of(System.Int32,System.Int32)">
            <summary>
                Creates a position.
            </summary>
            <param name="line">Line number.</param>
            <param name="column">Column number.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.Position.Of_UnChecked(System.Int32,System.Int32)">
            <summary>
                Creates a position. Method for deserialization without checks
            </summary>
            <param name="line">Line number.</param>
            <param name="column">Column number.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.Position.Equals(Microsoft.ProgramSynthesis.Wrangling.Tree.Node.Position)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.Position.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.Position.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.Position.op_Inequality(Microsoft.ProgramSynthesis.Wrangling.Tree.Node.Position,Microsoft.ProgramSynthesis.Wrangling.Tree.Node.Position)">
            <summary>
                Determines whether the <paramref name="left"/> object is not equal to the <paramref name="right"/> object.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.Position.op_Equality(Microsoft.ProgramSynthesis.Wrangling.Tree.Node.Position,Microsoft.ProgramSynthesis.Wrangling.Tree.Node.Position)">
            <summary>
                Determines whether the <paramref name="left"/> object is equal to the <paramref name="right"/> object.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.Position.op_LessThanOrEqual(Microsoft.ProgramSynthesis.Wrangling.Tree.Node.Position,Microsoft.ProgramSynthesis.Wrangling.Tree.Node.Position)">
            <summary>
                Determines whether the <paramref name="left"/> position is before to the <paramref name="right"/> position.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.Position.Missing">
            <summary>
                Value to be used when position data is missing.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.KnownSynthesisIrrelevantNodes">
            <summary>
                A dictionary of nodes that are not relevant for the synthesis process. This information
                can be used to improve the synthesis performance. 
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.AddSynthesisIrrelevantNodes(System.Collections.Generic.IReadOnlyDictionary{System.String,Microsoft.ProgramSynthesis.Wrangling.Tree.Node})">
            <summary>
                Add new synthesis irrelevant nodes. See <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.KnownSynthesisIrrelevantNodes" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.#ctor(System.String,Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes,Microsoft.ProgramSynthesis.Wrangling.Tree.Node[],Microsoft.ProgramSynthesis.Wrangling.Tree.Node)">
            <summary>
                Constructs a node from its elements.
            </summary>
            <param name="label">The Label.</param>
            <param name="attributes">The attributes.</param>
            <param name="children">The Children.</param>
            <param name="parent">The Parent.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.LabelCounts">
            <summary>
                The set of labels in this node and subnodes, with their multiplicities.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.Count">
            <summary>
                Returns the total number of nodes that the tree rooted in this node contains.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.Label">
            <summary>
                The label.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.Attributes">
            <summary>
                The attributes.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.Parent">
            <summary>
                The parent of the node
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.StartPosition">
            <summary>
                The start position (line, column) in a text representation of the tree.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.EndPosition">
            <summary>
                The end position (line, column) in a text representation of the tree.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.HasPosition">
            <summary>
                 True if and only if the node has source position information.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.Children">
            <summary>
                The children.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.AddChild(Microsoft.ProgramSynthesis.Wrangling.Tree.Node,System.Boolean)">
            <summary>
               Add a child to the end of Children.
            </summary>
            <param name="child">Child to be added.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.RemoveChild(Microsoft.ProgramSynthesis.Wrangling.Tree.Node)">
            <summary>
               Remove a child from Children.
            </summary>
            <param name="child">Child to be removed.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.ReplaceChildAt(System.Int32,Microsoft.ProgramSynthesis.Wrangling.Tree.Node,System.Boolean)">
            <summary>
                Replace child at position <paramref name="i"/> with <paramref name="child"/>.
            </summary>
            <param name="i">Position to replace at.</param>
            <param name="child">The new child to replace with.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.FindFirstDescendantByLabel(System.String)">
            <summary>
                Returns the first node in the tree (in order) that has label <paramref name="label" />
            </summary>
            <param name="label">The target label.</param>
            <returns>The first node with label <paramref name="label" /></returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.Ancestors">
            <summary>
                Gets an enumerable of all the ancestors of the current node.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.DeepClone">
            <summary>
                Returns a deep clone of this node.
            </summary>
            <returns>The clone.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.AcceptVisitor``1(Microsoft.ProgramSynthesis.Wrangling.Tree.NodeVisitor{``0})">
            <summary>
                Returns the value computed by the hierarchical application of the <paramref name="visitor" /> instance.
            </summary>
            <param name="visitor">The visitor.</param>
            <returns>The value.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.WithChildren(Microsoft.ProgramSynthesis.Wrangling.Tree.Node[])">
            <summary>
                Create a new node by replacing the current node's children list.
                This does not modify the current node and does not set the new node's parent field.
            </summary>
            <param name="newChildren">The new children list.</param>
            <returns>Node with new children.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.TreePathsToDescendants(System.Predicate{Microsoft.ProgramSynthesis.Wrangling.Tree.Node})">
            <summary>
                Returns all paths to the descendants that satisfy <paramref name="predicate" />.
                Each path uses the same kind of <see cref="N:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep" />.
            </summary>
            <param name="predicate">The filtering function.</param>
            <returns>Descendants that satisfy <paramref name="predicate" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.AllPossibleStepsTo(Microsoft.ProgramSynthesis.Wrangling.Tree.Node,Microsoft.ProgramSynthesis.Wrangling.Tree.Node)">
            <summary>
                Returns all possible steps from <paramref name="source" /> to <paramref name="dest" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.SerializeToXml">
            <summary>
                Serializes to XML
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.AddNonSerializableInfoToTree(Microsoft.ProgramSynthesis.Wrangling.Tree.Node)">
            <summary>
                Adds parent attribute to the tree and initializes the properties attribute.
                This method should be used only during deserialization of trees, where the parent information will be lost.
                Previous values of this attribute, if any, will get over-written.
            </summary>
            <param name="node">Deserialized node.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.ToText">
            <summary>
                Generates a text representation of the tree.
            </summary>
            <returns>Text representation of the tree.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.DCap(System.Int32)">
            <summary>
                Computes the d-cap for the node, for a given d > 0.
            </summary>
            <param name="d"></param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.SetCount(System.Int32)">
            <summary>
            Method to set count on deserialization of the node
            </summary>
            <param name="count"></param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.Node.SetHashCode(System.Int32)">
            <summary>
            Method to set hashcode on deserialization of the node
            </summary>
            <param name="hashCode"></param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Tree.NodeVisitor`1">
            <summary>
                Base class for <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Tree.Node"/> visitor.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Tree.SequenceNode">
            <summary>
                Represents a "sequence" <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Tree.Node" /> that has multiple similar elements.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.SequenceNode.#ctor(System.String,Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes,Microsoft.ProgramSynthesis.Wrangling.Tree.Node,Microsoft.ProgramSynthesis.Wrangling.Tree.Node[],Microsoft.ProgramSynthesis.Wrangling.Tree.Node)">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.SequenceNode.Separator">
            <summary>
                Separator node for the sequence.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.SequenceNode.GetEnumerator">
            <summary>Returns an enumerator that iterates through the collection.</summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.SequenceNode.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary>
            <returns>An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.SequenceNode.Equals(Microsoft.ProgramSynthesis.Wrangling.Tree.SequenceNode)">
            <summary>Indicates whether the current object is equal to another object of the same type.</summary>
            <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.SequenceNode.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
            <returns>true if the specified object  is equal to the current object; otherwise, false.</returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.SequenceNode.GetHashCode">
            <summary>Serves as the default hash function. </summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.SequenceNode.DeepClone">
            <inheritdoc />  
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.SequenceNode.AcceptVisitor``1(Microsoft.ProgramSynthesis.Wrangling.Tree.NodeVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.SequenceNode.DeserializeFromXml(System.Xml.Linq.XElement)">
            <summary>
                Deserializes a SequenceNode object.
            </summary>
            <param name="node">Serialized object</param>
            <returns>Deserialized object</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Tree.StructNode">
            <summary>
                Represents a structure <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Tree.Node" /> that may have multiple children.
                The children are ordered.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.StructNode.#ctor(System.String,Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes,Microsoft.ProgramSynthesis.Wrangling.Tree.Node[],Microsoft.ProgramSynthesis.Wrangling.Tree.Node)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.StructNode.Create(System.String,Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes,Microsoft.ProgramSynthesis.Wrangling.Tree.Node[],Microsoft.ProgramSynthesis.Wrangling.Tree.Node)">
            <summary>
               Safely create a frozen StructNode. The number of children
               cannot be changed after creation.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.StructNode.CreateUnsafe(System.String,Microsoft.ProgramSynthesis.Wrangling.Tree.Attributes,Microsoft.ProgramSynthesis.Wrangling.Tree.Node)">
            <summary>
               Create a non-finalized StructNode. On creating a node using this method,
               FinalizeChildren is to be called on it, before using it for any other operations.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.StructNode.Equals(Microsoft.ProgramSynthesis.Wrangling.Tree.StructNode)">
            <summary>Indicates whether the current object is equal to another object of the same type.</summary>
            <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.StructNode.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
            <returns>true if the specified object  is equal to the current object; otherwise, false.</returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.StructNode.GetHashCode">
            <summary>Serves as the default hash function. </summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.StructNode.DeepClone">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.StructNode.AcceptVisitor``1(Microsoft.ProgramSynthesis.Wrangling.Tree.NodeVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.StructNode.DeserializeFromXml(System.Xml.Linq.XElement)">
            <summary>
                Deserializes a StructNode object.
            </summary>
            <param name="node">Serialized object</param>
            <returns>Deserialized object</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePath">
            <summary>
                Represents a path to retrieve a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Tree.Node" /> from another <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Tree.Node" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePath.#ctor(Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.TreePathStep[])">
            <summary>
                Constructs a path from its corresponding steps.
            </summary>
            <param name="steps">The corresponding steps.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePath.#ctor(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.TreePathStep})">
            <summary>
                Constructs a path from its corresponding steps.
            </summary>
            <param name="steps">The corresponding steps.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePath.#ctor(System.String[])">
            <summary>
                Constructs a path from its corresponding steps.
            </summary>
            <param name="steps">The corresponding steps.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePath.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Constructs a path from its corresponding steps.
            </summary>
            <param name="steps">The corresponding steps.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePath.Steps">
            <summary>
                The steps in this path.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePath.Score">
            <summary>
                The score of this path.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePath.Equals(Microsoft.ProgramSynthesis.Wrangling.Tree.TreePath)">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePath.RenderHumanReadable">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePath.RenderXML">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePath.Find(Microsoft.ProgramSynthesis.Wrangling.Tree.Node)">
            <summary>
                Finds the destination node identified by this path.
            </summary>
            <param name="node">The source node.</param>
            <returns>
                The destination node.c
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePath.Join(Microsoft.ProgramSynthesis.Wrangling.Tree.TreePath[])">
            <summary>
                Joins several paths into a path.
            </summary>
            <param name="paths">The list of paths that need to join together.</param>
            <returns>The joined path.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePath.ParseFromXML(System.Xml.Linq.XElement)">
            <summary>
                Load a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePath" /> that had been serialized to XML.
            </summary>
            <param name="pathElement">An XML-representation of a path.</param>
            <returns>The path deserialized from <paramref name="pathElement" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePath.ParseFromHumanReadable(System.String)">
            <summary>
                Deserializes a string into a <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePath" />.
            </summary>
            <param name="path">A string representation of a path.</param>
            <returns>The deserialized <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePath" /> of <paramref name="path" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePath.Serialize">
            <summary>
                Serializes this path into a string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePath.ToString">
            <summary>
                Returns a TreePath string representation.
            </summary>
            <returns>
                A TreePath string.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePath.Equals(System.Object)">
            <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePath.GetHashCode">
            <summary>
                Serves as the default hash function.
            </summary>
            <returns>
                A hash code for the current object.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.CurrentStep">
            <summary>
                The step to access the current node.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.CurrentStep.Score">
            <summary>
                The ranking score of this step.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.CurrentStep.Equals(Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.CurrentStep)">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.CurrentStep.Serialize">
            <summary>
                Serializes the step.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.CurrentStep.Find(Microsoft.ProgramSynthesis.Wrangling.Tree.Node)">
            <summary>
                Find the parent node. 
            </summary>
            <returns>The parent node.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.CurrentStep.ToString">
            <summary>
                Returns a string that represents the current object.
            </summary>
            <returns>
                A string that represents the current object.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthLabelStep">
            <summary>
                The step to access the kth element in the list that matches a label.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthLabelStep.#ctor(System.String,System.Int32)">
            <summary>
                Constructs this step from an integer.
            </summary>
            <param name="label">The label.</param>
            <param name="k">The index.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthLabelStep.Label">
            <summary>
                The label.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthLabelStep.K">
            <summary>
                The index.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthLabelStep.Score">
            <summary>
                The ranking score of this step.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthLabelStep.Equals(Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthLabelStep)">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthLabelStep.Serialize">
            <summary>
                Serializes the step.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthLabelStep.Find(Microsoft.ProgramSynthesis.Wrangling.Tree.Node)">
            <summary>
                Finds the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthLabelStep.K" /> <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthLabelStep.Label" /> element of <paramref name="node" />,
                null if such element does not exist.
            </summary>
            <param name="node">The array.</param>
            <returns>The <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthLabelStep.K" /> <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthLabelStep.Label" /> element.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthLabelStep.ToString">
            <summary>
                Returns a string that represents the current object.
            </summary>
            <returns>
                A string that represents the current object.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthLabelStep.Equals(System.Object)">
            <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthLabelStep.GetHashCode">
            <summary>
                Serves as the default hash function.
            </summary>
            <returns>
                A hash code for the current object.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthStep">
            <summary>
                The step to access the kth child.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthStep.#ctor(System.Int32)">
            <summary>
                Constructs this step from an integer.
            </summary>
            <param name="k">The index.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthStep.K">
            <summary>
                The index.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthStep.Score">
            <summary>
                The ranking score of this step..
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthStep.Equals(Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthStep)">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthStep.Serialize">
            <summary>
                Serializes the step.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthStep.Find(Microsoft.ProgramSynthesis.Wrangling.Tree.Node)">
            <summary>
                Finds the <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthStep.K" /> element of <paramref name="node" />,
                null if out of range
            </summary>
            <param name="node">The array.</param>
            <returns>The <see cref="P:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthStep.K" /> element.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthStep.ToString">
            <summary>
                Returns a string that represents the current object.
            </summary>
            <returns>
                A string that represents the current object.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthStep.Equals(System.Object)">
            <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.KthStep.GetHashCode">
            <summary>
                Serves as the default hash function.
            </summary>
            <returns>
                A hash code for the current object.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.ParentStep">
            <summary>
                The step to access the parent node.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.ParentStep.Score">
            <summary>
                The ranking score of this step..
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.ParentStep.Equals(Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.ParentStep)">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.ParentStep.Serialize">
            <summary>
                Serializes the step.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.ParentStep.Find(Microsoft.ProgramSynthesis.Wrangling.Tree.Node)">
            <summary>
                Find the parent node. 
            </summary>
            <returns>The parent node.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.ParentStep.ToString">
            <summary>
                Returns a string that represents the current object.
            </summary>
            <returns>
                A string that represents the current object.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.RightSiblingTokenStep">
            <summary>
                The step to access the right sibling token.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.RightSiblingTokenStep.Score">
            <summary>
                The ranking score of this step..
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.RightSiblingTokenStep.Equals(Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.RightSiblingTokenStep)">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.RightSiblingTokenStep.Serialize">
            <summary>
                Serializes the step.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.RightSiblingTokenStep.Find(Microsoft.ProgramSynthesis.Wrangling.Tree.Node)">
            <summary>
                Find the parent node. 
            </summary>
            <returns>The parent node.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.RightSiblingTokenStep.ToString">
            <summary>
                Returns a string that represents the current object.
            </summary>
            <returns>
                A string that represents the current object.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.TreePathStep">
            <summary>
                Class for specifying a specific step in <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePath" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.TreePathStep.Score">
            <summary>
                The ranking score of this step.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.TreePathStep.Find(Microsoft.ProgramSynthesis.Wrangling.Tree.Node)">
            <summary>
                Finds the node located from <paramref name="node" /> to these steps.
            </summary>
            <param name="node">The node.</param>
            <returns>The destination node.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.TreePathStep.Serialize">
            <summary>
                Serializes the step.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.TreePathStep.From(System.String)">
            <summary>
                Creates a step from its string representation.
            </summary>
            <param name="step">The step string representation</param>
            <returns>The corresponding <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Tree.TreePathStep.TreePathStep" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.UnknownType.Equals(Microsoft.ProgramSynthesis.Wrangling.UnknownType)">
            <summary>Indicates whether the current object is equal to another object of the same type.</summary>
            <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.UnknownType.IsValidObject(Microsoft.ProgramSynthesis.Wrangling.ITypedValue)">
            <summary>
                Checks if an object is valid element of the given type.
            </summary>
            <param name="obj">Object to check.</param>
            <returns>True if object can be treated as a value of this type or false otherwise.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.UnknownType.IsAssignableFrom(Microsoft.ProgramSynthesis.Wrangling.IType)">
            <summary>
                Checks if this type is a superset of another type. That is, if true, then whenever <paramref name="other" />
                returns true for <see cref="M:Microsoft.ProgramSynthesis.Wrangling.IType.IsValidObject(Microsoft.ProgramSynthesis.Wrangling.ITypedValue)" /> so does this.
            </summary>
            <param name="other">Type to check if it can be used whenever this is expected.</param>
            <returns>True if <paramref name="other" /> is a subtype of this type.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.UnknownType.Equals(Microsoft.ProgramSynthesis.Wrangling.IType)">
            <summary>Indicates whether the current object is equal to another object of the same type.</summary>
            <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.UnknownType.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
            <returns>true if the specified object  is equal to the current object; otherwise, false.</returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Wrangling.UnknownType.GetHashCode">
            <summary>Serves as the default hash function. </summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Wrangling.XmlSchemaPrintVisitor`3">
            <summary>
            SchemaPrintVisitor used to get <see cref="F:Microsoft.ProgramSynthesis.AST.ASTSerializationFormat.XML"/> representation of SchemaNode.
            </summary>
        </member>
        <member name="M:System.Linq.EnumerableLinqEx.SequenceEqual``1(``0[],``0[])">
            <summary>
                Checks if 2 arrays of the same type are sequencial equal.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <param name="source">Source sequence when array.</param>
            <param name="target">Target sequence when array.</param>
        </member>
        <member name="M:System.Linq.EnumerableLinqEx.SequenceEqual``1(System.Collections.Generic.IReadOnlyList{``0},System.Collections.Generic.IReadOnlyList{``0})">
            <summary>
                Checks if 2 IReadOnlyList of TSource of the same type are sequencial equal.
            </summary>
            <typeparam name="TSource">Source sequence element type.</typeparam>
            <param name="source">Source sequence when array.</param>
            <param name="target">Target sequence when array.</param>
        </member>
        <member name="T:System.Collections.Generic.MultiValueDictionary`2">
            <summary>
            A MultiValueDictionary can be viewed as a <see cref="T:System.Collections.IDictionary" /> that allows multiple
            values for any given unique key. While the MultiValueDictionary API is
            mostly the same as that of a regular <see cref="T:System.Collections.IDictionary" />, there is a distinction
            in that getting the value for a key returns a <see cref="T:System.Collections.Generic.IReadOnlyCollection`1" /> of values
            rather than a single value associated with that key. Additionally,
            there is functionality to allow adding or removing more than a single
            value at once.
            
            The MultiValueDictionary can also be viewed as a IReadOnlyDictionary&lt;TKey,IReadOnlyCollection&lt;TValue&gt;t&gt;
            where the <see cref="T:System.Collections.Generic.IReadOnlyCollection`1" /> is abstracted from the view of the programmer.
            
            For a read-only MultiValueDictionary, see <see cref="!:ILookup&lt;TKey, TValue&gt;" />.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
        </member>
        <member name="F:System.Collections.Generic.MultiValueDictionary`2.dictionary">
            <summary>
            The private dictionary that this class effectively wraps around
            </summary>
        </member>
        <member name="F:System.Collections.Generic.MultiValueDictionary`2.NewCollectionFactory">
            <summary>
            The function to construct a new <see cref="T:System.Collections.Generic.ICollection`1"/>
            </summary>
            <returns></returns>
        </member>
        <member name="F:System.Collections.Generic.MultiValueDictionary`2.version">
            <summary>
            The current version of this MultiValueDictionary used to determine MultiValueDictionary modification
            during enumeration
            </summary>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />
            class that is empty, has the default initial capacity, and uses the default
            <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> for <typeparamref name="TKey"/>.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.MultiValueDictionary`2" /> class that is
            empty, has the specified initial capacity, and uses the default <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>
            for <typeparamref name="TKey"/>.
            </summary>
            <param name="capacity">Initial number of keys that the <see cref="T:System.Collections.Generic.MultiValueDictionary`2" /> will allocate space for</param>
            <exception cref="T:System.ArgumentOutOfRangeException">capacity must be >= 0</exception>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.MultiValueDictionary`2" /> class
            that is empty, has the default initial capacity, and uses the
            specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.
            </summary>
            <param name="comparer">Specified comparer to use for the <typeparamref name="TKey"/>s</param>
            <remarks>If <paramref name="comparer"/> is set to null, then the default <see cref="T:System.Collections.IEqualityComparer" /> for <typeparamref name="TKey"/> is used.</remarks>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.MultiValueDictionary`2" /> class
            that is empty, has the specified initial capacity, and uses the
            specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.
            </summary>
            <param name="capacity">Initial number of keys that the <see cref="T:System.Collections.Generic.MultiValueDictionary`2" /> will allocate space for</param>
            <param name="comparer">Specified comparer to use for the <typeparamref name="TKey"/>s</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Capacity must be >= 0</exception>
            <remarks>If <paramref name="comparer"/> is set to null, then the default <see cref="T:System.Collections.IEqualityComparer" /> for <typeparamref name="TKey"/> is used.</remarks>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.IReadOnlyCollection{`1}}})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.MultiValueDictionary`2" /> class that contains
            elements copied from the specified IEnumerable&lt;KeyValuePair&lt;TKey, IReadOnlyCollection&lt;TValue&gt;&gt;&gt; and uses the
            default <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> for the <typeparamref name="TKey"/> type.
            </summary>
            <param name="enumerable">IEnumerable to copy elements into this from</param>
            <exception cref="T:System.ArgumentNullException">enumerable must be non-null</exception>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.IReadOnlyCollection{`1}}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.MultiValueDictionary`2" /> class that contains
            elements copied from the specified IEnumerable&lt;KeyValuePair&lt;TKey, IReadOnlyCollection&lt;TValue&gt;&gt;&gt; and uses the
            specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.
            </summary>
            <param name="enumerable">IEnumerable to copy elements into this from</param>
            <param name="comparer">Specified comparer to use for the <typeparamref name="TKey"/>s</param>
            <exception cref="T:System.ArgumentNullException">enumerable must be non-null</exception>
            <remarks>If <paramref name="comparer"/> is set to null, then the default <see cref="T:System.Collections.IEqualityComparer" /> for <typeparamref name="TKey"/> is used.</remarks>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.Create``1">
            <summary>
            Creates a new new instance of the <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />
            class that is empty, has the default initial capacity, and uses the default
            <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> for <typeparamref name="TKey"/>. The
            internal dictionary will use instances of the <typeparamref name="TValueCollection"/>
            class as its collection type.
            </summary>
            <typeparam name="TValueCollection">
            The collection type that this <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />
            will contain in its internal dictionary.
            </typeparam>
            <returns>A new <see cref="T:System.Collections.Generic.MultiValueDictionary`2" /> with the specified
            parameters.</returns>
            <exception cref="T:System.InvalidOperationException"><typeparamref name="TValueCollection"/> must not have
            IsReadOnly set to true by default.</exception>
            <remarks>
            Note that <typeparamref name="TValueCollection"/> must implement <see cref="T:System.Collections.Generic.ICollection`1"/>
            in addition to being constructable through new(). The collection returned from the constructor
            must also not have IsReadOnly set to True by default.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.Create``1(System.Int32)">
            <summary>
            Creates a new new instance of the <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />
            class that is empty, has the specified initial capacity, and uses the default
            <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> for <typeparamref name="TKey"/>. The
            internal dictionary will use instances of the <typeparamref name="TValueCollection"/>
            class as its collection type.
            </summary>
            <typeparam name="TValueCollection">
            The collection type that this <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />
            will contain in its internal dictionary.
            </typeparam>
            <param name="capacity">Initial number of keys that the <see cref="T:System.Collections.Generic.MultiValueDictionary`2" /> will allocate space for</param>
            <returns>A new <see cref="T:System.Collections.Generic.MultiValueDictionary`2" /> with the specified
            parameters.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Capacity must be >= 0</exception>
            <exception cref="T:System.InvalidOperationException"><typeparamref name="TValueCollection"/> must not have
            IsReadOnly set to true by default.</exception>
            <remarks>
            Note that <typeparamref name="TValueCollection"/> must implement <see cref="T:System.Collections.Generic.ICollection`1"/>
            in addition to being constructable through new(). The collection returned from the constructor
            must also not have IsReadOnly set to True by default.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.Create``1(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new new instance of the <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />
            class that is empty, has the default initial capacity, and uses the specified
            <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> for <typeparamref name="TKey"/>. The
            internal dictionary will use instances of the <typeparamref name="TValueCollection"/>
            class as its collection type.
            </summary>
            <typeparam name="TValueCollection">
            The collection type that this <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />
            will contain in its internal dictionary.
            </typeparam>
            <param name="comparer">Specified comparer to use for the <typeparamref name="TKey"/>s</param>
            <exception cref="T:System.InvalidOperationException"><typeparamref name="TValueCollection"/> must not have
            IsReadOnly set to true by default.</exception>
            <returns>A new <see cref="T:System.Collections.Generic.MultiValueDictionary`2" /> with the specified
            parameters.</returns>
            <remarks>If <paramref name="comparer"/> is set to null, then the default <see cref="T:System.Collections.IEqualityComparer" /> for <typeparamref name="TKey"/> is used.</remarks>
            <remarks>
            Note that <typeparamref name="TValueCollection"/> must implement <see cref="T:System.Collections.Generic.ICollection`1"/>
            in addition to being constructable through new(). The collection returned from the constructor
            must also not have IsReadOnly set to True by default.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.Create``1(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new new instance of the <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />
            class that is empty, has the specified initial capacity, and uses the specified
            <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> for <typeparamref name="TKey"/>. The
            internal dictionary will use instances of the <typeparamref name="TValueCollection"/>
            class as its collection type.
            </summary>
            <typeparam name="TValueCollection">
            The collection type that this <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />
            will contain in its internal dictionary.
            </typeparam>
            <param name="capacity">Initial number of keys that the <see cref="T:System.Collections.Generic.MultiValueDictionary`2" /> will allocate space for</param>
            <param name="comparer">Specified comparer to use for the <typeparamref name="TKey"/>s</param>
            <returns>A new <see cref="T:System.Collections.Generic.MultiValueDictionary`2" /> with the specified
            parameters.</returns>
            <exception cref="T:System.InvalidOperationException"><typeparamref name="TValueCollection"/> must not have
            IsReadOnly set to true by default.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Capacity must be >= 0</exception>
            <remarks>If <paramref name="comparer"/> is set to null, then the default <see cref="T:System.Collections.IEqualityComparer" /> for <typeparamref name="TKey"/> is used.</remarks>
            <remarks>
            Note that <typeparamref name="TValueCollection"/> must implement <see cref="T:System.Collections.Generic.ICollection`1"/>
            in addition to being constructable through new(). The collection returned from the constructor
            must also not have IsReadOnly set to True by default.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.Create``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.IReadOnlyCollection{`1}}})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.MultiValueDictionary`2" /> class that contains
            elements copied from the specified IEnumerable&lt;KeyValuePair&lt;TKey, IReadOnlyCollection&lt;TValue&gt;&gt;&gt;
            and uses the default <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> for the <typeparamref name="TKey"/> type.
            The internal dictionary will use instances of the <typeparamref name="TValueCollection"/>
            class as its collection type.
            </summary>
            <typeparam name="TValueCollection">
            The collection type that this <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />
            will contain in its internal dictionary.
            </typeparam>
            <param name="enumerable">IEnumerable to copy elements into this from</param>
            <returns>A new <see cref="T:System.Collections.Generic.MultiValueDictionary`2" /> with the specified
            parameters.</returns>
            <exception cref="T:System.InvalidOperationException"><typeparamref name="TValueCollection"/> must not have
            IsReadOnly set to true by default.</exception>
            <exception cref="T:System.ArgumentNullException">enumerable must be non-null</exception>
            <remarks>
            Note that <typeparamref name="TValueCollection"/> must implement <see cref="T:System.Collections.Generic.ICollection`1"/>
            in addition to being constructable through new(). The collection returned from the constructor
            must also not have IsReadOnly set to True by default.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.Create``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.IReadOnlyCollection{`1}}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.MultiValueDictionary`2" /> class that contains
            elements copied from the specified IEnumerable&lt;KeyValuePair&lt;TKey, IReadOnlyCollection&lt;TValue&gt;&gt;&gt;
            and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> for the <typeparamref name="TKey"/> type.
            The internal dictionary will use instances of the <typeparamref name="TValueCollection"/>
            class as its collection type.
            </summary>
            <typeparam name="TValueCollection">
            The collection type that this <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />
            will contain in its internal dictionary.
            </typeparam>
            <param name="enumerable">IEnumerable to copy elements into this from</param>
            <param name="comparer">Specified comparer to use for the <typeparamref name="TKey"/>s</param>
            <returns>A new <see cref="T:System.Collections.Generic.MultiValueDictionary`2" /> with the specified
            parameters.</returns>
            <exception cref="T:System.InvalidOperationException"><typeparamref name="TValueCollection"/> must not have
            IsReadOnly set to true by default.</exception>
            <exception cref="T:System.ArgumentNullException">enumerable must be non-null</exception>
            <remarks>If <paramref name="comparer"/> is set to null, then the default <see cref="T:System.Collections.IEqualityComparer" /> for <typeparamref name="TKey"/> is used.</remarks>
            <remarks>
            Note that <typeparamref name="TValueCollection"/> must implement <see cref="T:System.Collections.Generic.ICollection`1"/>
            in addition to being constructable through new(). The collection returned from the constructor
            must also not have IsReadOnly set to True by default.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.Create``1(System.Func{``0})">
            <summary>
            Creates a new new instance of the <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />
            class that is empty, has the default initial capacity, and uses the default
            <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> for <typeparamref name="TKey"/>. The
            internal dictionary will use instances of the <typeparamref name="TValueCollection"/>
            class as its collection type.
            </summary>
            <typeparam name="TValueCollection">
            The collection type that this <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />
            will contain in its internal dictionary.
            </typeparam>
            <param name="collectionFactory">A function to create a new <see cref="T:System.Collections.Generic.ICollection`1"/> to use
            in the internal dictionary store of this <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />.</param>
            <returns>A new <see cref="T:System.Collections.Generic.MultiValueDictionary`2" /> with the specified
            parameters.</returns>
            <exception cref="T:System.InvalidOperationException"><paramref name="collectionFactory"/> must create collections with
            IsReadOnly set to true by default.</exception>
            <remarks>
            Note that <typeparamref name="TValueCollection"/> must implement <see cref="T:System.Collections.Generic.ICollection`1"/>
            in addition to being constructable through new(). The collection returned from the constructor
            must also not have IsReadOnly set to True by default.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.Create``1(System.Int32,System.Func{``0})">
            <summary>
            Creates a new new instance of the <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />
            class that is empty, has the specified initial capacity, and uses the default
            <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> for <typeparamref name="TKey"/>. The
            internal dictionary will use instances of the <typeparamref name="TValueCollection"/>
            class as its collection type.
            </summary>
            <typeparam name="TValueCollection">
            The collection type that this <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />
            will contain in its internal dictionary.
            </typeparam>
            <param name="capacity">Initial number of keys that the <see cref="T:System.Collections.Generic.MultiValueDictionary`2" /> will allocate space for</param>
            <param name="collectionFactory">A function to create a new <see cref="T:System.Collections.Generic.ICollection`1"/> to use
            in the internal dictionary store of this <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />.</param>
            <returns>A new <see cref="T:System.Collections.Generic.MultiValueDictionary`2" /> with the specified
            parameters.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Capacity must be >= 0</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="collectionFactory"/> must create collections with
            IsReadOnly set to true by default.</exception>
            <remarks>
            Note that <typeparamref name="TValueCollection"/> must implement <see cref="T:System.Collections.Generic.ICollection`1"/>
            in addition to being constructable through new(). The collection returned from the constructor
            must also not have IsReadOnly set to True by default.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.Create``1(System.Collections.Generic.IEqualityComparer{`0},System.Func{``0})">
            <summary>
            Creates a new new instance of the <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />
            class that is empty, has the default initial capacity, and uses the specified
            <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> for <typeparamref name="TKey"/>. The
            internal dictionary will use instances of the <typeparamref name="TValueCollection"/>
            class as its collection type.
            </summary>
            <typeparam name="TValueCollection">
            The collection type that this <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />
            will contain in its internal dictionary.
            </typeparam>
            <param name="comparer">Specified comparer to use for the <typeparamref name="TKey"/>s</param>
            <param name="collectionFactory">A function to create a new <see cref="T:System.Collections.Generic.ICollection`1"/> to use
            in the internal dictionary store of this <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />.</param>
            <exception cref="T:System.InvalidOperationException"><paramref name="collectionFactory"/> must create collections with
            IsReadOnly set to true by default.</exception>
            <returns>A new <see cref="T:System.Collections.Generic.MultiValueDictionary`2" /> with the specified
            parameters.</returns>
            <remarks>If <paramref name="comparer"/> is set to null, then the default <see cref="T:System.Collections.IEqualityComparer" /> for <typeparamref name="TKey"/> is used.</remarks>
            <remarks>
            Note that <typeparamref name="TValueCollection"/> must implement <see cref="T:System.Collections.Generic.ICollection`1"/>
            in addition to being constructable through new(). The collection returned from the constructor
            must also not have IsReadOnly set to True by default.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.Create``1(System.Int32,System.Collections.Generic.IEqualityComparer{`0},System.Func{``0})">
            <summary>
            Creates a new new instance of the <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />
            class that is empty, has the specified initial capacity, and uses the specified
            <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> for <typeparamref name="TKey"/>. The
            internal dictionary will use instances of the <typeparamref name="TValueCollection"/>
            class as its collection type.
            </summary>
            <typeparam name="TValueCollection">
            The collection type that this <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />
            will contain in its internal dictionary.
            </typeparam>
            <param name="capacity">Initial number of keys that the <see cref="T:System.Collections.Generic.MultiValueDictionary`2" /> will allocate space for</param>
            <param name="comparer">Specified comparer to use for the <typeparamref name="TKey"/>s</param>
            <param name="collectionFactory">A function to create a new <see cref="T:System.Collections.Generic.ICollection`1"/> to use
            in the internal dictionary store of this <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />.</param>
            <returns>A new <see cref="T:System.Collections.Generic.MultiValueDictionary`2" /> with the specified
            parameters.</returns>
            <exception cref="T:System.InvalidOperationException"><paramref name="collectionFactory"/> must create collections with
            IsReadOnly set to true by default.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Capacity must be >= 0</exception>
            <remarks>If <paramref name="comparer"/> is set to null, then the default <see cref="T:System.Collections.IEqualityComparer" /> for <typeparamref name="TKey"/> is used.</remarks>
            <remarks>
            Note that <typeparamref name="TValueCollection"/> must implement <see cref="T:System.Collections.Generic.ICollection`1"/>
            in addition to being constructable through new(). The collection returned from the constructor
            must also not have IsReadOnly set to True by default.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.Create``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.IReadOnlyCollection{`1}}},System.Func{``0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.MultiValueDictionary`2" /> class that contains
            elements copied from the specified IEnumerable&lt;KeyValuePair&lt;TKey, IReadOnlyCollection&lt;TValue&gt;&gt;&gt;
            and uses the default <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> for the <typeparamref name="TKey"/> type.
            The internal dictionary will use instances of the <typeparamref name="TValueCollection"/>
            class as its collection type.
            </summary>
            <typeparam name="TValueCollection">
            The collection type that this <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />
            will contain in its internal dictionary.
            </typeparam>
            <param name="enumerable">IEnumerable to copy elements into this from</param>
            <param name="collectionFactory">A function to create a new <see cref="T:System.Collections.Generic.ICollection`1"/> to use
            in the internal dictionary store of this <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />.</param>
            <returns>A new <see cref="T:System.Collections.Generic.MultiValueDictionary`2" /> with the specified
            parameters.</returns>
            <exception cref="T:System.InvalidOperationException"><paramref name="collectionFactory"/> must create collections with
            IsReadOnly set to true by default.</exception>
            <exception cref="T:System.ArgumentNullException">enumerable must be non-null</exception>
            <remarks>
            Note that <typeparamref name="TValueCollection"/> must implement <see cref="T:System.Collections.Generic.ICollection`1"/>
            in addition to being constructable through new(). The collection returned from the constructor
            must also not have IsReadOnly set to True by default.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.Create``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.IReadOnlyCollection{`1}}},System.Collections.Generic.IEqualityComparer{`0},System.Func{``0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.MultiValueDictionary`2" /> class that contains
            elements copied from the specified IEnumerable&lt;KeyValuePair&lt;TKey, IReadOnlyCollection&lt;TValue&gt;&gt;&gt;
            and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> for the <typeparamref name="TKey"/> type.
            The internal dictionary will use instances of the <typeparamref name="TValueCollection"/>
            class as its collection type.
            </summary>
            <typeparam name="TValueCollection">
            The collection type that this <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />
            will contain in its internal dictionary.
            </typeparam>
            <param name="enumerable">IEnumerable to copy elements into this from</param>
            <param name="comparer">Specified comparer to use for the <typeparamref name="TKey"/>s</param>
            <param name="collectionFactory">A function to create a new <see cref="T:System.Collections.Generic.ICollection`1"/> to use
            in the internal dictionary store of this <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />.</param>
            <returns>A new <see cref="T:System.Collections.Generic.MultiValueDictionary`2" /> with the specified
            parameters.</returns>
            <exception cref="T:System.InvalidOperationException"><paramref name="collectionFactory"/> must create collections with
            IsReadOnly set to true by default.</exception>
            <exception cref="T:System.ArgumentNullException">enumerable must be non-null</exception>
            <remarks>If <paramref name="comparer"/> is set to null, then the default <see cref="T:System.Collections.IEqualityComparer" /> for <typeparamref name="TKey"/> is used.</remarks>
            <remarks>
            Note that <typeparamref name="TValueCollection"/> must implement <see cref="T:System.Collections.Generic.ICollection`1"/>
            in addition to being constructable through new(). The collection returned from the constructor
            must also not have IsReadOnly set to True by default.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.Add(`0,`1)">
            <summary>
            Adds the specified <typeparamref name="TKey"/> and <typeparamref name="TValue"/> to the <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/>.
            </summary>
            <param name="key">The <typeparamref name="TKey"/> of the element to add.</param>
            <param name="value">The <typeparamref name="TValue"/> of the element to add.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <c>null</c>.</exception>
            <remarks>
            Unlike the Add for <see cref="T:System.Collections.IDictionary" />, the <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/> Add will not
            throw any exceptions. If the given <typeparamref name="TKey"/> is already in the <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/>,
            then <typeparamref name="TValue"/> will be added to <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/> associated with <paramref name="key"/>
            </remarks>
            <remarks>
            A call to this Add method will always invalidate any currently running enumeration regardless
            of whether the Add method actually modified the <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.AddRange(`0,System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Adds a number of key-value pairs to this <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/>, where
            the key for each value is <paramref name="key"/>, and the value for a pair
            is an element from <paramref name="values"/>
            </summary>
            <param name="key">The <typeparamref name="TKey"/> of all entries to add</param>
            <param name="values">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of values to add</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> and <paramref name="values"/> must be non-null</exception>
            <remarks>
            A call to this AddRange method will always invalidate any currently running enumeration regardless
            of whether the AddRange method actually modified the <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/>.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.Remove(`0)">
            <summary>
            Removes every <typeparamref name="TValue"/> associated with the given <typeparamref name="TKey"/>
            from the <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/>.
            </summary>
            <param name="key">The <typeparamref name="TKey"/> of the elements to remove</param>
            <returns><c>true</c> if the removal was successful; otherwise <c>false</c></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <c>null</c>.</exception>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.Remove(`0,`1)">
            <summary>
            Removes the first instance (if any) of the given <typeparamref name="TKey"/>-<typeparamref name="TValue"/>
            pair from this <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/>.
            </summary>
            <param name="key">The <typeparamref name="TKey"/> of the element to remove</param>
            <param name="value">The <typeparamref name="TValue"/> of the element to remove</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> must be non-null</exception>
            <returns><c>true</c> if the removal was successful; otherwise <c>false</c></returns>
            <remarks>
            If the <typeparamref name="TValue"/> being removed is the last one associated with its <typeparamref name="TKey"/>, then that
            <typeparamref name="TKey"/> will be removed from the <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/> and its
            associated <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/> will be freed as if a call to <see cref="M:System.Collections.Generic.MultiValueDictionary`2.Remove(`0)"/>
            had been made.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.Contains(`0,`1)">
            <summary>
            Determines if the given <typeparamref name="TKey"/>-<typeparamref name="TValue"/>
            pair exists within this <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/>.
            </summary>
            <param name="key">The <typeparamref name="TKey"/> of the element.</param>
            <param name="value">The <typeparamref name="TValue"/> of the element.</param>
            <returns><c>true</c> if found; otherwise <c>false</c></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> must be non-null</exception>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.ContainsValue(`1)">
            <summary>
            Determines if the given <typeparamref name="TValue"/> exists within this <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/>.
            </summary>
            <param name="value">A <typeparamref name="TValue"/> to search the <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/> for</param>
            <returns><c>true</c> if the <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/> contains the <paramref name="value"/>; otherwise <c>false</c></returns>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.Clear">
            <summary>
            Removes every <typeparamref name="TKey"/> and <typeparamref name="TValue"/> from this
            <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/>.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.ContainsKey(`0)">
            <summary>
            Determines if the given <typeparamref name="TKey"/> exists within this <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/> and has
            at least one <typeparamref name="TValue"/> associated with it.
            </summary>
            <param name="key">The <typeparamref name="TKey"/> to search the <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/> for</param>
            <returns><c>true</c> if the <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/> contains the requested <typeparamref name="TKey"/>;
            otherwise <c>false</c>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> must be non-null</exception>
        </member>
        <member name="P:System.Collections.Generic.MultiValueDictionary`2.Keys">
            <summary>
            Gets each <typeparamref name="TKey"/> in this <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/> that
            has one or more associated <typeparamref name="TValue"/>.
            </summary>
            <value>
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> containing each <typeparamref name="TKey"/>
            in this <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/> that has one or more associated
            <typeparamref name="TValue"/>.
            </value>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.TryGetValue(`0,System.Collections.Generic.IReadOnlyCollection{`1}@)">
            <summary>
            Attempts to get the <typeparamref name="TValue"/> associated with the given
            <typeparamref name="TKey"/> and place it into <paramref name="value"/>.
            </summary>
            <param name="key">The <typeparamref name="TKey"/> of the element to retrieve</param>
            <param name="value">
            When this method returns, contains the <typeparamref name="TValue"/> associated with the specified
            <typeparamref name="TKey"/> if it is found; otherwise contains the default value of <typeparamref name="TValue"/>.
            </param>
            <returns>
            <c>true</c> if the <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/> contains an element with the specified
            <typeparamref name="TKey"/>; otherwise, <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> must be non-null</exception>
        </member>
        <member name="P:System.Collections.Generic.MultiValueDictionary`2.Values">
            <summary>
            Gets an enumerable of <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/> from this <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/>,
            where each <see cref="T:System.Collections.Generic.IReadOnlyCollection`1" /> is the collection of every <typeparamref name="TValue"/> associated
            with a <typeparamref name="TKey"/> present in the <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/>.
            </summary>
            <value>An IEnumerable of each <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/> in this
            <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/></value>
        </member>
        <member name="P:System.Collections.Generic.MultiValueDictionary`2.Item(`0)">
            <summary>
            Get every <typeparamref name="TValue"/> associated with the given <typeparamref name="TKey"/>. If
            <paramref name="key"/> is not found in this <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/>, will
            throw a <see cref="T:System.Collections.Generic.KeyNotFoundException"/>.
            </summary>
            <param name="key">The <typeparamref name="TKey"/> of the elements to retrieve.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> must be non-null</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException"><paramref name="key"/> does not have any associated
            <typeparamref name="TValue"/>s in this <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/>.</exception>
            <value>
            An <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/> containing every <typeparamref name="TValue"/>
            associated with <paramref name="key"/>.
            </value>
            <remarks>
            Note that the <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/> returned will change alongside any changes
            to the <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/>
            </remarks>
        </member>
        <member name="P:System.Collections.Generic.MultiValueDictionary`2.Count">
            <summary>
            Returns the number of <typeparamref name="TKey"/>s with one or more associated <typeparamref name="TValue"/>
            in this <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/>.
            </summary>
            <value>The number of <typeparamref name="TKey"/>s in this <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/>.</value>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.GetEnumerator">
            <summary>
            Get an Enumerator over the <typeparamref name="TKey"/>-<see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/>
            pairs in this <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/>.
            </summary>
            <returns>an Enumerator over the <typeparamref name="TKey"/>-<see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/>
            pairs in this <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/>.</returns>
        </member>
        <member name="T:System.Collections.Generic.MultiValueDictionary`2.Enumerator">
            <summary>
            The Enumerator class for a <see cref="T:System.Collections.Generic.MultiValueDictionary`2"/>
            that iterates over <typeparamref name="TKey"/>-<see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/>
            pairs.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.Enumerator.#ctor(System.Collections.Generic.MultiValueDictionary{`0,`1})">
            <summary>
            Constructor for the enumerator
            </summary>
            <param name="multiValueDictionary">A MultiValueDictionary to iterate over</param>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.Enumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:System.Collections.Generic.MultiValueDictionary`2.Enumerator.Dispose">
            <summary>
            Frees resources associated with this Enumerator
            </summary>
        </member>
        <member name="T:System.Collections.Generic.MultiValueDictionary`2.InnerCollectionView">
            <summary>
            An inner class that functions as a view of an ICollection within a MultiValueDictionary
            </summary>
        </member>
        <member name="T:Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Properties.Resources.Arg_ArrayLengthsDiffer">
            <summary>
              Looks up a localized string similar to Array lengths must be the same..
            </summary>
        </member>
        <member name="P:Properties.Resources.Arg_ArrayPlusOffTooSmall">
            <summary>
              Looks up a localized string similar to Destination array is not long enough to copy all the items in the collection. Check array index and length..
            </summary>
        </member>
        <member name="P:Properties.Resources.Arg_BitArrayTypeUnsupported">
            <summary>
              Looks up a localized string similar to Only supported array types for CopyTo on BitArrays are Boolean[], Int32[] and Byte[]..
            </summary>
        </member>
        <member name="P:Properties.Resources.Arg_HSCapacityOverflow">
            <summary>
              Looks up a localized string similar to HashSet capacity is too big..
            </summary>
        </member>
        <member name="P:Properties.Resources.Arg_HTCapacityOverflow">
            <summary>
              Looks up a localized string similar to Hashtable&apos;s capacity overflowed and went negative. Check load factor, capacity and the current size of the table..
            </summary>
        </member>
        <member name="P:Properties.Resources.Arg_InsufficientSpace">
            <summary>
              Looks up a localized string similar to Insufficient space in the target location to copy the information..
            </summary>
        </member>
        <member name="P:Properties.Resources.Arg_MultiRank">
            <summary>
              Looks up a localized string similar to Multi dimension array is not supported on this operation..
            </summary>
        </member>
        <member name="P:Properties.Resources.Arg_NonZeroLowerBound">
            <summary>
              Looks up a localized string similar to The lower bound of target array must be zero..
            </summary>
        </member>
        <member name="P:Properties.Resources.Arg_RankMultiDimNotSupported">
            <summary>
              Looks up a localized string similar to Only single dimensional arrays are supported for the requested action..
            </summary>
        </member>
        <member name="P:Properties.Resources.Arg_WrongType">
            <summary>
              Looks up a localized string similar to The value &apos;{0}&apos; is not of type &apos;{1}&apos; and cannot be used in this generic collection..
            </summary>
        </member>
        <member name="P:Properties.Resources.Argument_AddingDuplicate">
            <summary>
              Looks up a localized string similar to An item with the same key has already been added..
            </summary>
        </member>
        <member name="P:Properties.Resources.Argument_ArrayTooLarge">
            <summary>
              Looks up a localized string similar to The input array length must not exceed Int32.MaxValue / {0}. Otherwise BitArray.Length would exceed Int32.MaxValue..
            </summary>
        </member>
        <member name="P:Properties.Resources.Argument_ImplementIComparable">
            <summary>
              Looks up a localized string similar to At least one object must implement IComparable..
            </summary>
        </member>
        <member name="P:Properties.Resources.Argument_InvalidArgumentForComparison">
            <summary>
              Looks up a localized string similar to Type of argument is not compatible with the generic comparer..
            </summary>
        </member>
        <member name="P:Properties.Resources.Argument_InvalidArrayType">
            <summary>
              Looks up a localized string similar to Target array type is not compatible with the type of items in the collection..
            </summary>
        </member>
        <member name="P:Properties.Resources.Argument_InvalidOffLen">
            <summary>
              Looks up a localized string similar to Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection..
            </summary>
        </member>
        <member name="P:Properties.Resources.ArgumentOutOfRange_BiggerThanCollection">
            <summary>
              Looks up a localized string similar to Larger than collection size..
            </summary>
        </member>
        <member name="P:Properties.Resources.ArgumentOutOfRange_Count">
            <summary>
              Looks up a localized string similar to Count must be positive and count must refer to a location within the string/array/collection..
            </summary>
        </member>
        <member name="P:Properties.Resources.ArgumentOutOfRange_Index">
            <summary>
              Looks up a localized string similar to Index was out of range. Must be non-negative and less than the size of the collection..
            </summary>
        </member>
        <member name="P:Properties.Resources.ArgumentOutOfRange_ListInsert">
            <summary>
              Looks up a localized string similar to Index must be within the bounds of the List..
            </summary>
        </member>
        <member name="P:Properties.Resources.ArgumentOutOfRange_NeedNonNegNum">
            <summary>
              Looks up a localized string similar to Non-negative number required..
            </summary>
        </member>
        <member name="P:Properties.Resources.ArgumentOutOfRange_NeedNonNegNumRequired">
            <summary>
              Looks up a localized string similar to Non-negative number required..
            </summary>
        </member>
        <member name="P:Properties.Resources.ArgumentOutOfRange_SmallCapacity">
            <summary>
              Looks up a localized string similar to capacity was less than the current size..
            </summary>
        </member>
        <member name="P:Properties.Resources.CopyTo_ArgumentsTooSmall">
            <summary>
              Looks up a localized string similar to Destination array is not long enough to copy all the items in the collection. Check array index and length..
            </summary>
        </member>
        <member name="P:Properties.Resources.Create_TValueCollectionReadOnly">
            <summary>
              Looks up a localized string similar to The specified TValueCollection creates collections that have IsReadOnly set to true by default. TValueCollection must be a mutable ICollection..
            </summary>
        </member>
        <member name="P:Properties.Resources.ExternalLinkedListNode">
            <summary>
              Looks up a localized string similar to The LinkedList node does not belong to current LinkedList..
            </summary>
        </member>
        <member name="P:Properties.Resources.IndexOutOfRange">
            <summary>
              Looks up a localized string similar to Index {0} is out of range..
            </summary>
        </member>
        <member name="P:Properties.Resources.Invalid_Array_Type">
            <summary>
              Looks up a localized string similar to Target array type is not compatible with the type of items in the collection..
            </summary>
        </member>
        <member name="P:Properties.Resources.InvalidOperation_EmptyQueue">
            <summary>
              Looks up a localized string similar to Queue empty..
            </summary>
        </member>
        <member name="P:Properties.Resources.InvalidOperation_EmptyStack">
            <summary>
              Looks up a localized string similar to Stack empty..
            </summary>
        </member>
        <member name="P:Properties.Resources.InvalidOperation_EnumEnded">
            <summary>
              Looks up a localized string similar to Enumeration already finished..
            </summary>
        </member>
        <member name="P:Properties.Resources.InvalidOperation_EnumFailedVersion">
            <summary>
              Looks up a localized string similar to Collection was modified; enumeration operation may not execute..
            </summary>
        </member>
        <member name="P:Properties.Resources.InvalidOperation_EnumNotStarted">
            <summary>
              Looks up a localized string similar to Enumeration has not started. Call MoveNext..
            </summary>
        </member>
        <member name="P:Properties.Resources.InvalidOperation_EnumOpCantHappen">
            <summary>
              Looks up a localized string similar to Enumeration has either not started or has already finished..
            </summary>
        </member>
        <member name="P:Properties.Resources.LinkedListEmpty">
            <summary>
              Looks up a localized string similar to The LinkedList is empty..
            </summary>
        </member>
        <member name="P:Properties.Resources.LinkedListNodeIsAttached">
            <summary>
              Looks up a localized string similar to The LinkedList node already belongs to a LinkedList..
            </summary>
        </member>
        <member name="P:Properties.Resources.NotSupported_KeyCollectionSet">
            <summary>
              Looks up a localized string similar to Mutating a key collection derived from a dictionary is not allowed..
            </summary>
        </member>
        <member name="P:Properties.Resources.NotSupported_SortedListNestedWrite">
            <summary>
              Looks up a localized string similar to This operation is not supported on SortedList nested types because they require modifying the original SortedList..
            </summary>
        </member>
        <member name="P:Properties.Resources.NotSupported_ValueCollectionSet">
            <summary>
              Looks up a localized string similar to Mutating a value collection derived from a dictionary is not allowed..
            </summary>
        </member>
        <member name="P:Properties.Resources.ReadOnly_Modification">
            <summary>
              Looks up a localized string similar to The collection is read-only.
            </summary>
        </member>
    </members>
</doc>
